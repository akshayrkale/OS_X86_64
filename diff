diff --git a/bin/hello/.shell.c.swp b/bin/hello/.shell.c.swp
deleted file mode 100644
index 1eaea6b..0000000
Binary files a/bin/hello/.shell.c.swp and /dev/null differ
diff --git a/bin/hello/shell.c b/bin/hello/shell.c
index 8dbcc7e..4d07a1b 100644
--- a/bin/hello/shell.c
+++ b/bin/hello/shell.c
@@ -1,51 +1,106 @@
 #include <stdio.h>
 #include <stdlib.h>
-#include <test.h>
+#include <memory.h>
+#include <stringTokenizer.h>
+#include <parser.h>
 #include <errno.h>
 #include <string.h>
+#include <shell.h>
 
-void parallel_fork(){
 
 
+char PS1[200]="SBUSH";
 
-    //int *pipe = (int*)malloc(4*sizeof(int));
-
-
-}
-int main(int argc, char* argv[], char* envp[])
+int main3 (int argc, char *argv[], char* envp[])
 {
-#define tot 250
-	
-//     dup2_test_case();
-//    parallel_fork();
-    int pid[tot] ;
-
-    int i;
-    int p;
-    int status=(uint64_t)&p;
-
-    for(i=0;i<tot;i++){
-
-
-        pid[i] = fork();
-
-       if(pid[i] == 0){
-
-            execve("/bin/malluaunty",NULL,NULL);
-
-        }
-
-      }
-    status=status;
-     //for(i=0;i<tot;i++);;
-     {
-         printf("chpid[%d]= %d",0,pid[0]);
-         waitpid(2,&status,0);
-   }
-printf("\n***PARENT EXITNG***\n");
-
 
+	/*printf(" Agrc is %d\n",argc);
+	printf("Argv[0] = %s\n",argv[0]);
+	printf("Envp[0] = %s\n\n",envp[0]);
+	printf("Starting shell\n");*/
+
+
+	char cmdLine[MAXLINE];
+
+
+	int fd=0,ret;
+
+	char temp[20]; //just for storing the command name in case of testing if the command is a builtin or not
+
+	//char x[10] ="akshay";
+	parseInfo *info; //info stores all the information returned by parser.
+	//printf("Akshay Kale %s, \n",x);
+	//exit(0);
+
+	if(argv[1]!=NULL)
+	{
+		//printf("executing script");
+		fd=open(argv[1],0);
+		//printf("opened");
+	}
+
+	while(1)
+	{
+		//cmdLine = "Santosh 1 2 3 | ls -l";
+
+		if(argv[1] == NULL)
+		{
+			printf("%s> ",PS1);
+			//read_line(0,cmdLine);
+		}
+		else
+		{
+			//printf("here");
+			ret=read_line(fd, cmdLine);
+			while (cmdLine[0] == '#')
+				ret=read_line(fd,cmdLine);
+			if(ret == -1)
+				break;
+		}
+    strcpy(cmdLine,"malluaunty");
+        printf("entered: %s",cmdLine);
+    
+		if (cmdLine == NULL) {
+			printf("Unable to read last command\n");
+			continue;
+		}
+
+		if(!(*cmdLine)){
+			//printf("No command entered\n");
+			continue;
+		}
+
+		printf("Calling parser%s",cmdLine);
+		info = parseModified(cmdLine,envp);
+		if (info == NULL){
+			free(cmdLine);
+			continue;
+		}
+
+		//prints the info struct
+		print_info(info);
+
+		strcpy(temp,info->CommArray[0]->commandName);
+
+		if(strcmp(temp,"set")==0||strcmp(temp,"cd")==0 || strcmp(temp,"exit")==0){
+
+			printf("Executing Builtin command\n");
+			executeBuiltins(info,envp);
+		}
+
+		else{
+            printf("Calling Execute");
+			execute_cmd(info,envp);
+
+		}
+
+
+
+		static int loop=0;
+		loop++;
+		//printf("Out of execute%d\n",loop++);
+		//exit(0);
+	}/* while(1) */
+	//printf("BYE BYE");
+	return 0;
 }
-
-
-
diff --git a/crt/crt1.c b/crt/crt1.c
index b2fbd60..0f2ce14 100644
--- a/crt/crt1.c
+++ b/crt/crt1.c
@@ -7,8 +7,10 @@ void _start(void) {
 //	char* argv[0];
 //	char* envp[0];
 	int res;
-	res = main(0, NULL, NULL);
-   
+//	res = main(0, NULL, NULL);
+ volatile int x=89;
+  res=  main(*((uint64_t*)(&x+0x3UL)),(char**)(uint64_t*)(&x+0x5UL), (char **)((&x+5) +  (2*(*(&x+3)+ 1))));
+
     exit(res);
   }
 
diff --git a/diff b/diff
index 682c32f..e69de29 100644
--- a/diff
+++ b/diff
@@ -1,741 +0,0 @@
-diff --git a/akshay.iso b/akshay.iso
-index 96af093..1a63852 100644
-Binary files a/akshay.iso and b/akshay.iso differ
-diff --git a/bin/hello/shell.c b/bin/hello/shell.c
-index b47d91c..d8490b3 100644
---- a/bin/hello/shell.c
-+++ b/bin/hello/shell.c
-@@ -44,6 +44,7 @@ closedir(dir);*/
-         if(pid == 0){
-              int i = 499999;
-              while(i--);
-+             execve("/bin/malluaunty",NULL,NULL);
-          ps();
-             printf("Child done\n");
-        }
-diff --git a/include/sys/paging.h b/include/sys/paging.h
-index a7f9983..faeaae7 100644
---- a/include/sys/paging.h
-+++ b/include/sys/paging.h
-@@ -19,7 +19,7 @@
- #define AVAIL2_LIM  0xffffffff87ffd000 //check this value o sbrocks
- 
- #define VIDEO_START  0xffffffff800B8000 
--#define USERSTACKTOP PGSIZE
-+#define USERSTACKTOP 0x00000000f0000000
- 
- typedef struct PageStruct {
- 	// Next page on the free list.
-diff --git a/include/sys/process.h b/include/sys/process.h
-index 61b3c61..80dd074 100644
---- a/include/sys/process.h
-+++ b/include/sys/process.h
-@@ -91,6 +91,8 @@ int copyvmas(ProcStruct *proc);
- int get_running_process();
- uint64_t inc_brk(uint64_t n);
- int proc_sleep(void* t);
-+uint64_t execve(const char *arg1,const char *arg2[],const  char* arg3[]);
-+int copy_args_to_stack(uint64_t stacktop,int argc);
- 
- #define POPA \
- 	"\tmovq 0(%%rsp),%%r15\n" \
-diff --git a/include/sys/syscall.h b/include/sys/syscall.h
-index 2996093..0482b05 100644
---- a/include/sys/syscall.h
-+++ b/include/sys/syscall.h
-@@ -46,6 +46,8 @@ int sys_ps();
- uint64_t sys_brk(uint64_t n);
- int sys_sleep(void* t);
- int sys_dup2(int oldfd,int newfd);
-+int sys_execve(const char *arg1,const char *arg2[],const  char* arg3[])
-+;
- 
- 
- #endif
-diff --git a/kernel b/kernel
-index 37dc38c..77df9cb 100755
-Binary files a/kernel and b/kernel differ
-diff --git a/obj/bin/hello/shell.o b/obj/bin/hello/shell.o
-index 8f73dd3..2eb2989 100644
-Binary files a/obj/bin/hello/shell.o and b/obj/bin/hello/shell.o differ
-diff --git a/obj/bin/malluaunty/tp.o b/obj/bin/malluaunty/tp.o
-index c6dc155..149c1d5 100644
-Binary files a/obj/bin/malluaunty/tp.o and b/obj/bin/malluaunty/tp.o differ
-diff --git a/obj/bin/tabz/tab.o b/obj/bin/tabz/tab.o
-index 4b1721c..ea5cf1a 100644
-Binary files a/obj/bin/tabz/tab.o and b/obj/bin/tabz/tab.o differ
-diff --git a/obj/crt/crt1.o b/obj/crt/crt1.o
-index c9f967b..f9365ad 100644
-Binary files a/obj/crt/crt1.o and b/obj/crt/crt1.o differ
-diff --git a/obj/libc/alarm.o b/obj/libc/alarm.o
-index 3cd2287..e8c0702 100644
-Binary files a/obj/libc/alarm.o and b/obj/libc/alarm.o differ
-diff --git a/obj/libc/cat.o b/obj/libc/cat.o
-index 5be260c..3bd3f63 100644
-Binary files a/obj/libc/cat.o and b/obj/libc/cat.o differ
-diff --git a/obj/libc/chdir.o b/obj/libc/chdir.o
-index 5f7090c..ee73181 100644
-Binary files a/obj/libc/chdir.o and b/obj/libc/chdir.o differ
-diff --git a/obj/libc/close.o b/obj/libc/close.o
-index ecb6637..0bd7674 100644
-Binary files a/obj/libc/close.o and b/obj/libc/close.o differ
-diff --git a/obj/libc/closedir.o b/obj/libc/closedir.o
-index adbf7aa..f331384 100644
-Binary files a/obj/libc/closedir.o and b/obj/libc/closedir.o differ
-diff --git a/obj/libc/dup.o b/obj/libc/dup.o
-index aa55c7b..9424c7a 100644
-Binary files a/obj/libc/dup.o and b/obj/libc/dup.o differ
-diff --git a/obj/libc/dup2.o b/obj/libc/dup2.o
-index d584f30..71d689b 100644
-Binary files a/obj/libc/dup2.o and b/obj/libc/dup2.o differ
-diff --git a/obj/libc/error.o b/obj/libc/error.o
-index 5a095bc..498aaf4 100644
-Binary files a/obj/libc/error.o and b/obj/libc/error.o differ
-diff --git a/obj/libc/execve.o b/obj/libc/execve.o
-index a5f9f5a..dc3bb0b 100644
-Binary files a/obj/libc/execve.o and b/obj/libc/execve.o differ
-diff --git a/obj/libc/exit.o b/obj/libc/exit.o
-index 990d211..cc12dd0 100644
-Binary files a/obj/libc/exit.o and b/obj/libc/exit.o differ
-diff --git a/obj/libc/fork.o b/obj/libc/fork.o
-index 9784229..61e0c21 100644
-Binary files a/obj/libc/fork.o and b/obj/libc/fork.o differ
-diff --git a/obj/libc/getcwd.o b/obj/libc/getcwd.o
-index 6bc3de7..b9c81cd 100644
-Binary files a/obj/libc/getcwd.o and b/obj/libc/getcwd.o differ
-diff --git a/obj/libc/lseek.o b/obj/libc/lseek.o
-index f7bb106..ca21177 100644
-Binary files a/obj/libc/lseek.o and b/obj/libc/lseek.o differ
-diff --git a/obj/libc/malloc.o b/obj/libc/malloc.o
-index 866e5bf..09b177c 100644
-Binary files a/obj/libc/malloc.o and b/obj/libc/malloc.o differ
-diff --git a/obj/libc/open.o b/obj/libc/open.o
-index df5102c..cef132d 100644
-Binary files a/obj/libc/open.o and b/obj/libc/open.o differ
-diff --git a/obj/libc/opendir.o b/obj/libc/opendir.o
-index 4ded7f5..5897bce 100644
-Binary files a/obj/libc/opendir.o and b/obj/libc/opendir.o differ
-diff --git a/obj/libc/pipe.o b/obj/libc/pipe.o
-index df7c94d..732715c 100644
-Binary files a/obj/libc/pipe.o and b/obj/libc/pipe.o differ
-diff --git a/obj/libc/printf.o b/obj/libc/printf.o
-index 4c4d215..9040483 100644
-Binary files a/obj/libc/printf.o and b/obj/libc/printf.o differ
-diff --git a/obj/libc/process.o b/obj/libc/process.o
-index 53e36b2..2b11284 100644
-Binary files a/obj/libc/process.o and b/obj/libc/process.o differ
-diff --git a/obj/libc/ps.o b/obj/libc/ps.o
-index a026db4..9931403 100644
-Binary files a/obj/libc/ps.o and b/obj/libc/ps.o differ
-diff --git a/obj/libc/read.o b/obj/libc/read.o
-index d013633..b9deff0 100644
-Binary files a/obj/libc/read.o and b/obj/libc/read.o differ
-diff --git a/obj/libc/readdir.o b/obj/libc/readdir.o
-index e1d6d6d..e413407 100644
-Binary files a/obj/libc/readdir.o and b/obj/libc/readdir.o differ
-diff --git a/obj/libc/scanf.o b/obj/libc/scanf.o
-index 93fdbe0..1c3a04a 100644
-Binary files a/obj/libc/scanf.o and b/obj/libc/scanf.o differ
-diff --git a/obj/libc/sleep.o b/obj/libc/sleep.o
-index 6ee9d99..3df2002 100644
-Binary files a/obj/libc/sleep.o and b/obj/libc/sleep.o differ
-diff --git a/obj/libc/string.o b/obj/libc/string.o
-index 23badfe..d24d076 100644
-Binary files a/obj/libc/string.o and b/obj/libc/string.o differ
-diff --git a/obj/libc/testCases.o b/obj/libc/testCases.o
-index b1334a7..64e3289 100644
-Binary files a/obj/libc/testCases.o and b/obj/libc/testCases.o differ
-diff --git a/obj/libc/write.o b/obj/libc/write.o
-index 42fb943..c1c483b 100644
-Binary files a/obj/libc/write.o and b/obj/libc/write.o differ
-diff --git a/obj/sys/gdt.o b/obj/sys/gdt.o
-index eddd242..a9390aa 100644
-Binary files a/obj/sys/gdt.o and b/obj/sys/gdt.o differ
-diff --git a/obj/sys/idt.o b/obj/sys/idt.o
-index 51d3336..914d9af 100644
-Binary files a/obj/sys/idt.o and b/obj/sys/idt.o differ
-diff --git a/obj/sys/isr.o b/obj/sys/isr.o
-index 5a97762..a983abe 100644
-Binary files a/obj/sys/isr.o and b/obj/sys/isr.o differ
-diff --git a/obj/sys/keyboard.o b/obj/sys/keyboard.o
-index 18bd681..c2e7f81 100644
-Binary files a/obj/sys/keyboard.o and b/obj/sys/keyboard.o differ
-diff --git a/obj/sys/kstring.o b/obj/sys/kstring.o
-index 2f4e0ea..5a92ffd 100644
-Binary files a/obj/sys/kstring.o and b/obj/sys/kstring.o differ
-diff --git a/obj/sys/main.o b/obj/sys/main.o
-index 146f3c2..5f26336 100644
-Binary files a/obj/sys/main.o and b/obj/sys/main.o differ
-diff --git a/obj/sys/paging.o b/obj/sys/paging.o
-index 3c001af..7e88098 100644
-Binary files a/obj/sys/paging.o and b/obj/sys/paging.o differ
-diff --git a/obj/sys/pic.o b/obj/sys/pic.o
-index 06d0488..4dd5d27 100644
-Binary files a/obj/sys/pic.o and b/obj/sys/pic.o differ
-diff --git a/obj/sys/pipe.o b/obj/sys/pipe.o
-index fe1f1fd..cdcdec7 100644
-Binary files a/obj/sys/pipe.o and b/obj/sys/pipe.o differ
-diff --git a/obj/sys/printf.o b/obj/sys/printf.o
-index 9a4089b..e1c0115 100644
-Binary files a/obj/sys/printf.o and b/obj/sys/printf.o differ
-diff --git a/obj/sys/process.o b/obj/sys/process.o
-index 778d390..3110734 100644
-Binary files a/obj/sys/process.o and b/obj/sys/process.o differ
-diff --git a/obj/sys/syscall.o b/obj/sys/syscall.o
-index 64d2446..db4e54c 100644
-Binary files a/obj/sys/syscall.o and b/obj/sys/syscall.o differ
-diff --git a/obj/sys/tarfs.o b/obj/sys/tarfs.o
-index f5ed92b..1e5992f 100644
-Binary files a/obj/sys/tarfs.o and b/obj/sys/tarfs.o differ
-diff --git a/obj/sys/timer.o b/obj/sys/timer.o
-index 27d5b02..d4c1690 100644
-Binary files a/obj/sys/timer.o and b/obj/sys/timer.o differ
-diff --git a/obj/sys/utils.o b/obj/sys/utils.o
-index 1183a2e..edeb5e3 100644
-Binary files a/obj/sys/utils.o and b/obj/sys/utils.o differ
-diff --git a/obj/tarfs.o b/obj/tarfs.o
-index 514d346..c7f3222 100644
-Binary files a/obj/tarfs.o and b/obj/tarfs.o differ
-diff --git a/rootfs/bin/hello b/rootfs/bin/hello
-index 579d1c0..999d4a7 100755
-Binary files a/rootfs/bin/hello and b/rootfs/bin/hello differ
-diff --git a/rootfs/bin/malluaunty b/rootfs/bin/malluaunty
-index 4d441c3..a15e0e4 100755
-Binary files a/rootfs/bin/malluaunty and b/rootfs/bin/malluaunty differ
-diff --git a/rootfs/bin/tabz b/rootfs/bin/tabz
-index 197c698..9bc49a1 100755
-Binary files a/rootfs/bin/tabz and b/rootfs/bin/tabz differ
-diff --git a/rootfs/boot/kernel/kernel b/rootfs/boot/kernel/kernel
-index 37dc38c..77df9cb 100755
-Binary files a/rootfs/boot/kernel/kernel and b/rootfs/boot/kernel/kernel differ
-diff --git a/rootfs/lib/libc.a b/rootfs/lib/libc.a
-index 83dbc5b..6ae502f 100644
-Binary files a/rootfs/lib/libc.a and b/rootfs/lib/libc.a differ
-diff --git a/sys/.process.c.swp b/sys/.process.c.swp
-deleted file mode 100644
-index 2ca4265..0000000
-Binary files a/sys/.process.c.swp and /dev/null differ
-diff --git a/sys/isr.c b/sys/isr.c
-index 07d3aea..8496abd 100644
---- a/sys/isr.c
-+++ b/sys/isr.c
-@@ -201,6 +201,7 @@ void isr14_handler(struct faultStruct *faultFrame)
- //        printf(" \n Error occured at %p ", faultFrame->rip);
- //        printf(" \n Faulting virtual address is %p", vaddr);
- //
-+        printf("Errorcode=%d",faultFrame->errorCode);
-         if(curproc->status==RUNNING)
-         {
-             vma_struct *vma=curproc->mm->mmap;
-@@ -440,7 +441,10 @@ void isr128_handler(struct Trapframe* tf){
-                     syscall_ret_value  = sys_sleep((void*)tf->tf_regs.reg_rdi);
-                     tf->tf_regs.reg_rax = (uint64_t)syscall_ret_value;
-                     break;
--
-+                
-+                case SYS_execve:
-+                    tf->tf_regs.reg_rax  = sys_execve((const char*)tf->tf_regs.reg_rdi,(const char**)tf->tf_regs.reg_rsi,(const char**)tf->tf_regs.reg_rdx);
-+                    break;
-                 default:
-                         break;
- 
-diff --git a/sys/main.c b/sys/main.c
-index 68d3f0d..5d83b91 100644
---- a/sys/main.c
-+++ b/sys/main.c
-@@ -40,10 +40,10 @@ void start(uint32_t* modulep, void* physbase, void* physfree)
- 
-   //printf("After initializing vm\n");
- 
--   i=499999999;
--    while(i--);
- 
-   tarfs_init();
-+   i=499999999;
-+    while(i--);
- 
-   printf("After initialize tarfs\n");
-   initialize_process();
-diff --git a/sys/process.c b/sys/process.c
-index 9bd22ef..2b350f5 100644
---- a/sys/process.c
-+++ b/sys/process.c
-@@ -151,7 +151,7 @@ int allocate_proc_area(ProcStruct* p, void* va, uint64_t size)
-     for(char* i=start; i<end; i+=PGSIZE)
-     {
-         pa = allocate_page();
--	pa->ref_count++;
-+	    pa->ref_count++;
-         if(!pa)
-            return -1;
-         newpage = pageToPhysicalAddress(pa);
-@@ -403,63 +403,7 @@ int proc_free(ProcStruct *proc)
-         return 0;
- }
- 
--/*
--uint64_t execve(const char *arg1,const char *arg2[],const  char* arg3[])
--{
--    
--     uint64_t* elf;
--     for(int i=0; i<numOfEntries; i++)
--     {
--        if(kstrcmp(arg1,tarfs_fs[i].name) == 0)
--        {
--            printf("found:%s ",tarfs_fs[i].name);
--            elf=(uint64_t*)((char*)tarfs_fs[i].addr_hdr+sizeof(struct posix_header_ustar));
--            break;
--        }
--     }
--          
--     proc_free(curproc);
--     load_elf(curproc,elf);
--     printf("REPLACED");
--     vma_struct* vma=curproc->mm->mmap;
--
--     for(int i=0;i<curproc->mm->count;i++)
--         if(vma->vm_type==STACK)
--             break;
--     
- 
--     int argc=copy_args_to_stack(vma->vm_end,arg1,arg2);
--     printf("REPLACED");
--   
--     return argc;
--}   
--
--int copy_args_to_stack(uint64_t stacktop,const char* arg1,const char** arg2)
--{
--
--     char* argv[10];
--     int len=kstrlen(arg1);
--
--     kstrcpy((char*)(stacktop=stacktop-len-1),arg1);
--     argv[0]=(char*)stacktop;
--     int argc=1;
--     
--     while(arg2[argc-1]!=NULL)
--     {
--        len = kstrlen(arg2[argc-1]);
--        kstrcpy((char*)(stacktop=stacktop-len-1),arg2[argc-1]);
--        argv[argc]=(char*)stacktop;
--        argc++;
--     }
--     for(int i=argc-1;i>=0;i--)
--     {
--         stacktop=stacktop-8;
--        *((uint64_t*)stacktop)=(uint64_t)argv[i];
--     }
--     curproc->tf.tf_rsp=stacktop;
--     return argc;
--}
--*/
- int fork_process(struct Trapframe* tf)
- {
-     ProcStruct* NewProc=NULL;
-@@ -689,3 +633,73 @@ int proc_sleep(void* t){
- 
- 
- }
-+
-+
-+char args[15][60];
-+uint64_t execve(const char *arg1,const char *arg2[],const  char* arg3[])
-+{
-+    
-+     uint64_t* elf;
-+     for(int i=0; i<numOfEntries; i++)
-+     {
-+        if(kstrcmp(arg1,tarfs_fs[i].name) == 0)
-+        {
-+            printf("found:%s ",tarfs_fs[i].name);
-+            elf=(uint64_t*)((char*)tarfs_fs[i].addr_hdr+sizeof(struct posix_header_ustar));
-+            break;
-+        }
-+     }
-+     kstrcpy(args[0],arg1);
-+     int argc=1;
-+     while(arg2[argc-1]!=NULL)
-+     {
-+        kstrcpy(args[argc],arg2[argc-1]);
-+        argc++;
-+     }     
-+     proc_free(curproc);
-+     load_elf(curproc,elf);
-+     printf("REPLACED");
-+     vma_struct* vma=curproc->mm->mmap;
-+
-+     for(int i=0;i<curproc->mm->count;i++)
-+     {
-+         if(vma->vm_type==STACK)
-+             break;
-+         vma=vma->vm_next;
-+     }
-+     
-+     printf("calling");
-+     //lcr3(curproc->cr3);
-+     argc=copy_args_to_stack(vma->vm_end,argc);
-+     //lcr3(boot_cr3);
-+
-+     printf("REPLACED");
-+     
-+     scheduler();
-+     return -1;
-+}   
-+
-+int copy_args_to_stack(uint64_t stacktop,int argc)
-+{
-+
-+     uint64_t argv[15];
-+
-+     int i=argc;
-+     
-+     while(i)
-+     {
-+        int len = kstrlen(args[i-1])+1;
-+        kstrcpy((char*)(stacktop=stacktop-len-1),args[i-1]);
-+        argv[i-1]=stacktop;
-+        i--;
-+     }
-+     for(int i=0;i<argc;i++)
-+     {
-+         stacktop=stacktop-8;
-+        *((uint64_t*)stacktop)=(uint64_t)argv[i];
-+     }
-+     curproc->tf.tf_rsp=stacktop;
-+     return argc;
-+}
-+
-+
-diff --git a/sys/syscall.c b/sys/syscall.c
-index adc89fa..89a9746 100644
---- a/sys/syscall.c
-+++ b/sys/syscall.c
-@@ -163,3 +163,9 @@ int sys_sleep(void* t){
- 	return proc_sleep(t);
- 
- }
-+
-+
-+int sys_execve(const char *arg1,const char *arg2[],const  char* arg3[])
-+{
-+return execve(arg1,arg2,arg3);
-+}
-diff --git a/sys/tarfs.c b/sys/tarfs.c
-index 7538657..776aaaa 100644
---- a/sys/tarfs.c
-+++ b/sys/tarfs.c
-@@ -127,7 +127,7 @@ void tarfs_init(){
- 
- 	 
- 	
--	while(1){
-+	for(int i=1;i<7;i++){
- 
- 		kstrcpy(name,fileSystemEntry->name);
- 
-diff --git a/tags b/tags
-index 2091d98..bba087c 100644
---- a/tags
-+++ b/tags
-@@ -40,7 +40,7 @@ CR4_TSD	include/sys/mmu.h	112;"	d
- CR4_VME	include/sys/mmu.h	114;"	d
- CRT_SRCS	Makefile	/^CRT_SRCS:=$(shell find crt\/ -name \\*.c -o -name \\*.s)$/;"	m
- CTRL	sys/keyboard.c	9;"	d	file:
--CommArray	include/parser.h	/^	singleCommand* CommArray[PIPE_MAX_NUM];	\/* Array to store individual commands*\/$/;"	m	struct:__anon7
-+CommArray	include/parser.h	/^	singleCommand* CommArray[PIPE_MAX_NUM];	\/* Array to store individual commands*\/$/;"	m	struct:__anon3
- D	sys/gdt.c	17;"	d	file:
- DIRECTORY	include/sys/tarfs.h	71;"	d
- DPL0	sys/gdt.c	11;"	d	file:
-@@ -170,14 +170,14 @@ KERNBASE	include/sys/paging.h	12;"	d
- KERNEL_PROCESS	include/sys/process.h	/^KERNEL_PROCESS$/;"	e	enum:ProcType
- KERN_SRCS	Makefile	/^KERN_SRCS:=$(shell find sys\/ -name \\*.c -o -name \\*.s)$/;"	m
- KEYBOARD_H_	include/sys/keyboard.h	2;"	d
--KO_CREAT	include/sys/tarfs.h	/^enum { KO_RDONLY = 0, KO_WRONLY = 1, KO_RDWR = 2, KO_CREAT = 0x40, KO_DIRECTORY = 0x10000 };$/;"	e	enum:__anon3
--KO_DIRECTORY	include/sys/tarfs.h	/^enum { KO_RDONLY = 0, KO_WRONLY = 1, KO_RDWR = 2, KO_CREAT = 0x40, KO_DIRECTORY = 0x10000 };$/;"	e	enum:__anon3
--KO_RDONLY	include/sys/tarfs.h	/^enum { KO_RDONLY = 0, KO_WRONLY = 1, KO_RDWR = 2, KO_CREAT = 0x40, KO_DIRECTORY = 0x10000 };$/;"	e	enum:__anon3
--KO_RDWR	include/sys/tarfs.h	/^enum { KO_RDONLY = 0, KO_WRONLY = 1, KO_RDWR = 2, KO_CREAT = 0x40, KO_DIRECTORY = 0x10000 };$/;"	e	enum:__anon3
--KO_WRONLY	include/sys/tarfs.h	/^enum { KO_RDONLY = 0, KO_WRONLY = 1, KO_RDWR = 2, KO_CREAT = 0x40, KO_DIRECTORY = 0x10000 };$/;"	e	enum:__anon3
--KSEEK_CUR	include/sys/tarfs.h	/^enum { KSEEK_SET = 0, KSEEK_CUR = 1, KSEEK_END = 2 };$/;"	e	enum:__anon2
--KSEEK_END	include/sys/tarfs.h	/^enum { KSEEK_SET = 0, KSEEK_CUR = 1, KSEEK_END = 2 };$/;"	e	enum:__anon2
--KSEEK_SET	include/sys/tarfs.h	/^enum { KSEEK_SET = 0, KSEEK_CUR = 1, KSEEK_END = 2 };$/;"	e	enum:__anon2
-+KO_CREAT	include/sys/tarfs.h	/^enum { KO_RDONLY = 0, KO_WRONLY = 1, KO_RDWR = 2, KO_CREAT = 0x40, KO_DIRECTORY = 0x10000 };$/;"	e	enum:__anon7
-+KO_DIRECTORY	include/sys/tarfs.h	/^enum { KO_RDONLY = 0, KO_WRONLY = 1, KO_RDWR = 2, KO_CREAT = 0x40, KO_DIRECTORY = 0x10000 };$/;"	e	enum:__anon7
-+KO_RDONLY	include/sys/tarfs.h	/^enum { KO_RDONLY = 0, KO_WRONLY = 1, KO_RDWR = 2, KO_CREAT = 0x40, KO_DIRECTORY = 0x10000 };$/;"	e	enum:__anon7
-+KO_RDWR	include/sys/tarfs.h	/^enum { KO_RDONLY = 0, KO_WRONLY = 1, KO_RDWR = 2, KO_CREAT = 0x40, KO_DIRECTORY = 0x10000 };$/;"	e	enum:__anon7
-+KO_WRONLY	include/sys/tarfs.h	/^enum { KO_RDONLY = 0, KO_WRONLY = 1, KO_RDWR = 2, KO_CREAT = 0x40, KO_DIRECTORY = 0x10000 };$/;"	e	enum:__anon7
-+KSEEK_CUR	include/sys/tarfs.h	/^enum { KSEEK_SET = 0, KSEEK_CUR = 1, KSEEK_END = 2 };$/;"	e	enum:__anon6
-+KSEEK_END	include/sys/tarfs.h	/^enum { KSEEK_SET = 0, KSEEK_CUR = 1, KSEEK_END = 2 };$/;"	e	enum:__anon6
-+KSEEK_SET	include/sys/tarfs.h	/^enum { KSEEK_SET = 0, KSEEK_CUR = 1, KSEEK_END = 2 };$/;"	e	enum:__anon6
- K_CS	include/sys/gdt.h	18;"	d
- K_DS	include/sys/gdt.h	19;"	d
- K_NAME_MAX	include/sys/tarfs.h	38;"	d
-@@ -242,7 +242,7 @@ PIC_sendEOI	sys/pic.c	/^void PIC_sendEOI(unsigned char irq)$/;"	f
- PIPE_MAX_NUM	include/parser.h	5;"	d
- PML4	include/sys/mmu.h	40;"	d
- PML4SHIFT	include/sys/mmu.h	69;"	d
--POPA	include/sys/process.h	95;"	d
-+POPA	include/sys/process.h	97;"	d
- POPA2	include/sys/utils.h	20;"	d
- PORT_H_	include/sys/port.h	2;"	d
- PPN	include/sys/mmu.h	30;"	d
-@@ -267,7 +267,7 @@ PTXSHIFT	include/sys/mmu.h	66;"	d
- PUSHA	include/sys/utils.h	1;"	d
- PageStruct	include/sys/paging.h	/^typedef struct PageStruct {$/;"	s
- PageStruct	include/sys/paging.h	/^}PageStruct;$/;"	t	typeref:struct:PageStruct
--Pipe	include/sys/file_table.h	/^}Pipe;$/;"	t	typeref:struct:__anon4
-+Pipe	include/sys/file_table.h	/^}Pipe;$/;"	t	typeref:struct:__anon8
- ProcStatus	include/sys/process.h	/^enum ProcStatus{$/;"	g
- ProcStruct	include/sys/process.h	/^typedef struct ProcStruct{$/;"	s
- ProcStruct	include/sys/process.h	/^}ProcStruct;$/;"	t	typeref:struct:ProcStruct
-@@ -327,8 +327,8 @@ TRUE	sys/keyboard.c	12;"	d	file:
- TYPE_DIRECTORY	include/sys/file_table.h	4;"	d
- TYPE_FILE	include/sys/file_table.h	3;"	d
- TYPE_PIPE	include/sys/file_table.h	5;"	d
--Token	include/stringTokenizer.h	/^}Token;$/;"	t	typeref:struct:__anon8
--Token	include/stringtokenizer.h	/^} Token;$/;"	t	typeref:struct:__anon9
-+Token	include/stringTokenizer.h	/^}Token;$/;"	t	typeref:struct:__anon4
-+Token	include/stringtokenizer.h	/^} Token;$/;"	t	typeref:struct:__anon1
- Trapframe	include/sys/idt.h	/^struct Trapframe {$/;"	s
- USERSTACKTOP	include/sys/paging.h	22;"	d
- USER_PROCESS	include/sys/process.h	/^USER_PROCESS=0,$/;"	e	enum:ProcType
-@@ -340,8 +340,8 @@ VPD	include/sys/mmu.h	36;"	d
- VPDPE	include/sys/mmu.h	37;"	d
- VPML4E	include/sys/mmu.h	38;"	d
- VPN	include/sys/mmu.h	31;"	d
--VarList	include/parser.h	/^	char *VarList[MAX_VAR_NUM];$/;"	m	struct:__anon6
--VarNum	include/parser.h	/^	int VarNum;$/;"	m	struct:__anon6
-+VarList	include/parser.h	/^	char *VarList[MAX_VAR_NUM];$/;"	m	struct:__anon2
-+VarNum	include/parser.h	/^	int VarNum;$/;"	m	struct:__anon2
- W	sys/gdt.c	18;"	d	file:
- _DEFS_H	include/sys/defs.h	2;"	d
- _ERRNO_H	include/errno.h	2;"	d
-@@ -360,8 +360,8 @@ _start	tp.s	/^_start:$/;"	l
- _x86_64_asm_lgdt	sys/gdt.s	/^_x86_64_asm_lgdt:$/;"	l
- addr	sys/gdt.c	/^	uint64_t addr;$/;"	m	struct:gdtr_t	file:
- addr	sys/idt.c	/^        uint64_t addr;$/;"	m	struct:idtr_t	file:
--addr_hdr	include/sys/tarfs.h	/^    uint64_t addr_hdr;$/;"	m	struct:__anon1
--address	include/sys/file_table.h	/^	uint64_t address; \/\/Only valid for pipe buffers and directories$/;"	m	struct:__anon4
-+addr_hdr	include/sys/tarfs.h	/^    uint64_t addr_hdr;$/;"	m	struct:__anon5
-+address	include/sys/file_table.h	/^	uint64_t address; \/\/Only valid for pipe buffers and directories$/;"	m	struct:__anon8
- alarm	libc/alarm.c	/^unsigned int alarm(unsigned int sec)$/;"	f
- align4	include/memory.h	4;"	d
- alloc_new	libc/malloc.c	/^void *alloc_new(int aligned_size)$/;"	f
-@@ -370,6 +370,7 @@ allocate_proc_area	sys/process.c	/^int allocate_proc_area(ProcStruct* p, void* v
- allocate_process	sys/process.c	/^ProcStruct* allocate_process(unsigned char parentid)$/;"	f
- allocate_vma	sys/process.c	/^struct vma_struct* allocate_vma(mm_struct* mem)$/;"	f
- allocated_mem	libc/malloc.c	/^static int allocated_mem; $/;"	v	file:
-+args	sys/process.c	/^char args[15][60];$/;"	v
- argv	tp.c	/^    ; push argv$/;"	v
- binary	include/sys/process.h	/^uint64_t *binary;$/;"	m	struct:ProcStruct
- block	include/memory.h	/^struct block{$/;"	s
-@@ -387,14 +388,15 @@ cat	libc/cat.c	/^void cat(char* filename){$/;"	f
- cd	libc/testCases.c	/^void cd(char *path){$/;"	f
- chdir	libc/chdir.c	/^int chdir(const char *path){$/;"	f
- checksum	include/sys/tarfs.h	/^	char checksum[8];$/;"	m	struct:posix_header_ustar
--close	include/sys/file_table.h	/^	int (*close)(); \/\/pointer to the device specific close call$/;"	m	struct:__anon5
-+close	include/sys/file_table.h	/^	int (*close)(); \/\/pointer to the device specific close call$/;"	m	struct:__anon9
- close	libc/close.c	/^int close(int fd)$/;"	f
- close_file	sys/tarfs.c	/^int close_file(int file_table_index){$/;"	f
- closedir	libc/closedir.c	/^int closedir(void *dir){$/;"	f
- colour	sys/printf.c	7;"	d	file:
--commandName	include/parser.h	/^	char *commandName;$/;"	m	struct:__anon6
-+commandName	include/parser.h	/^	char *commandName;$/;"	m	struct:__anon2
- convert_to_absolute_path_dir	sys/tarfs.c	/^void convert_to_absolute_path_dir(const char* path,char* absPath){$/;"	f
- convert_to_absolute_path_file	sys/tarfs.c	/^void convert_to_absolute_path_file(const char* path,char* absPath){$/;"	f
-+copy_args_to_stack	sys/process.c	/^int copy_args_to_stack(uint64_t stacktop,int argc)$/;"	f
- copypagetables	sys/process.c	/^int copypagetables(ProcStruct *proc)$/;"	f
- copyvmas	sys/process.c	/^int copyvmas(ProcStruct *proc)$/;"	f
- count	include/sys/process.h	/^    int count;$/;"	m	struct:mm_struct
-@@ -404,7 +406,7 @@ create_process	sys/process.c	/^ProcStruct* create_process(uint64_t* binary, enum
- cs	include/sys/isr.h	/^    uint64_t cs;$/;"	m	struct:faultStruct
- ctrl	sys/keyboard.c	/^unsigned char ctrl = FALSE;$/;"	v
- curproc	include/sys/process.h	/^ProcStruct* proc_free_list,*proc_running_list,*curproc;$/;"	v
--cursor	include/sys/file_table.h	/^	uint64_t cursor; \/\/current cursor position$/;"	m	struct:__anon5
-+cursor	include/sys/file_table.h	/^	uint64_t cursor; \/\/current cursor position$/;"	m	struct:__anon9
- cwd	include/sys/process.h	/^char cwd[50]; \/\/store the current working directory of a process$/;"	m	struct:ProcStruct
- d_ino	include/stdlib.h	/^	long d_ino;$/;"	m	struct:dirent
- d_ino	include/sys/tarfs.h	/^	long d_ino;$/;"	m	struct:K_dirent
-@@ -424,7 +426,7 @@ dup	libc/dup.c	/^int dup(int oldfd)$/;"	f
- dup2	libc/dup2.c	/^int dup2(int oldfd, int newfd)$/;"	f
- dup2	sys/pipe.c	/^int dup2(int oldfd, int newfd){$/;"	f
- dup2_test_case	libc/testCases.c	/^void dup2_test_case(){$/;"	f
--duplicateFD	include/sys/file_table.h	/^	int duplicateFD;$/;"	m	struct:__anon4
-+duplicateFD	include/sys/file_table.h	/^	int duplicateFD;$/;"	m	struct:__anon8
- e_ehsize	include/sys/elf.h	/^	uint16_t e_ehsize;$/;"	m	struct:Elf
- e_elf	include/sys/elf.h	/^	unsigned char e_elf[12];$/;"	m	struct:Elf
- e_entry	include/sys/elf.h	/^	uint64_t e_entry;$/;"	m	struct:Elf
-@@ -447,11 +449,12 @@ env_pop_tf	sys/process.c	/^void env_pop_tf(struct Trapframe *tf1)$/;"	f
- errno	sys/main.c	/^int errno = 0;$/;"	v
- errorCode	include/sys/isr.h	/^    uint64_t errorCode;$/;"	m	struct:faultStruct
- execve	libc/execve.c	/^int execve(const char *filename, char *const argv[], char *const envp[])$/;"	f
-+execve	sys/process.c	/^uint64_t execve(const char *arg1,const char *arg2[],const  char* arg3[])$/;"	f
- exit	libc/exit.c	/^void exit(int status){$/;"	f
- faultFrame	include/sys/isr.h	/^typedef struct faultStruct faultFrame;$/;"	t	typeref:struct:faultStruct
- faultStruct	include/sys/isr.h	/^struct faultStruct {$/;"	s
- fd_table	include/sys/process.h	/^int fd_table[10];  \/\/per process file descriptor array$/;"	m	struct:ProcStruct
--fileTable_entry	include/sys/file_table.h	/^} fileTable_entry;$/;"	t	typeref:struct:__anon5
-+fileTable_entry	include/sys/file_table.h	/^} fileTable_entry;$/;"	t	typeref:struct:__anon9
- file_read_test_case	libc/testCases.c	/^void file_read_test_case(){$/;"	f
- file_table	sys/tarfs.c	/^fileTable_entry file_table[10];$/;"	v
- fork	libc/fork.c	/^pid_t fork()$/;"	f
-@@ -487,7 +490,7 @@ initialize_page_lists	sys/paging.c	/^void initialize_page_lists(){$/;"	f
- initialize_process	sys/process.c	/^void initialize_process()$/;"	f
- initialize_vm_64	sys/paging.c	/^void initialize_vm_64(void){$/;"	f
- inode	newfs/newfs.c	/^struct inode {$/;"	s	file:
--inode_num	include/sys/file_table.h	/^	int inode_num; \/\/the entry in the tarfs table$/;"	m	struct:__anon5
-+inode_num	include/sys/file_table.h	/^	int inode_num; \/\/the entry in the tarfs table$/;"	m	struct:__anon9
- int	bin/hello/tp.s	/^int $80$/;"	l
- int	tp.s	/^int $80$/;"	l
- int16_t	include/sys/defs.h	/^typedef          short  int16_t;$/;"	t
-@@ -511,6 +514,7 @@ isr6_handler	sys/isr.c	/^void isr6_handler(){$/;"	f
- isr8_handler	sys/isr.c	/^void isr8_handler(){$/;"	f
- ist	sys/idt.c	/^    unsigned ist : 3 ;$/;"	m	struct:idt_t	file:
- k	bin/tabz/tab.c	/^int k=0;$/;"	v
-+k	libc/testCases.c	/^int k=0;$/;"	v
- kchdir	sys/tarfs.c	/^int kchdir(char* directoryPath){$/;"	f
- kclose	sys/tarfs.c	/^int kclose(int fd){$/;"	f
- keyboard_buffer	sys/keyboard.c	/^char keyboard_buffer[100]; \/\/To be used to hold the pressed keys till user presses ENTER$/;"	v
-@@ -571,15 +575,15 @@ mov	bin/hello/tp.s	/^mov  %eax, 3$/;"	l
- mov	tp.s	/^mov  %eax, 1$/;"	l
- mtime	include/sys/tarfs.h	/^	char mtime[12];$/;"	m	struct:posix_header_ustar
- name	include/sys/tarfs.h	/^	char name[100];$/;"	m	struct:posix_header_ustar
--name	include/sys/tarfs.h	/^    char name[100];$/;"	m	struct:__anon1
-+name	include/sys/tarfs.h	/^    char name[100];$/;"	m	struct:__anon5
- next	include/memory.h	/^	struct block* next;$/;"	m	struct:block	typeref:struct:block::block
- next	include/sys/paging.h	/^        struct PageStruct *next;$/;"	m	struct:PageStruct	typeref:struct:PageStruct::PageStruct
- next	include/sys/process.h	/^struct ProcStruct* next;$/;"	m	struct:ProcStruct	typeref:struct:ProcStruct::ProcStruct
- nextfree	sys/paging.c	/^static char* nextfree;$/;"	v	file:
- npages	include/sys/paging.h	/^uint64_t npages;$/;"	v
- numOfEntries	sys/tarfs.c	/^int numOfEntries = 1; \/\/index into the tarfs table..after tarfs_init() it has the total number of entries in FS$/;"	v
--numOfTokens	include/stringTokenizer.h	/^	int numOfTokens;$/;"	m	struct:__anon8
--numOfTokens	include/stringtokenizer.h	/^	int numOfTokens;$/;"	m	struct:__anon9
-+numOfTokens	include/stringTokenizer.h	/^	int numOfTokens;$/;"	m	struct:__anon4
-+numOfTokens	include/stringtokenizer.h	/^	int numOfTokens;$/;"	m	struct:__anon1
- octalToDecimal	sys/utils.c	/^uint64_t octalToDecimal(uint64_t octal)$/;"	f
- off_t	include/stdlib.h	/^typedef uint64_t off_t;$/;"	t
- offset_0_15	sys/idt.c	/^    uint16_t offset_0_15;$/;"	m	struct:idt_t	file:
-@@ -601,18 +605,18 @@ pad	include/sys/tarfs.h	/^	char pad[12];$/;"	m	struct:posix_header_ustar
- pageToPhysicalAddress	sys/paging.c	/^uint64_t* pageToPhysicalAddress(PageStruct* page){$/;"	f
- page_free_list	sys/paging.c	/^static struct PageStruct *page_free_list;	\/\/ Free list of physical pages. page_free_list is the head of the free list$/;"	v	typeref:struct:PageStruct	file:
- pages	sys/paging.c	/^struct PageStruct *pages;$/;"	v	typeref:struct:PageStruct
--par_ind	include/sys/tarfs.h	/^    int par_ind;$/;"	m	struct:__anon1
-+par_ind	include/sys/tarfs.h	/^    int par_ind;$/;"	m	struct:__anon5
- parent_id	include/sys/process.h	/^unsigned char parent_id;$/;"	m	struct:ProcStruct
--parseInfo	include/parser.h	/^} parseInfo;$/;"	t	typeref:struct:__anon7
-+parseInfo	include/parser.h	/^} parseInfo;$/;"	t	typeref:struct:__anon3
- pde_t	include/sys/defs.h	/^typedef uint64_t pde_t;$/;"	t
- pdpe_t	include/sys/defs.h	/^typedef uint64_t pdpe_t;$/;"	t
- physaddr_t	include/sys/defs.h	/^typedef uint64_t physaddr_t;$/;"	t
- physicalAddressToPage	sys/paging.c	/^PageStruct * physicalAddressToPage(uint64_t *addr){$/;"	f
- pid_t	include/stdlib.h	/^typedef uint32_t pid_t;$/;"	t
--pipe	include/sys/file_table.h	/^	Pipe pipe; \/\/$/;"	m	struct:__anon5
-+pipe	include/sys/file_table.h	/^	Pipe pipe; \/\/$/;"	m	struct:__anon9
- pipe	libc/pipe.c	/^int pipe(int fd[2])$/;"	f
- pipe	sys/pipe.c	/^int pipe(int *pipefd){$/;"	f
--pipeNum	include/parser.h	/^	int   pipeNum;$/;"	m	struct:__anon7
-+pipeNum	include/parser.h	/^	int   pipeNum;$/;"	m	struct:__anon3
- pipe_close	sys/pipe.c	/^int pipe_close(int fd){$/;"	f
- pipe_read	sys/pipe.c	/^int pipe_read(int file_table_index,char* buf, int numBytesToRead){$/;"	f
- pipe_write	sys/pipe.c	/^int pipe_write(int file_table_index,char *buf,int numBytesToWrite){$/;"	f
-@@ -621,7 +625,7 @@ pml4e_t	include/sys/defs.h	/^typedef uint64_t pml4e_t;$/;"	t
- posix_header_ustar	include/sys/tarfs.h	/^struct posix_header_ustar {$/;"	s
- power	sys/utils.c	/^uint64_t power(uint64_t x, int e) {$/;"	f
- prefix	include/sys/tarfs.h	/^	char prefix[155];$/;"	m	struct:posix_header_ustar
--present	include/sys/file_table.h	/^	int present; \/\/indicates if this entry is valid or not 0->free 1->present$/;"	m	struct:__anon5
-+present	include/sys/file_table.h	/^	int present; \/\/indicates if this entry is valid or not 0->free 1->present$/;"	m	struct:__anon9
- prev	include/memory.h	/^	struct block* prev;$/;"	m	struct:block	typeref:struct:block::block
- print_keyboard_buff	sys/keyboard.c	/^void print_keyboard_buff(){$/;"	f
- print_num	libc/printf.c	/^void print_num(int num, int base)$/;"	f
-@@ -643,15 +647,15 @@ procs	include/sys/process.h	/^ProcStruct* procs; $/;"	v
- ps	libc/ps.c	/^int ps(){$/;"	f
- pt	include/sys/process.h	/^    uint64_t * pt; \/\/ page table pointer  $/;"	m	struct:mm_struct
- pte_t	include/sys/defs.h	/^typedef uint64_t pte_t;$/;"	t
--read	include/sys/file_table.h	/^	int (*read)(); \/\/pointer to the device specific read call$/;"	m	struct:__anon5
-+read	include/sys/file_table.h	/^	int (*read)(); \/\/pointer to the device specific read call$/;"	m	struct:__anon9
- read	libc/read.c	/^ssize_t read(int fd, void *buf, size_t count){$/;"	f
- read_cr2_register	sys/isr.c	/^uint64_t read_cr2_register(){$/;"	f
--read_cursor	include/sys/file_table.h	/^	uint64_t read_cursor;$/;"	m	struct:__anon4
-+read_cursor	include/sys/file_table.h	/^	uint64_t read_cursor;$/;"	m	struct:__anon8
- read_file	sys/tarfs.c	/^int read_file(int file_table_index,char *buf,int numBytesToRead){$/;"	f
- read_line	libc/testCases.c	/^void read_line(int fd, char* buf)$/;"	f
- readdir	libc/readdir.c	/^struct dirent* readdir(void *dir){$/;"	f
--readers	include/sys/file_table.h	/^	int readers;$/;"	m	struct:__anon4
--ref_count	include/sys/file_table.h	/^	int ref_count; \/\/number of processes which have this file open$/;"	m	struct:__anon5
-+readers	include/sys/file_table.h	/^	int readers;$/;"	m	struct:__anon8
-+ref_count	include/sys/file_table.h	/^	int ref_count; \/\/number of processes which have this file open$/;"	m	struct:__anon9
- ref_count	include/sys/paging.h	/^	uint16_t ref_count;$/;"	m	struct:PageStruct
- refcount	newfs/newfs.c	/^	uint64_t refcount;$/;"	m	struct:inode	file:
- reg_r10	include/sys/idt.h	/^    uint64_t reg_r10;$/;"	m	struct:GpRegs
-@@ -716,11 +720,11 @@ sh_type	include/sys/elf.h	/^	uint32_t sh_type;$/;"	m	struct:Secthdr
- shift	sys/keyboard.c	/^unsigned char shift = FALSE;$/;"	v
- show_fd_table	sys/tarfs.c	/^void show_fd_table(){$/;"	f
- show_file_table	sys/tarfs.c	/^void show_file_table(int fd){$/;"	f
--singleCommand	include/parser.h	/^}singleCommand;$/;"	t	typeref:struct:__anon6
-+singleCommand	include/parser.h	/^}singleCommand;$/;"	t	typeref:struct:__anon2
- size	include/memory.h	/^	int size;$/;"	m	struct:block
--size	include/sys/file_table.h	/^	int size;$/;"	m	struct:__anon5
-+size	include/sys/file_table.h	/^	int size;$/;"	m	struct:__anon9
- size	include/sys/tarfs.h	/^	char size[12];$/;"	m	struct:posix_header_ustar
--size	include/sys/tarfs.h	/^    int size;$/;"	m	struct:__anon1
-+size	include/sys/tarfs.h	/^    int size;$/;"	m	struct:__anon5
- size	libc/malloc.c	/^    int size;$/;"	m	struct:MCB_header_t	file:
- size	sys/gdt.c	/^	uint16_t size;$/;"	m	struct:gdtr_t	file:
- size	sys/idt.c	/^		uint16_t size;$/;"	m	struct:idtr_t	file:
-@@ -748,6 +752,7 @@ sys_chdir	sys/syscall.c	/^int sys_chdir(char* path){$/;"	f
- sys_close_directory	sys/syscall.c	/^int sys_close_directory(void* dir){$/;"	f
- sys_close_file	sys/syscall.c	/^uint64_t sys_close_file(int fd){$/;"	f
- sys_dup2	sys/syscall.c	/^int sys_dup2(int oldfd,int newfd){$/;"	f
-+sys_execve	sys/syscall.c	/^int sys_execve(const char *arg1,const char *arg2[],const  char* arg3[])$/;"	f
- sys_exit	sys/syscall.c	/^void sys_exit(uint64_t error_code){$/;"	f
- sys_fork	sys/syscall.c	/^int sys_fork(struct Trapframe* tf)$/;"	f
- sys_getcwd	sys/syscall.c	/^uint64_t sys_getcwd(char* buff, uint64_t size){$/;"	f
-@@ -768,7 +773,7 @@ syscall_1	include/syscall.h	/^static __inline int64_t syscall_1(uint64_t n, uint
- syscall_2	include/syscall.h	/^static __inline uint64_t syscall_2(uint64_t n, uint64_t a1, uint64_t a2) {$/;"	f
- syscall_3	include/syscall.h	/^static __inline uint64_t syscall_3(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3) {$/;"	f
- tabwidth	sys/printf.c	6;"	d	file:
--tarfs_entry	include/sys/tarfs.h	/^} tarfs_entry;$/;"	t	typeref:struct:__anon1
-+tarfs_entry	include/sys/tarfs.h	/^} tarfs_entry;$/;"	t	typeref:struct:__anon5
- tarfs_fs	sys/tarfs.c	/^tarfs_entry tarfs_fs[100];$/;"	v
- tarfs_init	sys/tarfs.c	/^void tarfs_init(){$/;"	f
- terminal_read	sys/tarfs.c	/^int terminal_read(int file_table_index,char *buf,int numBytesToRead){$/;"	f
-@@ -796,19 +801,19 @@ tf_trapno	include/sys/idt.h	/^	uint64_t tf_trapno;$/;"	m	struct:Trapframe
- timeTillNow	sys/isr.c	/^unsigned long int timeTillNow=0;$/;"	v
- timespec	libc/sleep.c	/^struct timespec$/;"	s	file:
- tlb_invalidate	sys/paging.c	/^tlb_invalidate(pml4e_t *pml4e, void *va)$/;"	f
--tokenArr	include/stringTokenizer.h	/^	char *tokenArr[50];$/;"	m	struct:__anon8
--tokenArr	include/stringtokenizer.h	/^	char *tokenArr[50];$/;"	m	struct:__anon9
-+tokenArr	include/stringTokenizer.h	/^	char *tokenArr[50];$/;"	m	struct:__anon4
-+tokenArr	include/stringtokenizer.h	/^	char *tokenArr[50];$/;"	m	struct:__anon1
- tss	sys/main.c	/^struct tss_t tss;$/;"	v	typeref:struct:tss_t
- tss_t	include/sys/gdt.h	/^struct tss_t {$/;"	s
- tv_nsec	include/sys/process.h	/^	int64_t tv_nsec;$/;"	m	struct:K_timespec
- tv_nsec	libc/sleep.c	/^	int64_t tv_nsec;$/;"	m	struct:timespec	file:
- tv_sec	include/sys/process.h	/^	unsigned int tv_sec;$/;"	m	struct:K_timespec
- tv_sec	libc/sleep.c	/^	unsigned int tv_sec;$/;"	m	struct:timespec	file:
--type	include/sys/file_table.h	/^	uint64_t type;$/;"	m	struct:__anon5
-+type	include/sys/file_table.h	/^	uint64_t type;$/;"	m	struct:__anon9
- type	include/sys/process.h	/^enum ProcType type;$/;"	m	struct:ProcStruct	typeref:enum:ProcStruct::ProcType
- type	sys/idt.c	/^    unsigned type : 4;$/;"	m	struct:idt_t	file:
- typeflag	include/sys/tarfs.h	/^	char typeflag[1];$/;"	m	struct:posix_header_ustar
--typeflag	include/sys/tarfs.h	/^    int typeflag;$/;"	m	struct:__anon1
-+typeflag	include/sys/tarfs.h	/^    int typeflag;$/;"	m	struct:__anon5
- uid	include/sys/tarfs.h	/^	char uid[8];$/;"	m	struct:posix_header_ustar
- uint16_t	include/sys/defs.h	/^typedef unsigned short uint16_t;$/;"	t
- uint32_t	include/sys/defs.h	/^typedef unsigned int   uint32_t;$/;"	t
-@@ -837,12 +842,12 @@ vma_struct	include/sys/process.h	/^typedef struct vma_struct{$/;"	s
- vma_struct	include/sys/process.h	/^}vma_struct;$/;"	t	typeref:struct:vma_struct
- waitpid	libc/process.c	/^pid_t waitpid(pid_t pid, int *status, int options)$/;"	f
- wakeuptime	include/sys/process.h	/^uint64_t wakeuptime;$/;"	m	struct:ProcStruct
--write	include/sys/file_table.h	/^	int (*write)(); \/\/pointer to the device specific write call$/;"	m	struct:__anon5
-+write	include/sys/file_table.h	/^	int (*write)(); \/\/pointer to the device specific write call$/;"	m	struct:__anon9
- write	libc/write.c	/^ssize_t write(int fd, const void *buf, size_t count){$/;"	f
--write_cursor	include/sys/file_table.h	/^	uint64_t write_cursor;$/;"	m	struct:__anon4
-+write_cursor	include/sys/file_table.h	/^	uint64_t write_cursor;$/;"	m	struct:__anon8
- write_file	sys/tarfs.c	/^int write_file(int file_table_index,char *buf,int numBytesToWrite){$/;"	f
- write_text	sys/printf.c	/^int write_text(int len) {$/;"	f
--writers	include/sys/file_table.h	/^	int writers;$/;"	m	struct:__anon4
-+writers	include/sys/file_table.h	/^	int writers;$/;"	m	struct:__anon8
- x	sys/printf.c	/^static int x=5,y;$/;"	v	file:
- y	sys/printf.c	/^static int x=5,y;$/;"	v	file:
- zero	sys/idt.c	/^    unsigned zero : 1;$/;"	m	struct:idt_t	file:
diff --git a/hello_obj b/hello_obj
index 0d0a06e..44de5cc 100644
--- a/hello_obj
+++ b/hello_obj
@@ -17,1131 +17,5801 @@ void _start(void) {
 //	char* argv[0];
 //	char* envp[0];
 	int res;
-	res = main(0, NULL, NULL);
-  4000f0:	ba 00 00 00 00       	mov    $0x0,%edx
-  4000f5:	be 00 00 00 00       	mov    $0x0,%esi
-  4000fa:	bf 00 00 00 00       	mov    $0x0,%edi
-  4000ff:	e8 15 00 00 00       	callq  400119 <main>
-  400104:	89 45 fc             	mov    %eax,-0x4(%rbp)
-   
+//	res = main(0, NULL, NULL);
+ volatile int x=89;
+  4000f0:	c7 45 f8 59 00 00 00 	movl   $0x59,-0x8(%rbp)
+  res=  main(*((uint64_t*)(&x+0x3UL)),(char**)(uint64_t*)(&x+0x5UL), (char **)((&x+5) +  (2*(*(&x+3)+ 1))));
+  4000f7:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
+  4000fb:	48 83 c0 0c          	add    $0xc,%rax
+  4000ff:	8b 00                	mov    (%rax),%eax
+  400101:	ff c0                	inc    %eax
+  400103:	48 98                	cltq   
+  400105:	48 c1 e0 03          	shl    $0x3,%rax
+  400109:	48 8d 50 14          	lea    0x14(%rax),%rdx
+  40010d:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
+  400111:	48 01 c2             	add    %rax,%rdx
+  400114:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
+  400118:	48 83 c0 0c          	add    $0xc,%rax
+  40011c:	48 8b 00             	mov    (%rax),%rax
+  40011f:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
+  400123:	48 83 c1 14          	add    $0x14,%rcx
+  400127:	48 89 ce             	mov    %rcx,%rsi
+  40012a:	89 c7                	mov    %eax,%edi
+  40012c:	e8 2f 15 00 00       	callq  401660 <main>
+  400131:	89 45 fc             	mov    %eax,-0x4(%rbp)
+
     exit(res);
-  400107:	8b 45 fc             	mov    -0x4(%rbp),%eax
-  40010a:	89 c7                	mov    %eax,%edi
-  40010c:	e8 d0 08 00 00       	callq  4009e1 <exit>
+  400134:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  400137:	89 c7                	mov    %eax,%edi
+  400139:	e8 ac 27 00 00       	callq  4028ea <exit>
   }
-  400111:	c9                   	leaveq 
-  400112:	c3                   	retq   
+  40013e:	c9                   	leaveq 
+  40013f:	c3                   	retq   
+
+0000000000400140 <changedir>:
+#include <errno.h>
+#include <string.h>
+#include <shell.h>
+
+
+void changedir(char* path){
+  400140:	55                   	push   %rbp
+  400141:	48 89 e5             	mov    %rsp,%rbp
+  400144:	48 81 ec 40 02 00 00 	sub    $0x240,%rsp
+  40014b:	48 89 bd c8 fd ff ff 	mov    %rdi,-0x238(%rbp)
+
+int pathLen = strlen(path);
+  400152:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
+  400159:	48 89 c7             	mov    %rax,%rdi
+  40015c:	e8 a5 27 00 00       	callq  402906 <strlen>
+  400161:	89 45 ec             	mov    %eax,-0x14(%rbp)
+
+    int forward=0;
+  400164:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
+    int back = 0;
+  40016b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
+    char temp[20];
+    int i=0;
+  400172:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
+    int x=0;
+  400179:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
+    int numOfComponents = 0;
+  400180:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
+
+    char components[10][20];
+
+    for(forward=0;forward<pathLen;){
+  400187:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
+  40018e:	e9 1a 01 00 00       	jmpq   4002ad <changedir+0x16d>
+        
+        if(forward == 0 && path[forward] == '/'){
+  400193:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
+  400197:	75 3b                	jne    4001d4 <changedir+0x94>
+  400199:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  40019c:	48 63 d0             	movslq %eax,%rdx
+  40019f:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
+  4001a6:	48 01 d0             	add    %rdx,%rax
+  4001a9:	0f b6 00             	movzbl (%rax),%eax
+  4001ac:	3c 2f                	cmp    $0x2f,%al
+  4001ae:	75 24                	jne    4001d4 <changedir+0x94>
+            strcpy(components[0],"/");
+  4001b0:	48 8d 85 08 ff ff ff 	lea    -0xf8(%rbp),%rax
+  4001b7:	48 8d 35 f2 30 00 00 	lea    0x30f2(%rip),%rsi        # 4032b0 <chdir+0x38>
+  4001be:	48 89 c7             	mov    %rax,%rdi
+  4001c1:	e8 75 27 00 00       	callq  40293b <strcpy>
+            back++;
+  4001c6:	ff 45 f8             	incl   -0x8(%rbp)
+            forward++;
+  4001c9:	ff 45 fc             	incl   -0x4(%rbp)
+            numOfComponents++;
+  4001cc:	ff 45 f0             	incl   -0x10(%rbp)
+            continue;
+  4001cf:	e9 d9 00 00 00       	jmpq   4002ad <changedir+0x16d>
+        }
+
+        if(path[forward] == '/'){
+  4001d4:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  4001d7:	48 63 d0             	movslq %eax,%rdx
+  4001da:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
+  4001e1:	48 01 d0             	add    %rdx,%rax
+  4001e4:	0f b6 00             	movzbl (%rax),%eax
+  4001e7:	3c 2f                	cmp    $0x2f,%al
+  4001e9:	0f 85 bb 00 00 00    	jne    4002aa <changedir+0x16a>
+
+            if(path[forward-1] == '/'){
+  4001ef:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  4001f2:	48 98                	cltq   
+  4001f4:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
+  4001f8:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
+  4001ff:	48 01 d0             	add    %rdx,%rax
+  400202:	0f b6 00             	movzbl (%rax),%eax
+  400205:	3c 2f                	cmp    $0x2f,%al
+  400207:	75 16                	jne    40021f <changedir+0xdf>
+                printf("Malformed path\n");
+  400209:	48 8d 3d a2 30 00 00 	lea    0x30a2(%rip),%rdi        # 4032b2 <chdir+0x3a>
+  400210:	b8 00 00 00 00       	mov    $0x0,%eax
+  400215:	e8 16 20 00 00       	callq  402230 <printf>
+  40021a:	e9 4d 03 00 00       	jmpq   40056c <changedir+0x42c>
+                return;
+            }
+
+            //copy from back till forward-1
+            i=0;
+  40021f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
+            
+            x = (forward-back);
+  400226:	8b 45 f8             	mov    -0x8(%rbp),%eax
+  400229:	8b 55 fc             	mov    -0x4(%rbp),%edx
+  40022c:	29 c2                	sub    %eax,%edx
+  40022e:	89 d0                	mov    %edx,%eax
+  400230:	89 45 e8             	mov    %eax,-0x18(%rbp)
+            while(i< x){
+  400233:	eb 28                	jmp    40025d <changedir+0x11d>
+
+                temp[i++] = path[back++];
+  400235:	8b 45 f4             	mov    -0xc(%rbp),%eax
+  400238:	8d 50 01             	lea    0x1(%rax),%edx
+  40023b:	89 55 f4             	mov    %edx,-0xc(%rbp)
+  40023e:	8b 55 f8             	mov    -0x8(%rbp),%edx
+  400241:	8d 4a 01             	lea    0x1(%rdx),%ecx
+  400244:	89 4d f8             	mov    %ecx,-0x8(%rbp)
+  400247:	48 63 ca             	movslq %edx,%rcx
+  40024a:	48 8b 95 c8 fd ff ff 	mov    -0x238(%rbp),%rdx
+  400251:	48 01 ca             	add    %rcx,%rdx
+  400254:	0f b6 12             	movzbl (%rdx),%edx
+  400257:	48 98                	cltq   
+  400259:	88 54 05 d0          	mov    %dl,-0x30(%rbp,%rax,1)
+
+            //copy from back till forward-1
+            i=0;
+            
+            x = (forward-back);
+            while(i< x){
+  40025d:	8b 45 f4             	mov    -0xc(%rbp),%eax
+  400260:	3b 45 e8             	cmp    -0x18(%rbp),%eax
+  400263:	7c d0                	jl     400235 <changedir+0xf5>
+
+                temp[i++] = path[back++];
+              
+            }
+            temp[i]= '\0';
+  400265:	8b 45 f4             	mov    -0xc(%rbp),%eax
+  400268:	48 98                	cltq   
+  40026a:	c6 44 05 d0 00       	movb   $0x0,-0x30(%rbp,%rax,1)
+            //printf("%s\n", temp );
+            
+            strcpy(components[numOfComponents],temp);
+  40026f:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
+  400276:	8b 45 f0             	mov    -0x10(%rbp),%eax
+  400279:	48 98                	cltq   
+  40027b:	48 c1 e0 02          	shl    $0x2,%rax
+  40027f:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
+  400286:	00 
+  400287:	48 01 c8             	add    %rcx,%rax
+  40028a:	48 01 c2             	add    %rax,%rdx
+  40028d:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
+  400291:	48 89 c6             	mov    %rax,%rsi
+  400294:	48 89 d7             	mov    %rdx,%rdi
+  400297:	e8 9f 26 00 00       	callq  40293b <strcpy>
+            //printf("%s\n", &components[0] );
+            forward++;
+  40029c:	ff 45 fc             	incl   -0x4(%rbp)
+            back = forward;
+  40029f:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  4002a2:	89 45 f8             	mov    %eax,-0x8(%rbp)
+            numOfComponents++;
+  4002a5:	ff 45 f0             	incl   -0x10(%rbp)
+            continue;
+  4002a8:	eb 03                	jmp    4002ad <changedir+0x16d>
+
+        }
+
+        forward++;
+  4002aa:	ff 45 fc             	incl   -0x4(%rbp)
+    int x=0;
+    int numOfComponents = 0;
+
+    char components[10][20];
+
+    for(forward=0;forward<pathLen;){
+  4002ad:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  4002b0:	3b 45 ec             	cmp    -0x14(%rbp),%eax
+  4002b3:	0f 8c da fe ff ff    	jl     400193 <changedir+0x53>
+
+        forward++;
+
+    } //End of for
+
+    if(path[forward-1] != '/'){
+  4002b9:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  4002bc:	48 98                	cltq   
+  4002be:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
+  4002c2:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
+  4002c9:	48 01 d0             	add    %rdx,%rax
+  4002cc:	0f b6 00             	movzbl (%rax),%eax
+  4002cf:	3c 2f                	cmp    $0x2f,%al
+  4002d1:	0f 84 83 00 00 00    	je     40035a <changedir+0x21a>
+
+        i=0;
+  4002d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
+        x = forward-back;
+  4002de:	8b 45 f8             	mov    -0x8(%rbp),%eax
+  4002e1:	8b 55 fc             	mov    -0x4(%rbp),%edx
+  4002e4:	29 c2                	sub    %eax,%edx
+  4002e6:	89 d0                	mov    %edx,%eax
+  4002e8:	89 45 e8             	mov    %eax,-0x18(%rbp)
+        while(i<x){
+  4002eb:	eb 28                	jmp    400315 <changedir+0x1d5>
+            temp[i++]=path[back++];
+  4002ed:	8b 45 f4             	mov    -0xc(%rbp),%eax
+  4002f0:	8d 50 01             	lea    0x1(%rax),%edx
+  4002f3:	89 55 f4             	mov    %edx,-0xc(%rbp)
+  4002f6:	8b 55 f8             	mov    -0x8(%rbp),%edx
+  4002f9:	8d 4a 01             	lea    0x1(%rdx),%ecx
+  4002fc:	89 4d f8             	mov    %ecx,-0x8(%rbp)
+  4002ff:	48 63 ca             	movslq %edx,%rcx
+  400302:	48 8b 95 c8 fd ff ff 	mov    -0x238(%rbp),%rdx
+  400309:	48 01 ca             	add    %rcx,%rdx
+  40030c:	0f b6 12             	movzbl (%rdx),%edx
+  40030f:	48 98                	cltq   
+  400311:	88 54 05 d0          	mov    %dl,-0x30(%rbp,%rax,1)
+
+    if(path[forward-1] != '/'){
+
+        i=0;
+        x = forward-back;
+        while(i<x){
+  400315:	8b 45 f4             	mov    -0xc(%rbp),%eax
+  400318:	3b 45 e8             	cmp    -0x18(%rbp),%eax
+  40031b:	7c d0                	jl     4002ed <changedir+0x1ad>
+            temp[i++]=path[back++];
+        }
+        temp[i] = '\0';
+  40031d:	8b 45 f4             	mov    -0xc(%rbp),%eax
+  400320:	48 98                	cltq   
+  400322:	c6 44 05 d0 00       	movb   $0x0,-0x30(%rbp,%rax,1)
+        strcpy(components[numOfComponents++],temp);
+  400327:	8b 45 f0             	mov    -0x10(%rbp),%eax
+  40032a:	8d 50 01             	lea    0x1(%rax),%edx
+  40032d:	89 55 f0             	mov    %edx,-0x10(%rbp)
+  400330:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
+  400337:	48 98                	cltq   
+  400339:	48 c1 e0 02          	shl    $0x2,%rax
+  40033d:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
+  400344:	00 
+  400345:	48 01 c8             	add    %rcx,%rax
+  400348:	48 01 c2             	add    %rax,%rdx
+  40034b:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
+  40034f:	48 89 c6             	mov    %rax,%rsi
+  400352:	48 89 d7             	mov    %rdx,%rdi
+  400355:	e8 e1 25 00 00       	callq  40293b <strcpy>
+
+    char buff[100];
+    char originalWorkingDirectory[100];
+    char toSend[100];
+
+    getcwd(originalWorkingDirectory,100);
+  40035a:	48 8d 85 40 fe ff ff 	lea    -0x1c0(%rbp),%rax
+  400361:	be 64 00 00 00       	mov    $0x64,%esi
+  400366:	48 89 c7             	mov    %rax,%rdi
+  400369:	e8 9b 1a 00 00       	callq  401e09 <getcwd>
+
+   
+    i=0;
+  40036e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
+
+    
+    while(i < numOfComponents){
+  400375:	e9 e4 01 00 00       	jmpq   40055e <changedir+0x41e>
+
+        if(i == numOfComponents){
+  40037a:	8b 45 f4             	mov    -0xc(%rbp),%eax
+  40037d:	3b 45 f0             	cmp    -0x10(%rbp),%eax
+  400380:	75 05                	jne    400387 <changedir+0x247>
+            break;
+  400382:	e9 e5 01 00 00       	jmpq   40056c <changedir+0x42c>
+        }
+
+        if(i==0){
+  400387:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
+  40038b:	75 5c                	jne    4003e9 <changedir+0x2a9>
+            strcpy(toSend,components[i]);
+  40038d:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
+  400394:	8b 45 f4             	mov    -0xc(%rbp),%eax
+  400397:	48 98                	cltq   
+  400399:	48 c1 e0 02          	shl    $0x2,%rax
+  40039d:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
+  4003a4:	00 
+  4003a5:	48 01 c8             	add    %rcx,%rax
+  4003a8:	48 01 c2             	add    %rax,%rdx
+  4003ab:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
+  4003b2:	48 89 d6             	mov    %rdx,%rsi
+  4003b5:	48 89 c7             	mov    %rax,%rdi
+  4003b8:	e8 7e 25 00 00       	callq  40293b <strcpy>
+            
+            if(chdir(toSend) == -1){
+  4003bd:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
+  4003c4:	48 89 c7             	mov    %rax,%rdi
+  4003c7:	e8 ac 2e 00 00       	callq  403278 <chdir>
+  4003cc:	83 f8 ff             	cmp    $0xffffffff,%eax
+  4003cf:	0f 85 7c 01 00 00    	jne    400551 <changedir+0x411>
+            chdir(originalWorkingDirectory);
+  4003d5:	48 8d 85 40 fe ff ff 	lea    -0x1c0(%rbp),%rax
+  4003dc:	48 89 c7             	mov    %rax,%rdi
+  4003df:	e8 94 2e 00 00       	callq  403278 <chdir>
+            break;
+  4003e4:	e9 83 01 00 00       	jmpq   40056c <changedir+0x42c>
+            }
+        }
+
+        else if(strcmp(components[i],".")==0){
+  4003e9:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
+  4003f0:	8b 45 f4             	mov    -0xc(%rbp),%eax
+  4003f3:	48 98                	cltq   
+  4003f5:	48 c1 e0 02          	shl    $0x2,%rax
+  4003f9:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
+  400400:	00 
+  400401:	48 01 c8             	add    %rcx,%rax
+  400404:	48 01 d0             	add    %rdx,%rax
+  400407:	48 8d 35 b4 2e 00 00 	lea    0x2eb4(%rip),%rsi        # 4032c2 <chdir+0x4a>
+  40040e:	48 89 c7             	mov    %rax,%rdi
+  400411:	e8 84 25 00 00       	callq  40299a <strcmp>
+  400416:	85 c0                	test   %eax,%eax
+  400418:	75 08                	jne    400422 <changedir+0x2e2>
+
+        	//nothing to do
+        	i++;
+  40041a:	ff 45 f4             	incl   -0xc(%rbp)
+        	continue;
+  40041d:	e9 3c 01 00 00       	jmpq   40055e <changedir+0x41e>
+
+        }
+
+        else if(strcmp(components[i],"..")==0){
+  400422:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
+  400429:	8b 45 f4             	mov    -0xc(%rbp),%eax
+  40042c:	48 98                	cltq   
+  40042e:	48 c1 e0 02          	shl    $0x2,%rax
+  400432:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
+  400439:	00 
+  40043a:	48 01 c8             	add    %rcx,%rax
+  40043d:	48 01 d0             	add    %rdx,%rax
+  400440:	48 8d 35 7d 2e 00 00 	lea    0x2e7d(%rip),%rsi        # 4032c4 <chdir+0x4c>
+  400447:	48 89 c7             	mov    %rax,%rdi
+  40044a:	e8 4b 25 00 00       	callq  40299a <strcmp>
+  40044f:	85 c0                	test   %eax,%eax
+  400451:	75 4b                	jne    40049e <changedir+0x35e>
+
+            if(i == numOfComponents){
+  400453:	8b 45 f4             	mov    -0xc(%rbp),%eax
+  400456:	3b 45 f0             	cmp    -0x10(%rbp),%eax
+  400459:	75 05                	jne    400460 <changedir+0x320>
+                break;
+  40045b:	e9 0c 01 00 00       	jmpq   40056c <changedir+0x42c>
+            }
+
+            chdir("..");
+  400460:	48 8d 3d 5d 2e 00 00 	lea    0x2e5d(%rip),%rdi        # 4032c4 <chdir+0x4c>
+  400467:	e8 0c 2e 00 00       	callq  403278 <chdir>
+            getcwd(buff,100);
+  40046c:	48 8d 85 a4 fe ff ff 	lea    -0x15c(%rbp),%rax
+  400473:	be 64 00 00 00       	mov    $0x64,%esi
+  400478:	48 89 c7             	mov    %rax,%rdi
+  40047b:	e8 89 19 00 00       	callq  401e09 <getcwd>
+            strcpy(toSend,buff);
+  400480:	48 8d 95 a4 fe ff ff 	lea    -0x15c(%rbp),%rdx
+  400487:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
+  40048e:	48 89 d6             	mov    %rdx,%rsi
+  400491:	48 89 c7             	mov    %rax,%rdi
+  400494:	e8 a2 24 00 00       	callq  40293b <strcpy>
+  400499:	e9 b3 00 00 00       	jmpq   400551 <changedir+0x411>
+        }
+
+
+        else{
+
+            if(i == numOfComponents){
+  40049e:	8b 45 f4             	mov    -0xc(%rbp),%eax
+  4004a1:	3b 45 f0             	cmp    -0x10(%rbp),%eax
+  4004a4:	75 05                	jne    4004ab <changedir+0x36b>
+                break;
+  4004a6:	e9 c1 00 00 00       	jmpq   40056c <changedir+0x42c>
+            }
+
+
+            if(toSend[strlen(toSend)-1] != '/'){
+  4004ab:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
+  4004b2:	48 89 c7             	mov    %rax,%rdi
+  4004b5:	e8 4c 24 00 00       	callq  402906 <strlen>
+  4004ba:	ff c8                	dec    %eax
+  4004bc:	48 98                	cltq   
+  4004be:	0f b6 84 05 dc fd ff 	movzbl -0x224(%rbp,%rax,1),%eax
+  4004c5:	ff 
+  4004c6:	3c 2f                	cmp    $0x2f,%al
+  4004c8:	74 16                	je     4004e0 <changedir+0x3a0>
+                
+                strcat(toSend,"/");
+  4004ca:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
+  4004d1:	48 8d 35 d8 2d 00 00 	lea    0x2dd8(%rip),%rsi        # 4032b0 <chdir+0x38>
+  4004d8:	48 89 c7             	mov    %rax,%rdi
+  4004db:	e8 1f 26 00 00       	callq  402aff <strcat>
+            }
+            
+            strcat(toSend,components[i]);
+  4004e0:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
+  4004e7:	8b 45 f4             	mov    -0xc(%rbp),%eax
+  4004ea:	48 98                	cltq   
+  4004ec:	48 c1 e0 02          	shl    $0x2,%rax
+  4004f0:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
+  4004f7:	00 
+  4004f8:	48 01 c8             	add    %rcx,%rax
+  4004fb:	48 01 c2             	add    %rax,%rdx
+  4004fe:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
+  400505:	48 89 d6             	mov    %rdx,%rsi
+  400508:	48 89 c7             	mov    %rax,%rdi
+  40050b:	e8 ef 25 00 00       	callq  402aff <strcat>
+
+            if(chdir(toSend) == -1){
+  400510:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
+  400517:	48 89 c7             	mov    %rax,%rdi
+  40051a:	e8 59 2d 00 00       	callq  403278 <chdir>
+  40051f:	83 f8 ff             	cmp    $0xffffffff,%eax
+  400522:	75 2d                	jne    400551 <changedir+0x411>
+            //Invalid path
+            //restore to the cwd
+           int ret= chdir(originalWorkingDirectory);
+  400524:	48 8d 85 40 fe ff ff 	lea    -0x1c0(%rbp),%rax
+  40052b:	48 89 c7             	mov    %rax,%rdi
+  40052e:	e8 45 2d 00 00       	callq  403278 <chdir>
+  400533:	89 45 e4             	mov    %eax,-0x1c(%rbp)
+           if(ret<0)
+  400536:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
+  40053a:	79 13                	jns    40054f <changedir+0x40f>
+               printf("Could Not Change Directory");
+  40053c:	48 8d 3d 84 2d 00 00 	lea    0x2d84(%rip),%rdi        # 4032c7 <chdir+0x4f>
+  400543:	b8 00 00 00 00       	mov    $0x0,%eax
+  400548:	e8 e3 1c 00 00       	callq  402230 <printf>
+            break;
+  40054d:	eb 1d                	jmp    40056c <changedir+0x42c>
+  40054f:	eb 1b                	jmp    40056c <changedir+0x42c>
+            }
+        }
+
+        i = i + 1;
+  400551:	ff 45 f4             	incl   -0xc(%rbp)
+
+        if(i == numOfComponents){
+  400554:	8b 45 f4             	mov    -0xc(%rbp),%eax
+  400557:	3b 45 f0             	cmp    -0x10(%rbp),%eax
+  40055a:	75 02                	jne    40055e <changedir+0x41e>
+            break;
+  40055c:	eb 0e                	jmp    40056c <changedir+0x42c>
+
+   
+    i=0;
+
+    
+    while(i < numOfComponents){
+  40055e:	8b 45 f4             	mov    -0xc(%rbp),%eax
+  400561:	3b 45 f0             	cmp    -0x10(%rbp),%eax
+  400564:	0f 8c 10 fe ff ff    	jl     40037a <changedir+0x23a>
+  40056a:	eb 00                	jmp    40056c <changedir+0x42c>
+        }
+
+    }
+	
+
+}
+  40056c:	c9                   	leaveq 
+  40056d:	c3                   	retq   
+
+000000000040056e <setPath>:
+#include <errno.h>
+#include <string.h>
+#include <shell.h>
+
+
+char * setPath(char* env,char* path,int mode){
+  40056e:	55                   	push   %rbp
+  40056f:	48 89 e5             	mov    %rsp,%rbp
+  400572:	53                   	push   %rbx
+  400573:	48 83 ec 38          	sub    $0x38,%rsp
+  400577:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
+  40057b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
+  40057f:	89 55 cc             	mov    %edx,-0x34(%rbp)
+
+	int newEnvVarLength;
+	//char p[500];
+	char *new;
+
+	if(mode == EASIS){
+  400582:	83 7d cc 01          	cmpl   $0x1,-0x34(%rbp)
+  400586:	75 6f                	jne    4005f7 <setPath+0x89>
+
+		//Calculate new space for the path
+		newEnvVarLength = strlen("PATH=") + strlen(path)+1;
+  400588:	48 8d 3d 53 2d 00 00 	lea    0x2d53(%rip),%rdi        # 4032e2 <chdir+0x6a>
+  40058f:	e8 72 23 00 00       	callq  402906 <strlen>
+  400594:	89 c3                	mov    %eax,%ebx
+  400596:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
+  40059a:	48 89 c7             	mov    %rax,%rdi
+  40059d:	e8 64 23 00 00       	callq  402906 <strlen>
+  4005a2:	01 d8                	add    %ebx,%eax
+  4005a4:	ff c0                	inc    %eax
+  4005a6:	89 45 e4             	mov    %eax,-0x1c(%rbp)
+
+		//printf("In setPath.... passed path is :%s:\n newEnvVarLength :%d\n",path,newEnvVarLength);
+
+
+		//Allocate that space fr the new path
+		new = (char*)malloc(sizeof(char)*newEnvVarLength);
+  4005a9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
+  4005ac:	48 98                	cltq   
+  4005ae:	48 89 c7             	mov    %rax,%rdi
+  4005b1:	e8 d0 2a 00 00       	callq  403086 <malloc>
+  4005b6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
+
+		strcpy(new,"PATH=");//copy the old env variable
+  4005ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  4005be:	48 8d 35 1d 2d 00 00 	lea    0x2d1d(%rip),%rsi        # 4032e2 <chdir+0x6a>
+  4005c5:	48 89 c7             	mov    %rax,%rdi
+  4005c8:	e8 6e 23 00 00       	callq  40293b <strcpy>
+		strcpy(new+strlen("PATH="),path);
+  4005cd:	48 8d 3d 0e 2d 00 00 	lea    0x2d0e(%rip),%rdi        # 4032e2 <chdir+0x6a>
+  4005d4:	e8 2d 23 00 00       	callq  402906 <strlen>
+  4005d9:	48 63 d0             	movslq %eax,%rdx
+  4005dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  4005e0:	48 01 c2             	add    %rax,%rdx
+  4005e3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
+  4005e7:	48 89 c6             	mov    %rax,%rsi
+  4005ea:	48 89 d7             	mov    %rdx,%rdi
+  4005ed:	e8 49 23 00 00       	callq  40293b <strcpy>
+  4005f2:	e9 92 00 00 00       	jmpq   400689 <setPath+0x11b>
+	}
+	else{
+
+
+		//Calculate new space for the path
+		newEnvVarLength = strlen(env) + strlen(path)+1;
+  4005f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  4005fb:	48 89 c7             	mov    %rax,%rdi
+  4005fe:	e8 03 23 00 00       	callq  402906 <strlen>
+  400603:	89 c3                	mov    %eax,%ebx
+  400605:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
+  400609:	48 89 c7             	mov    %rax,%rdi
+  40060c:	e8 f5 22 00 00       	callq  402906 <strlen>
+  400611:	01 d8                	add    %ebx,%eax
+  400613:	ff c0                	inc    %eax
+  400615:	89 45 e4             	mov    %eax,-0x1c(%rbp)
+
+		//Allocate that space fr the new path
+		new = (char*)malloc(sizeof(char)*newEnvVarLength);
+  400618:	8b 45 e4             	mov    -0x1c(%rbp),%eax
+  40061b:	48 98                	cltq   
+  40061d:	48 89 c7             	mov    %rax,%rdi
+  400620:	e8 61 2a 00 00       	callq  403086 <malloc>
+  400625:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
+
+		strcpy(new,env);//copy the old env variable
+  400629:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
+  40062d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  400631:	48 89 d6             	mov    %rdx,%rsi
+  400634:	48 89 c7             	mov    %rax,%rdi
+  400637:	e8 ff 22 00 00       	callq  40293b <strcpy>
+		strcpy(new+strlen(env),":");
+  40063c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  400640:	48 89 c7             	mov    %rax,%rdi
+  400643:	e8 be 22 00 00       	callq  402906 <strlen>
+  400648:	48 63 d0             	movslq %eax,%rdx
+  40064b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  40064f:	48 01 d0             	add    %rdx,%rax
+  400652:	48 8d 35 8f 2c 00 00 	lea    0x2c8f(%rip),%rsi        # 4032e8 <chdir+0x70>
+  400659:	48 89 c7             	mov    %rax,%rdi
+  40065c:	e8 da 22 00 00       	callq  40293b <strcpy>
+		strcpy(new+strlen(env)+1,path);
+  400661:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  400665:	48 89 c7             	mov    %rax,%rdi
+  400668:	e8 99 22 00 00       	callq  402906 <strlen>
+  40066d:	48 98                	cltq   
+  40066f:	48 8d 50 01          	lea    0x1(%rax),%rdx
+  400673:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  400677:	48 01 c2             	add    %rax,%rdx
+  40067a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
+  40067e:	48 89 c6             	mov    %rax,%rsi
+  400681:	48 89 d7             	mov    %rdx,%rdi
+  400684:	e8 b2 22 00 00       	callq  40293b <strcpy>
+	}
+
+
+	//printf("Returning new path from setPath %s\n",new);
+
+	return new;
+  400689:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+}
+  40068d:	48 83 c4 38          	add    $0x38,%rsp
+  400691:	5b                   	pop    %rbx
+  400692:	5d                   	pop    %rbp
+  400693:	c3                   	retq   
+
+0000000000400694 <set>:
+
+
+
+void set(char * args, char** envp){
+  400694:	55                   	push   %rbp
+  400695:	48 89 e5             	mov    %rsp,%rbp
+  400698:	48 81 ec 30 04 00 00 	sub    $0x430,%rsp
+  40069f:	48 89 bd d8 fb ff ff 	mov    %rdi,-0x428(%rbp)
+  4006a6:	48 89 b5 d0 fb ff ff 	mov    %rsi,-0x430(%rbp)
+
+	char *path=NULL;
+  4006ad:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
+  4006b4:	00 
+	//include logic to check for entire string ${PATH} or $PATH
+
+
+	//printf("In set path\n\n");
+
+	tokenEquals = tokenize(args,"=");
+  4006b5:	48 8b 85 d8 fb ff ff 	mov    -0x428(%rbp),%rax
+  4006bc:	48 8d 35 27 2c 00 00 	lea    0x2c27(%rip),%rsi        # 4032ea <chdir+0x72>
+  4006c3:	48 89 c7             	mov    %rax,%rdi
+  4006c6:	e8 55 13 00 00       	callq  401a20 <tokenize>
+  4006cb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
+	 * Get the location in the envp array where PATH
+	 * is stored. We will keep the modified PATH string in this location only.
+	 */
+
+
+	envLoc=findEnvVar("PATH",envp);
+  4006cf:	48 8b 85 d0 fb ff ff 	mov    -0x430(%rbp),%rax
+  4006d6:	48 89 c6             	mov    %rax,%rsi
+  4006d9:	48 8d 3d 0c 2c 00 00 	lea    0x2c0c(%rip),%rdi        # 4032ec <chdir+0x74>
+  4006e0:	e8 9f 09 00 00       	callq  401084 <findEnvVar>
+  4006e5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
+
+	if(tokenEquals->numOfTokens==1){
+  4006e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  4006ed:	8b 00                	mov    (%rax),%eax
+  4006ef:	83 f8 01             	cmp    $0x1,%eax
+  4006f2:	75 3d                	jne    400731 <set+0x9d>
+
+		//printf("PATH= case.......\n\n");
+		strcpy(tokentoPass,"");
+  4006f4:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
+  4006fb:	48 8d 35 ef 2b 00 00 	lea    0x2bef(%rip),%rsi        # 4032f1 <chdir+0x79>
+  400702:	48 89 c7             	mov    %rax,%rdi
+  400705:	e8 31 22 00 00       	callq  40293b <strcpy>
+		path = setPath(*envLoc,tokentoPass,EASIS);
+  40070a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  40070e:	48 8b 00             	mov    (%rax),%rax
+  400711:	48 8d 8d dc fd ff ff 	lea    -0x224(%rbp),%rcx
+  400718:	ba 01 00 00 00       	mov    $0x1,%edx
+  40071d:	48 89 ce             	mov    %rcx,%rsi
+  400720:	48 89 c7             	mov    %rax,%rdi
+  400723:	e8 46 fe ff ff       	callq  40056e <setPath>
+  400728:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+  40072c:	e9 ab 01 00 00       	jmpq   4008dc <set+0x248>
+		return;
+
+	}
+
+
+	strcpy(tokentoPass,tokenEquals->tokenArr[1]);
+  400731:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  400735:	48 8b 50 10          	mov    0x10(%rax),%rdx
+  400739:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
+  400740:	48 89 d6             	mov    %rdx,%rsi
+  400743:	48 89 c7             	mov    %rax,%rdi
+  400746:	e8 f0 21 00 00       	callq  40293b <strcpy>
+	//printf("Token to pass after tokenizing on colon is .%s.\n",tokentoPass);
+	tokenColon = tokenize(tokentoPass,":");
+  40074b:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
+  400752:	48 8d 35 8f 2b 00 00 	lea    0x2b8f(%rip),%rsi        # 4032e8 <chdir+0x70>
+  400759:	48 89 c7             	mov    %rax,%rdi
+  40075c:	e8 bf 12 00 00       	callq  401a20 <tokenize>
+  400761:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
+	/*
+	 * Save the value of PATH in oldSysPath.We will need this
+	 * when we need to expand ${PATH}
+	 */
+	char oldSysPath[500];
+	token = tokenize(*envLoc,"=");
+  400765:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  400769:	48 8b 00             	mov    (%rax),%rax
+  40076c:	48 8d 35 77 2b 00 00 	lea    0x2b77(%rip),%rsi        # 4032ea <chdir+0x72>
+  400773:	48 89 c7             	mov    %rax,%rdi
+  400776:	e8 a5 12 00 00       	callq  401a20 <tokenize>
+  40077b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
+	strcpy(oldSysPath,token->tokenArr[1]);
+  40077f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
+  400783:	48 8b 50 10          	mov    0x10(%rax),%rdx
+  400787:	48 8d 85 e8 fb ff ff 	lea    -0x418(%rbp),%rax
+  40078e:	48 89 d6             	mov    %rdx,%rsi
+  400791:	48 89 c7             	mov    %rax,%rdi
+  400794:	e8 a2 21 00 00       	callq  40293b <strcpy>
+
+	/*
+	 * First element of the tokenColon always needs to be addes ASIS
+	 * Check if the component to add is ${PATH}.If yes send oldSysPath
+	 */
+	if((strcmp(tokenColon->tokenArr[0],"${PATH}")==0)||(strcmp(tokenColon->tokenArr[0],"$PATH")==0)){
+  400799:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  40079d:	48 8b 40 08          	mov    0x8(%rax),%rax
+  4007a1:	48 8d 35 4a 2b 00 00 	lea    0x2b4a(%rip),%rsi        # 4032f2 <chdir+0x7a>
+  4007a8:	48 89 c7             	mov    %rax,%rdi
+  4007ab:	e8 ea 21 00 00       	callq  40299a <strcmp>
+  4007b0:	85 c0                	test   %eax,%eax
+  4007b2:	74 1b                	je     4007cf <set+0x13b>
+  4007b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  4007b8:	48 8b 40 08          	mov    0x8(%rax),%rax
+  4007bc:	48 8d 35 37 2b 00 00 	lea    0x2b37(%rip),%rsi        # 4032fa <chdir+0x82>
+  4007c3:	48 89 c7             	mov    %rax,%rdi
+  4007c6:	e8 cf 21 00 00       	callq  40299a <strcmp>
+  4007cb:	85 c0                	test   %eax,%eax
+  4007cd:	75 24                	jne    4007f3 <set+0x15f>
+		path = setPath(*envLoc,oldSysPath,EASIS);
+  4007cf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  4007d3:	48 8b 00             	mov    (%rax),%rax
+  4007d6:	48 8d 8d e8 fb ff ff 	lea    -0x418(%rbp),%rcx
+  4007dd:	ba 01 00 00 00       	mov    $0x1,%edx
+  4007e2:	48 89 ce             	mov    %rcx,%rsi
+  4007e5:	48 89 c7             	mov    %rax,%rdi
+  4007e8:	e8 81 fd ff ff       	callq  40056e <setPath>
+  4007ed:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+  4007f1:	eb 23                	jmp    400816 <set+0x182>
+		//printf("PATH IS %s\n",path);
+	}
+	else{
+		path = setPath(*envLoc,tokenColon->tokenArr[0],EASIS);
+  4007f3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  4007f7:	48 8b 48 08          	mov    0x8(%rax),%rcx
+  4007fb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  4007ff:	48 8b 00             	mov    (%rax),%rax
+  400802:	ba 01 00 00 00       	mov    $0x1,%edx
+  400807:	48 89 ce             	mov    %rcx,%rsi
+  40080a:	48 89 c7             	mov    %rax,%rdi
+  40080d:	e8 5c fd ff ff       	callq  40056e <setPath>
+  400812:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+	}
+
+	//Assign the newly modified path to envLoc.This causes the envp array to get updated
+	*envLoc = path;
+  400816:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  40081a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
+  40081e:	48 89 10             	mov    %rdx,(%rax)
+
+	//printf("The new environment is: %s\n", getenv("PATH"));
+
+
+	//Append the later elements in a loop
+	for(i=1;i<tokenColon->numOfTokens;i++){
+  400821:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
+  400828:	e9 a0 00 00 00       	jmpq   4008cd <set+0x239>
+
+		/*
+		 * Check if the component to add is ${PATH}.If yes send oldSysPath
+		 *
+		 */
+		if((strcmp(tokenColon->tokenArr[i],"${PATH}")==0)||(strcmp(tokenColon->tokenArr[i],"$PATH")==0)){
+  40082d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  400831:	8b 55 f4             	mov    -0xc(%rbp),%edx
+  400834:	48 63 d2             	movslq %edx,%rdx
+  400837:	48 8b 44 d0 08       	mov    0x8(%rax,%rdx,8),%rax
+  40083c:	48 8d 35 af 2a 00 00 	lea    0x2aaf(%rip),%rsi        # 4032f2 <chdir+0x7a>
+  400843:	48 89 c7             	mov    %rax,%rdi
+  400846:	e8 4f 21 00 00       	callq  40299a <strcmp>
+  40084b:	85 c0                	test   %eax,%eax
+  40084d:	74 22                	je     400871 <set+0x1dd>
+  40084f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  400853:	8b 55 f4             	mov    -0xc(%rbp),%edx
+  400856:	48 63 d2             	movslq %edx,%rdx
+  400859:	48 8b 44 d0 08       	mov    0x8(%rax,%rdx,8),%rax
+  40085e:	48 8d 35 95 2a 00 00 	lea    0x2a95(%rip),%rsi        # 4032fa <chdir+0x82>
+  400865:	48 89 c7             	mov    %rax,%rdi
+  400868:	e8 2d 21 00 00       	callq  40299a <strcmp>
+  40086d:	85 c0                	test   %eax,%eax
+  40086f:	75 24                	jne    400895 <set+0x201>
+			path = setPath(*envLoc,oldSysPath,EAPPEND);
+  400871:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  400875:	48 8b 00             	mov    (%rax),%rax
+  400878:	48 8d 8d e8 fb ff ff 	lea    -0x418(%rbp),%rcx
+  40087f:	ba 02 00 00 00       	mov    $0x2,%edx
+  400884:	48 89 ce             	mov    %rcx,%rsi
+  400887:	48 89 c7             	mov    %rax,%rdi
+  40088a:	e8 df fc ff ff       	callq  40056e <setPath>
+  40088f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+  400893:	eb 2a                	jmp    4008bf <set+0x22b>
+			//printf("PATH IS %s\n",path);
+		}
+		else{
+			path = setPath(*envLoc,tokenColon->tokenArr[i],EAPPEND);
+  400895:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  400899:	8b 55 f4             	mov    -0xc(%rbp),%edx
+  40089c:	48 63 d2             	movslq %edx,%rdx
+  40089f:	48 8b 4c d0 08       	mov    0x8(%rax,%rdx,8),%rcx
+  4008a4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  4008a8:	48 8b 00             	mov    (%rax),%rax
+  4008ab:	ba 02 00 00 00       	mov    $0x2,%edx
+  4008b0:	48 89 ce             	mov    %rcx,%rsi
+  4008b3:	48 89 c7             	mov    %rax,%rdi
+  4008b6:	e8 b3 fc ff ff       	callq  40056e <setPath>
+  4008bb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+		}
+
+		//Assign the newly modified path to envLoc.This causes the envp array to get updated
+		*envLoc = path;
+  4008bf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  4008c3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
+  4008c7:	48 89 10             	mov    %rdx,(%rax)
+
+	//printf("The new environment is: %s\n", getenv("PATH"));
+
+
+	//Append the later elements in a loop
+	for(i=1;i<tokenColon->numOfTokens;i++){
+  4008ca:	ff 45 f4             	incl   -0xc(%rbp)
+  4008cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  4008d1:	8b 00                	mov    (%rax),%eax
+  4008d3:	3b 45 f4             	cmp    -0xc(%rbp),%eax
+  4008d6:	0f 8f 51 ff ff ff    	jg     40082d <set+0x199>
+
+
+	}//End of for loop
+
+	//printf("The new environment is: %s\n", getenv("PATH"));
+}
+  4008dc:	c9                   	leaveq 
+  4008dd:	c3                   	retq   
+
+00000000004008de <executeBuiltins>:
+#include <parser.h>
+#include <errno.h>
+#include <string.h>
+#include <shell.h>
+
+void executeBuiltins(parseInfo* command,char*envp[]){
+  4008de:	55                   	push   %rbp
+  4008df:	48 89 e5             	mov    %rsp,%rbp
+  4008e2:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
+  4008e6:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
+  4008ea:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
+		printf("Token %d : %s\n",i,command->CommArray[0]->VarList[i]);
+	}*/
+
+
+
+	if(strcmp(command->CommArray[0]->commandName,"set")==0){
+  4008ee:	48 8b 45 88          	mov    -0x78(%rbp),%rax
+  4008f2:	48 8b 00             	mov    (%rax),%rax
+  4008f5:	48 8b 00             	mov    (%rax),%rax
+  4008f8:	48 8d 35 01 2a 00 00 	lea    0x2a01(%rip),%rsi        # 403300 <chdir+0x88>
+  4008ff:	48 89 c7             	mov    %rax,%rdi
+  400902:	e8 93 20 00 00       	callq  40299a <strcmp>
+  400907:	85 c0                	test   %eax,%eax
+  400909:	0f 85 f5 00 00 00    	jne    400a04 <executeBuiltins+0x126>
+
+		if(strstr(command->CommArray[0]->VarList[1],"PATH")!=NULL){
+  40090f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
+  400913:	48 8b 00             	mov    (%rax),%rax
+  400916:	48 8b 40 10          	mov    0x10(%rax),%rax
+  40091a:	48 8d 35 e3 29 00 00 	lea    0x29e3(%rip),%rsi        # 403304 <chdir+0x8c>
+  400921:	48 89 c7             	mov    %rax,%rdi
+  400924:	e8 f8 20 00 00       	callq  402a21 <strstr>
+  400929:	48 85 c0             	test   %rax,%rax
+  40092c:	74 76                	je     4009a4 <executeBuiltins+0xc6>
+			//execute change PATH
+			//printf("Going to change path");
+
+
+			if(command->CommArray[0]->VarNum >2){
+  40092e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
+  400932:	48 8b 00             	mov    (%rax),%rax
+  400935:	8b 40 58             	mov    0x58(%rax),%eax
+  400938:	83 f8 02             	cmp    $0x2,%eax
+  40093b:	7e 16                	jle    400953 <executeBuiltins+0x75>
+
+				printf("Too many arguments to set PATH.Please enter set PATH=ABC:XYX:... (no spaces in between)\n");
+  40093d:	48 8d 3d cc 29 00 00 	lea    0x29cc(%rip),%rdi        # 403310 <chdir+0x98>
+  400944:	b8 00 00 00 00       	mov    $0x0,%eax
+  400949:	e8 e2 18 00 00       	callq  402230 <printf>
+				return;
+  40094e:	e9 56 01 00 00       	jmpq   400aa9 <executeBuiltins+0x1cb>
+			}
+
+
+			set(command->CommArray[0]->VarList[1],envp);
+  400953:	48 8b 45 88          	mov    -0x78(%rbp),%rax
+  400957:	48 8b 00             	mov    (%rax),%rax
+  40095a:	48 8b 40 10          	mov    0x10(%rax),%rax
+  40095e:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
+  400962:	48 89 d6             	mov    %rdx,%rsi
+  400965:	48 89 c7             	mov    %rax,%rdi
+  400968:	e8 27 fd ff ff       	callq  400694 <set>
+			envVar=findEnvVar("PATH",envp);
+  40096d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
+  400971:	48 89 c6             	mov    %rax,%rsi
+  400974:	48 8d 3d 89 29 00 00 	lea    0x2989(%rip),%rdi        # 403304 <chdir+0x8c>
+  40097b:	e8 04 07 00 00       	callq  401084 <findEnvVar>
+  400980:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+			printf("Current Path is :\n %s\n",*envVar);
+  400984:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  400988:	48 8b 00             	mov    (%rax),%rax
+  40098b:	48 89 c6             	mov    %rax,%rsi
+  40098e:	48 8d 3d d4 29 00 00 	lea    0x29d4(%rip),%rdi        # 403369 <chdir+0xf1>
+  400995:	b8 00 00 00 00       	mov    $0x0,%eax
+  40099a:	e8 91 18 00 00       	callq  402230 <printf>
+  40099f:	e9 04 01 00 00       	jmpq   400aa8 <executeBuiltins+0x1ca>
+
+
+		}
+		else if(strstr(command->CommArray[0]->VarList[1],"PS1")!=NULL){
+  4009a4:	48 8b 45 88          	mov    -0x78(%rbp),%rax
+  4009a8:	48 8b 00             	mov    (%rax),%rax
+  4009ab:	48 8b 40 10          	mov    0x10(%rax),%rax
+  4009af:	48 8d 35 ca 29 00 00 	lea    0x29ca(%rip),%rsi        # 403380 <chdir+0x108>
+  4009b6:	48 89 c7             	mov    %rax,%rdi
+  4009b9:	e8 63 20 00 00       	callq  402a21 <strstr>
+  4009be:	48 85 c0             	test   %rax,%rax
+  4009c1:	0f 84 e1 00 00 00    	je     400aa8 <executeBuiltins+0x1ca>
+			//simple change the shell variable PS1
+			//Add function to remove spaces from PS1=hgchbvh
+
+			//printf("Going to change PS1");
+
+			if(command->CommArray[0]->VarNum >2){
+  4009c7:	48 8b 45 88          	mov    -0x78(%rbp),%rax
+  4009cb:	48 8b 00             	mov    (%rax),%rax
+  4009ce:	8b 40 58             	mov    0x58(%rax),%eax
+  4009d1:	83 f8 02             	cmp    $0x2,%eax
+  4009d4:	7e 16                	jle    4009ec <executeBuiltins+0x10e>
+
+				printf("Too many arguments to set PS1.Please enter set PS1=ABCD (no spaces in between)\n");
+  4009d6:	48 8d 3d ab 29 00 00 	lea    0x29ab(%rip),%rdi        # 403388 <chdir+0x110>
+  4009dd:	b8 00 00 00 00       	mov    $0x0,%eax
+  4009e2:	e8 49 18 00 00       	callq  402230 <printf>
+				return;
+  4009e7:	e9 bd 00 00 00       	jmpq   400aa9 <executeBuiltins+0x1cb>
+			}
+
+			changePS1(command->CommArray[0]->VarList[1]);
+  4009ec:	48 8b 45 88          	mov    -0x78(%rbp),%rax
+  4009f0:	48 8b 00             	mov    (%rax),%rax
+  4009f3:	48 8b 40 10          	mov    0x10(%rax),%rax
+  4009f7:	48 89 c7             	mov    %rax,%rdi
+  4009fa:	e8 03 0b 00 00       	callq  401502 <changePS1>
+		printf("Current Working Directory is: %s\n",cmdWithoutSpaces);
+
+	}
+
+
+	return;
+  4009ff:	e9 a5 00 00 00       	jmpq   400aa9 <executeBuiltins+0x1cb>
+
+		}
+	}
+
+
+	else if(strcmp(command->CommArray[0]->commandName,"exit")==0){
+  400a04:	48 8b 45 88          	mov    -0x78(%rbp),%rax
+  400a08:	48 8b 00             	mov    (%rax),%rax
+  400a0b:	48 8b 00             	mov    (%rax),%rax
+  400a0e:	48 8d 35 c3 29 00 00 	lea    0x29c3(%rip),%rsi        # 4033d8 <chdir+0x160>
+  400a15:	48 89 c7             	mov    %rax,%rdi
+  400a18:	e8 7d 1f 00 00       	callq  40299a <strcmp>
+  400a1d:	85 c0                	test   %eax,%eax
+  400a1f:	75 0c                	jne    400a2d <executeBuiltins+0x14f>
+
+		exit(0);
+  400a21:	bf 00 00 00 00       	mov    $0x0,%edi
+  400a26:	e8 bf 1e 00 00       	callq  4028ea <exit>
+  400a2b:	eb 7b                	jmp    400aa8 <executeBuiltins+0x1ca>
+	}
+
+	else if(strcmp(command->CommArray[0]->commandName,"cd")==0) {
+  400a2d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
+  400a31:	48 8b 00             	mov    (%rax),%rax
+  400a34:	48 8b 00             	mov    (%rax),%rax
+  400a37:	48 8d 35 9f 29 00 00 	lea    0x299f(%rip),%rsi        # 4033dd <chdir+0x165>
+  400a3e:	48 89 c7             	mov    %rax,%rdi
+  400a41:	e8 54 1f 00 00       	callq  40299a <strcmp>
+  400a46:	85 c0                	test   %eax,%eax
+  400a48:	75 5e                	jne    400aa8 <executeBuiltins+0x1ca>
+		if(command->CommArray[0]->VarNum >2){
+  400a4a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
+  400a4e:	48 8b 00             	mov    (%rax),%rax
+  400a51:	8b 40 58             	mov    0x58(%rax),%eax
+  400a54:	83 f8 02             	cmp    $0x2,%eax
+  400a57:	7e 13                	jle    400a6c <executeBuiltins+0x18e>
+
+			printf("Too many arguments to cd.Please enter cd <directory name>\n");
+  400a59:	48 8d 3d 80 29 00 00 	lea    0x2980(%rip),%rdi        # 4033e0 <chdir+0x168>
+  400a60:	b8 00 00 00 00       	mov    $0x0,%eax
+  400a65:	e8 c6 17 00 00       	callq  402230 <printf>
+			return;
+  400a6a:	eb 3d                	jmp    400aa9 <executeBuiltins+0x1cb>
+		}
+
+
+		//execute change directory
+		changedir(command->CommArray[0]->VarList[1]);
+  400a6c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
+  400a70:	48 8b 00             	mov    (%rax),%rax
+  400a73:	48 8b 40 10          	mov    0x10(%rax),%rax
+  400a77:	48 89 c7             	mov    %rax,%rdi
+  400a7a:	e8 c1 f6 ff ff       	callq  400140 <changedir>
+		getcwd(cmdWithoutSpaces,100);
+  400a7f:	48 8d 45 94          	lea    -0x6c(%rbp),%rax
+  400a83:	be 64 00 00 00       	mov    $0x64,%esi
+  400a88:	48 89 c7             	mov    %rax,%rdi
+  400a8b:	e8 79 13 00 00       	callq  401e09 <getcwd>
+		printf("Current Working Directory is: %s\n",cmdWithoutSpaces);
+  400a90:	48 8d 45 94          	lea    -0x6c(%rbp),%rax
+  400a94:	48 89 c6             	mov    %rax,%rsi
+  400a97:	48 8d 3d 82 29 00 00 	lea    0x2982(%rip),%rdi        # 403420 <chdir+0x1a8>
+  400a9e:	b8 00 00 00 00       	mov    $0x0,%eax
+  400aa3:	e8 88 17 00 00       	callq  402230 <printf>
+
+	}
+
+
+	return;
+  400aa8:	90                   	nop
+
+
+}
+  400aa9:	c9                   	leaveq 
+  400aaa:	c3                   	retq   
+
+0000000000400aab <execute_cmd>:
+#include <shell.h>
+
+
+
+void execute_cmd(parseInfo * info,char*envp[])
+{
+  400aab:	55                   	push   %rbp
+  400aac:	48 89 e5             	mov    %rsp,%rbp
+  400aaf:	53                   	push   %rbx
+  400ab0:	48 81 ec 28 08 00 00 	sub    $0x828,%rsp
+  400ab7:	48 89 bd d8 f7 ff ff 	mov    %rdi,-0x828(%rbp)
+  400abe:	48 89 b5 d0 f7 ff ff 	mov    %rsi,-0x830(%rbp)
+	int i,j,*pipes=NULL,status;
+  400ac5:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
+  400acc:	00 
+	char cmd[20][100];
+
+	int  *proc_ids;
+	//printf("pipes=%d \n",info->pipeNum);
+
+	for(i=0; i<=info->pipeNum; i++)
+  400acd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
+  400ad4:	eb 36                	jmp    400b0c <execute_cmd+0x61>
+	{
+		//printf("info: %s\n", info->CommArray[i]->commandName);
+		strcpy(cmd[i],info->CommArray[i]->commandName);
+  400ad6:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
+  400add:	8b 55 ec             	mov    -0x14(%rbp),%edx
+  400ae0:	48 63 d2             	movslq %edx,%rdx
+  400ae3:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
+  400ae7:	48 8b 00             	mov    (%rax),%rax
+  400aea:	48 8d 8d fc f7 ff ff 	lea    -0x804(%rbp),%rcx
+  400af1:	8b 55 ec             	mov    -0x14(%rbp),%edx
+  400af4:	48 63 d2             	movslq %edx,%rdx
+  400af7:	48 6b d2 64          	imul   $0x64,%rdx,%rdx
+  400afb:	48 01 ca             	add    %rcx,%rdx
+  400afe:	48 89 c6             	mov    %rax,%rsi
+  400b01:	48 89 d7             	mov    %rdx,%rdi
+  400b04:	e8 32 1e 00 00       	callq  40293b <strcpy>
+	char cmd[20][100];
+
+	int  *proc_ids;
+	//printf("pipes=%d \n",info->pipeNum);
+
+	for(i=0; i<=info->pipeNum; i++)
+  400b09:	ff 45 ec             	incl   -0x14(%rbp)
+  400b0c:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
+  400b13:	8b 40 50             	mov    0x50(%rax),%eax
+  400b16:	3b 45 ec             	cmp    -0x14(%rbp),%eax
+  400b19:	7d bb                	jge    400ad6 <execute_cmd+0x2b>
+		//printf("varList=%s\n",info->CommArray[i]->VarList[j]);
+	}
+
+
+
+	proc_ids = (int *)malloc(info->pipeNum+1);
+  400b1b:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
+  400b22:	8b 40 50             	mov    0x50(%rax),%eax
+  400b25:	ff c0                	inc    %eax
+  400b27:	48 98                	cltq   
+  400b29:	48 89 c7             	mov    %rax,%rdi
+  400b2c:	e8 55 25 00 00       	callq  403086 <malloc>
+  400b31:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
+
+	if(info->pipeNum==0)
+  400b35:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
+  400b3c:	8b 40 50             	mov    0x50(%rax),%eax
+  400b3f:	85 c0                	test   %eax,%eax
+  400b41:	0f 85 ca 00 00 00    	jne    400c11 <execute_cmd+0x166>
+	{
+		printf("forking");
+  400b47:	48 8d 3d f4 28 00 00 	lea    0x28f4(%rip),%rdi        # 403442 <chdir+0x1ca>
+  400b4e:	b8 00 00 00 00       	mov    $0x0,%eax
+  400b53:	e8 d8 16 00 00       	callq  402230 <printf>
+
+
+		proc_ids[0]=fork();
+  400b58:	e8 22 1d 00 00       	callq  40287f <fork>
+  400b5d:	89 c2                	mov    %eax,%edx
+  400b5f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  400b63:	89 10                	mov    %edx,(%rax)
+
+		if (proc_ids[0] < 0)
+  400b65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  400b69:	8b 00                	mov    (%rax),%eax
+  400b6b:	85 c0                	test   %eax,%eax
+  400b6d:	79 1a                	jns    400b89 <execute_cmd+0xde>
+		{
+			strerror( errno);
+  400b6f:	48 8b 05 82 38 20 00 	mov    0x203882(%rip),%rax        # 6043f8 <chdir+0x201180>
+  400b76:	8b 00                	mov    (%rax),%eax
+  400b78:	89 c7                	mov    %eax,%edi
+  400b7a:	e8 bb 1f 00 00       	callq  402b3a <strerror>
+			exit(1);
+  400b7f:	bf 01 00 00 00       	mov    $0x1,%edi
+  400b84:	e8 61 1d 00 00       	callq  4028ea <exit>
+		}
+		if(proc_ids[0]==0)
+  400b89:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  400b8d:	8b 00                	mov    (%rax),%eax
+  400b8f:	85 c0                	test   %eax,%eax
+  400b91:	0f 85 08 03 00 00    	jne    400e9f <execute_cmd+0x3f4>
+		{
+			//printf("executing %s\n",cmd[0]);
+
+			printf("Executing Command %s\n",cmd[0]);
+  400b97:	48 8d 85 fc f7 ff ff 	lea    -0x804(%rbp),%rax
+  400b9e:	48 89 c6             	mov    %rax,%rsi
+  400ba1:	48 8d 3d a2 28 00 00 	lea    0x28a2(%rip),%rdi        # 40344a <chdir+0x1d2>
+  400ba8:	b8 00 00 00 00       	mov    $0x0,%eax
+  400bad:	e8 7e 16 00 00       	callq  402230 <printf>
+
+			char* envpChildProcess[]={NULL};
+  400bb2:	48 c7 85 f0 f7 ff ff 	movq   $0x0,-0x810(%rbp)
+  400bb9:	00 00 00 00 
+			int ret = execve(cmd[0],info->CommArray[0]->VarList,envpChildProcess);
+  400bbd:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
+  400bc4:	48 8b 00             	mov    (%rax),%rax
+  400bc7:	48 8d 48 08          	lea    0x8(%rax),%rcx
+  400bcb:	48 8d 95 f0 f7 ff ff 	lea    -0x810(%rbp),%rdx
+  400bd2:	48 8d 85 fc f7 ff ff 	lea    -0x804(%rbp),%rax
+  400bd9:	48 89 ce             	mov    %rcx,%rsi
+  400bdc:	48 89 c7             	mov    %rax,%rdi
+  400bdf:	e8 3a 1c 00 00       	callq  40281e <execve>
+  400be4:	89 45 d4             	mov    %eax,-0x2c(%rbp)
+			if(ret == -1)
+  400be7:	83 7d d4 ff          	cmpl   $0xffffffff,-0x2c(%rbp)
+  400beb:	75 1f                	jne    400c0c <execute_cmd+0x161>
+			{
+				strerror(errno);
+  400bed:	48 8b 05 04 38 20 00 	mov    0x203804(%rip),%rax        # 6043f8 <chdir+0x201180>
+  400bf4:	8b 00                	mov    (%rax),%eax
+  400bf6:	89 c7                	mov    %eax,%edi
+  400bf8:	e8 3d 1f 00 00       	callq  402b3a <strerror>
+				exit(1);
+  400bfd:	bf 01 00 00 00       	mov    $0x1,%edi
+  400c02:	e8 e3 1c 00 00       	callq  4028ea <exit>
+  400c07:	e9 93 02 00 00       	jmpq   400e9f <execute_cmd+0x3f4>
+  400c0c:	e9 8e 02 00 00       	jmpq   400e9f <execute_cmd+0x3f4>
+		//printf("\ndone\n");
+	}
+	else
+	{
+
+		pipes=(int*)malloc(2*info->pipeNum*sizeof(int));
+  400c11:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
+  400c18:	8b 40 50             	mov    0x50(%rax),%eax
+  400c1b:	48 98                	cltq   
+  400c1d:	48 c1 e0 03          	shl    $0x3,%rax
+  400c21:	48 89 c7             	mov    %rax,%rdi
+  400c24:	e8 5d 24 00 00       	callq  403086 <malloc>
+  400c29:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
+
+
+		for(i=0; i<info->pipeNum; i++)
+  400c2d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
+  400c34:	eb 34                	jmp    400c6a <execute_cmd+0x1bf>
+		{
+			if(pipe(pipes+i*2) == -1)
+  400c36:	8b 45 ec             	mov    -0x14(%rbp),%eax
+  400c39:	48 98                	cltq   
+  400c3b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
+  400c42:	00 
+  400c43:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  400c47:	48 01 d0             	add    %rdx,%rax
+  400c4a:	48 89 c7             	mov    %rax,%rdi
+  400c4d:	e8 63 1b 00 00       	callq  4027b5 <pipe>
+  400c52:	83 f8 ff             	cmp    $0xffffffff,%eax
+  400c55:	75 10                	jne    400c67 <execute_cmd+0x1bc>
+				strerror(errno);
+  400c57:	48 8b 05 9a 37 20 00 	mov    0x20379a(%rip),%rax        # 6043f8 <chdir+0x201180>
+  400c5e:	8b 00                	mov    (%rax),%eax
+  400c60:	89 c7                	mov    %eax,%edi
+  400c62:	e8 d3 1e 00 00       	callq  402b3a <strerror>
+	{
+
+		pipes=(int*)malloc(2*info->pipeNum*sizeof(int));
+
+
+		for(i=0; i<info->pipeNum; i++)
+  400c67:	ff 45 ec             	incl   -0x14(%rbp)
+  400c6a:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
+  400c71:	8b 40 50             	mov    0x50(%rax),%eax
+  400c74:	3b 45 ec             	cmp    -0x14(%rbp),%eax
+  400c77:	7f bd                	jg     400c36 <execute_cmd+0x18b>
+		{
+			if(pipe(pipes+i*2) == -1)
+				strerror(errno);
+		}
+		//printf("Multiple Commands");
+		for(i=0; i<=info->pipeNum;i++)
+  400c79:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
+  400c80:	e9 b2 01 00 00       	jmpq   400e37 <execute_cmd+0x38c>
+		{
+			proc_ids[i]=fork();
+  400c85:	8b 45 ec             	mov    -0x14(%rbp),%eax
+  400c88:	48 98                	cltq   
+  400c8a:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
+  400c91:	00 
+  400c92:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  400c96:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
+  400c9a:	e8 e0 1b 00 00       	callq  40287f <fork>
+  400c9f:	89 03                	mov    %eax,(%rbx)
+			if (proc_ids[i] < 0)
+  400ca1:	8b 45 ec             	mov    -0x14(%rbp),%eax
+  400ca4:	48 98                	cltq   
+  400ca6:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
+  400cad:	00 
+  400cae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  400cb2:	48 01 d0             	add    %rdx,%rax
+  400cb5:	8b 00                	mov    (%rax),%eax
+  400cb7:	85 c0                	test   %eax,%eax
+  400cb9:	79 1a                	jns    400cd5 <execute_cmd+0x22a>
+			{
+				strerror(errno);
+  400cbb:	48 8b 05 36 37 20 00 	mov    0x203736(%rip),%rax        # 6043f8 <chdir+0x201180>
+  400cc2:	8b 00                	mov    (%rax),%eax
+  400cc4:	89 c7                	mov    %eax,%edi
+  400cc6:	e8 6f 1e 00 00       	callq  402b3a <strerror>
+				exit(1);
+  400ccb:	bf 01 00 00 00       	mov    $0x1,%edi
+  400cd0:	e8 15 1c 00 00       	callq  4028ea <exit>
+			}
+			//printf("pid=%d",proc_ids[i]);
+			if(proc_ids[i]==0)
+  400cd5:	8b 45 ec             	mov    -0x14(%rbp),%eax
+  400cd8:	48 98                	cltq   
+  400cda:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
+  400ce1:	00 
+  400ce2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  400ce6:	48 01 d0             	add    %rdx,%rax
+  400ce9:	8b 00                	mov    (%rax),%eax
+  400ceb:	85 c0                	test   %eax,%eax
+  400ced:	0f 85 41 01 00 00    	jne    400e34 <execute_cmd+0x389>
+			{
+				//printf("in child%d",i);
+
+				if(i!=0)
+  400cf3:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
+  400cf7:	74 37                	je     400d30 <execute_cmd+0x285>
+				{
+					if(dup2(pipes[i*2-2],0)==-1)
+  400cf9:	8b 45 ec             	mov    -0x14(%rbp),%eax
+  400cfc:	48 98                	cltq   
+  400cfe:	48 c1 e0 03          	shl    $0x3,%rax
+  400d02:	48 8d 50 f8          	lea    -0x8(%rax),%rdx
+  400d06:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  400d0a:	48 01 d0             	add    %rdx,%rax
+  400d0d:	8b 00                	mov    (%rax),%eax
+  400d0f:	be 00 00 00 00       	mov    $0x0,%esi
+  400d14:	89 c7                	mov    %eax,%edi
+  400d16:	e8 1a 10 00 00       	callq  401d35 <dup2>
+  400d1b:	83 f8 ff             	cmp    $0xffffffff,%eax
+  400d1e:	75 10                	jne    400d30 <execute_cmd+0x285>
+						strerror(errno);
+  400d20:	48 8b 05 d1 36 20 00 	mov    0x2036d1(%rip),%rax        # 6043f8 <chdir+0x201180>
+  400d27:	8b 00                	mov    (%rax),%eax
+  400d29:	89 c7                	mov    %eax,%edi
+  400d2b:	e8 0a 1e 00 00       	callq  402b3a <strerror>
+				}
+				if(i!=info->pipeNum)
+  400d30:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
+  400d37:	8b 40 50             	mov    0x50(%rax),%eax
+  400d3a:	3b 45 ec             	cmp    -0x14(%rbp),%eax
+  400d3d:	74 37                	je     400d76 <execute_cmd+0x2cb>
+				{
+
+					if(dup2(pipes[i*2+1],1)==-1)
+  400d3f:	8b 45 ec             	mov    -0x14(%rbp),%eax
+  400d42:	48 98                	cltq   
+  400d44:	48 c1 e0 03          	shl    $0x3,%rax
+  400d48:	48 8d 50 04          	lea    0x4(%rax),%rdx
+  400d4c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  400d50:	48 01 d0             	add    %rdx,%rax
+  400d53:	8b 00                	mov    (%rax),%eax
+  400d55:	be 01 00 00 00       	mov    $0x1,%esi
+  400d5a:	89 c7                	mov    %eax,%edi
+  400d5c:	e8 d4 0f 00 00       	callq  401d35 <dup2>
+  400d61:	83 f8 ff             	cmp    $0xffffffff,%eax
+  400d64:	75 10                	jne    400d76 <execute_cmd+0x2cb>
+						strerror(errno);
+  400d66:	48 8b 05 8b 36 20 00 	mov    0x20368b(%rip),%rax        # 6043f8 <chdir+0x201180>
+  400d6d:	8b 00                	mov    (%rax),%eax
+  400d6f:	89 c7                	mov    %eax,%edi
+  400d71:	e8 c4 1d 00 00       	callq  402b3a <strerror>
+				}
+
+				for(j=0;j<info->pipeNum;j++)
+  400d76:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
+  400d7d:	eb 3d                	jmp    400dbc <execute_cmd+0x311>
+				{
+					close(pipes[j*2]);
+  400d7f:	8b 45 e8             	mov    -0x18(%rbp),%eax
+  400d82:	48 98                	cltq   
+  400d84:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
+  400d8b:	00 
+  400d8c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  400d90:	48 01 d0             	add    %rdx,%rax
+  400d93:	8b 00                	mov    (%rax),%eax
+  400d95:	89 c7                	mov    %eax,%edi
+  400d97:	e8 ec 10 00 00       	callq  401e88 <close>
+					close(pipes[j*2+1]);
+  400d9c:	8b 45 e8             	mov    -0x18(%rbp),%eax
+  400d9f:	48 98                	cltq   
+  400da1:	48 c1 e0 03          	shl    $0x3,%rax
+  400da5:	48 8d 50 04          	lea    0x4(%rax),%rdx
+  400da9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  400dad:	48 01 d0             	add    %rdx,%rax
+  400db0:	8b 00                	mov    (%rax),%eax
+  400db2:	89 c7                	mov    %eax,%edi
+  400db4:	e8 cf 10 00 00       	callq  401e88 <close>
+
+					if(dup2(pipes[i*2+1],1)==-1)
+						strerror(errno);
+				}
+
+				for(j=0;j<info->pipeNum;j++)
+  400db9:	ff 45 e8             	incl   -0x18(%rbp)
+  400dbc:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
+  400dc3:	8b 40 50             	mov    0x50(%rax),%eax
+  400dc6:	3b 45 e8             	cmp    -0x18(%rbp),%eax
+  400dc9:	7f b4                	jg     400d7f <execute_cmd+0x2d4>
+				//printf("debug:%s ", cmd[i]);
+
+
+				//printf("Executing Command %s\n",cmd[i]);
+
+				char* envpChildProcess[]={NULL};
+  400dcb:	48 c7 85 e8 f7 ff ff 	movq   $0x0,-0x818(%rbp)
+  400dd2:	00 00 00 00 
+				int ret=execve(cmd[i],info->CommArray[i]->VarList,envpChildProcess);
+  400dd6:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
+  400ddd:	8b 55 ec             	mov    -0x14(%rbp),%edx
+  400de0:	48 63 d2             	movslq %edx,%rdx
+  400de3:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
+  400de7:	48 8d 70 08          	lea    0x8(%rax),%rsi
+  400deb:	48 8d 95 fc f7 ff ff 	lea    -0x804(%rbp),%rdx
+  400df2:	8b 45 ec             	mov    -0x14(%rbp),%eax
+  400df5:	48 98                	cltq   
+  400df7:	48 6b c0 64          	imul   $0x64,%rax,%rax
+  400dfb:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
+  400dff:	48 8d 85 e8 f7 ff ff 	lea    -0x818(%rbp),%rax
+  400e06:	48 89 c2             	mov    %rax,%rdx
+  400e09:	48 89 cf             	mov    %rcx,%rdi
+  400e0c:	e8 0d 1a 00 00       	callq  40281e <execve>
+  400e11:	89 45 d0             	mov    %eax,-0x30(%rbp)
+				if(ret == -1)
+  400e14:	83 7d d0 ff          	cmpl   $0xffffffff,-0x30(%rbp)
+  400e18:	75 1a                	jne    400e34 <execute_cmd+0x389>
+				{
+					strerror(errno);
+  400e1a:	48 8b 05 d7 35 20 00 	mov    0x2035d7(%rip),%rax        # 6043f8 <chdir+0x201180>
+  400e21:	8b 00                	mov    (%rax),%eax
+  400e23:	89 c7                	mov    %eax,%edi
+  400e25:	e8 10 1d 00 00       	callq  402b3a <strerror>
+					exit(1);
+  400e2a:	bf 01 00 00 00       	mov    $0x1,%edi
+  400e2f:	e8 b6 1a 00 00       	callq  4028ea <exit>
+		{
+			if(pipe(pipes+i*2) == -1)
+				strerror(errno);
+		}
+		//printf("Multiple Commands");
+		for(i=0; i<=info->pipeNum;i++)
+  400e34:	ff 45 ec             	incl   -0x14(%rbp)
+  400e37:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
+  400e3e:	8b 40 50             	mov    0x50(%rax),%eax
+  400e41:	3b 45 ec             	cmp    -0x14(%rbp),%eax
+  400e44:	0f 8d 3b fe ff ff    	jge    400c85 <execute_cmd+0x1da>
+				}
+			}
+		}
+		//printf("\nin multiple's parent\n");
+
+		for(i=0;i<info->pipeNum;i++)
+  400e4a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
+  400e51:	eb 3d                	jmp    400e90 <execute_cmd+0x3e5>
+		{
+			close(pipes[i*2]);
+  400e53:	8b 45 ec             	mov    -0x14(%rbp),%eax
+  400e56:	48 98                	cltq   
+  400e58:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
+  400e5f:	00 
+  400e60:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  400e64:	48 01 d0             	add    %rdx,%rax
+  400e67:	8b 00                	mov    (%rax),%eax
+  400e69:	89 c7                	mov    %eax,%edi
+  400e6b:	e8 18 10 00 00       	callq  401e88 <close>
+			close(pipes[i*2+1]);
+  400e70:	8b 45 ec             	mov    -0x14(%rbp),%eax
+  400e73:	48 98                	cltq   
+  400e75:	48 c1 e0 03          	shl    $0x3,%rax
+  400e79:	48 8d 50 04          	lea    0x4(%rax),%rdx
+  400e7d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  400e81:	48 01 d0             	add    %rdx,%rax
+  400e84:	8b 00                	mov    (%rax),%eax
+  400e86:	89 c7                	mov    %eax,%edi
+  400e88:	e8 fb 0f 00 00       	callq  401e88 <close>
+				}
+			}
+		}
+		//printf("\nin multiple's parent\n");
+
+		for(i=0;i<info->pipeNum;i++)
+  400e8d:	ff 45 ec             	incl   -0x14(%rbp)
+  400e90:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
+  400e97:	8b 40 50             	mov    0x50(%rax),%eax
+  400e9a:	3b 45 ec             	cmp    -0x14(%rbp),%eax
+  400e9d:	7f b4                	jg     400e53 <execute_cmd+0x3a8>
+			close(pipes[i*2+1]);
+			//printf("closed");
+		}
+	}
+	//printf("\nin singles's parent\n");
+	for (i = 0; i <= info->pipeNum; i++)
+  400e9f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
+  400ea6:	eb 2c                	jmp    400ed4 <execute_cmd+0x429>
+		waitpid(proc_ids[i], &status, 0);
+  400ea8:	8b 45 ec             	mov    -0x14(%rbp),%eax
+  400eab:	48 98                	cltq   
+  400ead:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
+  400eb4:	00 
+  400eb5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  400eb9:	48 01 d0             	add    %rdx,%rax
+  400ebc:	8b 00                	mov    (%rax),%eax
+  400ebe:	48 8d 4d cc          	lea    -0x34(%rbp),%rcx
+  400ec2:	ba 00 00 00 00       	mov    $0x0,%edx
+  400ec7:	48 89 ce             	mov    %rcx,%rsi
+  400eca:	89 c7                	mov    %eax,%edi
+  400ecc:	e8 8d 10 00 00       	callq  401f5e <waitpid>
+			close(pipes[i*2+1]);
+			//printf("closed");
+		}
+	}
+	//printf("\nin singles's parent\n");
+	for (i = 0; i <= info->pipeNum; i++)
+  400ed1:	ff 45 ec             	incl   -0x14(%rbp)
+  400ed4:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
+  400edb:	8b 40 50             	mov    0x50(%rax),%eax
+  400ede:	3b 45 ec             	cmp    -0x14(%rbp),%eax
+  400ee1:	7d c5                	jge    400ea8 <execute_cmd+0x3fd>
+		waitpid(proc_ids[i], &status, 0);
+	//printf("child returned:%d\n",waitpid(proc_ids[i], &status, 0));
+
+}
+  400ee3:	48 81 c4 28 08 00 00 	add    $0x828,%rsp
+  400eea:	5b                   	pop    %rbx
+  400eeb:	5d                   	pop    %rbp
+  400eec:	c3                   	retq   
+
+0000000000400eed <find_file_in_dir>:
+
+
+
+
+char* find_file_in_dir (char *path, char *file)
+{
+  400eed:	55                   	push   %rbp
+  400eee:	48 89 e5             	mov    %rsp,%rbp
+  400ef1:	48 83 ec 30          	sub    $0x30,%rsp
+  400ef5:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
+  400ef9:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
+	struct dirent *entry=NULL;
+  400efd:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
+  400f04:	00 
+	char* ret = NULL;
+  400f05:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
+  400f0c:	00 
+	//ret=NULL;
+	void *dir;
+	dir = opendir (path);
+  400f0d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  400f11:	48 89 c7             	mov    %rax,%rdi
+  400f14:	e8 75 17 00 00       	callq  40268e <opendir>
+  400f19:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
+	if(dir == NULL)
+  400f1d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
+  400f22:	75 0a                	jne    400f2e <find_file_in_dir+0x41>
+		return (char *)NULL;
+  400f24:	b8 00 00 00 00       	mov    $0x0,%eax
+  400f29:	e9 ae 00 00 00       	jmpq   400fdc <find_file_in_dir+0xef>
+
+	errno = 0;
+  400f2e:	48 8b 05 c3 34 20 00 	mov    0x2034c3(%rip),%rax        # 6043f8 <chdir+0x201180>
+  400f35:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
+	//printf("In find_file_in_dir....searching %s\n",path);
+	while ((entry = readdir (dir)) != NULL) {
+  400f3b:	eb 3e                	jmp    400f7b <find_file_in_dir+0x8e>
+		//printf("entry->dname=%s file=%s",entry->d_name, file);
+		if (!strcmp(entry->d_name, file)) {
+  400f3d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  400f41:	48 8d 50 12          	lea    0x12(%rax),%rdx
+  400f45:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
+  400f49:	48 89 c6             	mov    %rax,%rsi
+  400f4c:	48 89 d7             	mov    %rdx,%rdi
+  400f4f:	e8 46 1a 00 00       	callq  40299a <strcmp>
+  400f54:	85 c0                	test   %eax,%eax
+  400f56:	75 23                	jne    400f7b <find_file_in_dir+0x8e>
+			ret=malloc(sizeof(strlen(path)+1));
+  400f58:	bf 04 00 00 00       	mov    $0x4,%edi
+  400f5d:	e8 24 21 00 00       	callq  403086 <malloc>
+  400f62:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+			strcpy(ret,path);
+  400f66:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
+  400f6a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  400f6e:	48 89 d6             	mov    %rdx,%rsi
+  400f71:	48 89 c7             	mov    %rax,%rdi
+  400f74:	e8 c2 19 00 00       	callq  40293b <strcpy>
+			break;
+  400f79:	eb 17                	jmp    400f92 <find_file_in_dir+0xa5>
+	if(dir == NULL)
+		return (char *)NULL;
+
+	errno = 0;
+	//printf("In find_file_in_dir....searching %s\n",path);
+	while ((entry = readdir (dir)) != NULL) {
+  400f7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  400f7f:	48 89 c7             	mov    %rax,%rdi
+  400f82:	e8 dc 0c 00 00       	callq  401c63 <readdir>
+  400f87:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
+  400f8b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
+  400f90:	75 ab                	jne    400f3d <find_file_in_dir+0x50>
+			ret=malloc(sizeof(strlen(path)+1));
+			strcpy(ret,path);
+			break;
+		}
+	}
+	if (errno && !entry){
+  400f92:	48 8b 05 5f 34 20 00 	mov    0x20345f(%rip),%rax        # 6043f8 <chdir+0x201180>
+  400f99:	8b 00                	mov    (%rax),%eax
+  400f9b:	85 c0                	test   %eax,%eax
+  400f9d:	74 17                	je     400fb6 <find_file_in_dir+0xc9>
+  400f9f:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
+  400fa4:	75 10                	jne    400fb6 <find_file_in_dir+0xc9>
+		strerror(errno);
+  400fa6:	48 8b 05 4b 34 20 00 	mov    0x20344b(%rip),%rax        # 6043f8 <chdir+0x201180>
+  400fad:	8b 00                	mov    (%rax),%eax
+  400faf:	89 c7                	mov    %eax,%edi
+  400fb1:	e8 84 1b 00 00       	callq  402b3a <strerror>
+	}
+
+	if(closedir (dir) == -1){
+  400fb6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  400fba:	48 89 c7             	mov    %rax,%rdi
+  400fbd:	e8 14 10 00 00       	callq  401fd6 <closedir>
+  400fc2:	83 f8 ff             	cmp    $0xffffffff,%eax
+  400fc5:	75 11                	jne    400fd8 <find_file_in_dir+0xeb>
+
+		printf("Fatal error. Could not close a directory\n");
+  400fc7:	48 8d 3d 92 24 00 00 	lea    0x2492(%rip),%rdi        # 403460 <chdir+0x1e8>
+  400fce:	b8 00 00 00 00       	mov    $0x0,%eax
+  400fd3:	e8 58 12 00 00       	callq  402230 <printf>
+
+	}
+
+
+	//printf("In find_file_in_dir....returning %s\n",ret);
+	return ret;
+  400fd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+}
+  400fdc:	c9                   	leaveq 
+  400fdd:	c3                   	retq   
+
+0000000000400fde <findBinaryFullPath>:
+
+
+char* findBinaryFullPath(char* srchPath,char* binaryName){
+  400fde:	55                   	push   %rbp
+  400fdf:	48 89 e5             	mov    %rsp,%rbp
+  400fe2:	48 83 ec 60          	sub    $0x60,%rsp
+  400fe6:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
+  400fea:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
+	 * Else if none of the above are there then find the full path
+	 *
+	 */
+
+	int i;
+	char* x=NULL;
+  400fee:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
+  400ff5:	00 
+	//printf("In find full binary path\n");
+
+
+	//printf("After strstr call. Search Path is :%s \n",srchPath);
+
+	Token* dirToSearch = tokenize(srchPath,":");
+  400ff6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
+  400ffa:	48 8d 35 89 24 00 00 	lea    0x2489(%rip),%rsi        # 40348a <chdir+0x212>
+  401001:	48 89 c7             	mov    %rax,%rdi
+  401004:	e8 17 0a 00 00       	callq  401a20 <tokenize>
+  401009:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
+
+	//printf("After tokenize on : Number of tokens %d\n",dirToSearch->numOfTokens);
+
+	for(i=0;i<dirToSearch->numOfTokens;i++){
+  40100d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
+  401014:	eb 5d                	jmp    401073 <findBinaryFullPath+0x95>
+
+		//printf("Calling find_file_in_dir token number %d of %d",i,dirToSearch->numOfTokens);
+		//printf("\n\npath component 1 %s\n\n",dirToSearch->tokenArr[i]);
+		strcpy(temp,dirToSearch->tokenArr[i]);
+  401016:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  40101a:	8b 55 fc             	mov    -0x4(%rbp),%edx
+  40101d:	48 63 d2             	movslq %edx,%rdx
+  401020:	48 8b 54 d0 08       	mov    0x8(%rax,%rdx,8),%rdx
+  401025:	48 8d 45 b6          	lea    -0x4a(%rbp),%rax
+  401029:	48 89 d6             	mov    %rdx,%rsi
+  40102c:	48 89 c7             	mov    %rax,%rdi
+  40102f:	e8 07 19 00 00       	callq  40293b <strcpy>
+		printf("\n\nBefore calling find_file_in_dir %s binary=%s\n",temp, binaryName	);
+  401034:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
+  401038:	48 8d 45 b6          	lea    -0x4a(%rbp),%rax
+  40103c:	48 89 c6             	mov    %rax,%rsi
+  40103f:	48 8d 3d 4a 24 00 00 	lea    0x244a(%rip),%rdi        # 403490 <chdir+0x218>
+  401046:	b8 00 00 00 00       	mov    $0x0,%eax
+  40104b:	e8 e0 11 00 00       	callq  402230 <printf>
+
+		x=find_file_in_dir(temp,binaryName);
+  401050:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
+  401054:	48 8d 45 b6          	lea    -0x4a(%rbp),%rax
+  401058:	48 89 d6             	mov    %rdx,%rsi
+  40105b:	48 89 c7             	mov    %rax,%rdi
+  40105e:	e8 8a fe ff ff       	callq  400eed <find_file_in_dir>
+  401063:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
+
+		if(x!=NULL){
+  401067:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
+  40106c:	74 02                	je     401070 <findBinaryFullPath+0x92>
+
+			break;
+  40106e:	eb 0e                	jmp    40107e <findBinaryFullPath+0xa0>
+
+	Token* dirToSearch = tokenize(srchPath,":");
+
+	//printf("After tokenize on : Number of tokens %d\n",dirToSearch->numOfTokens);
+
+	for(i=0;i<dirToSearch->numOfTokens;i++){
+  401070:	ff 45 fc             	incl   -0x4(%rbp)
+  401073:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401077:	8b 00                	mov    (%rax),%eax
+  401079:	3b 45 fc             	cmp    -0x4(%rbp),%eax
+  40107c:	7f 98                	jg     401016 <findBinaryFullPath+0x38>
+
+		}
+	}
+
+
+	return x;
+  40107e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+
+
+}
+  401082:	c9                   	leaveq 
+  401083:	c3                   	retq   
+
+0000000000401084 <findEnvVar>:
+#include <parser.h>
+#include <errno.h>
+#include <string.h>
+#include <shell.h>
+
+char** findEnvVar(char* envVar, char* envp[]){
+  401084:	55                   	push   %rbp
+  401085:	48 89 e5             	mov    %rsp,%rbp
+  401088:	48 83 ec 20          	sub    $0x20,%rsp
+  40108c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  401090:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+	 * envVar in the evnp[]. It returns a pointer, which is a pointer to the array
+	 * envp[] that contains a the pointer to the envVar string.
+	 * If not found returns null.
+	 */
+
+	int count=0;
+  401094:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
+	Token* tokens;
+
+	//printf("Inside findEnv var\n");
+    
+	while(envp[count]!= NULL){
+  40109b:	eb 6a                	jmp    401107 <findEnvVar+0x83>
+
+		tokens = tokenize(envp[count],"=");
+  40109d:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  4010a0:	48 98                	cltq   
+  4010a2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
+  4010a9:	00 
+  4010aa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  4010ae:	48 01 d0             	add    %rdx,%rax
+  4010b1:	48 8b 00             	mov    (%rax),%rax
+  4010b4:	48 8d 35 05 24 00 00 	lea    0x2405(%rip),%rsi        # 4034c0 <chdir+0x248>
+  4010bb:	48 89 c7             	mov    %rax,%rdi
+  4010be:	e8 5d 09 00 00       	callq  401a20 <tokenize>
+  4010c3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
+
+		//printf("%s\n",envp[count]);
+
+		if(strcmp(tokens->tokenArr[0],envVar)==0){
+  4010c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  4010cb:	48 8b 40 08          	mov    0x8(%rax),%rax
+  4010cf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
+  4010d3:	48 89 d6             	mov    %rdx,%rsi
+  4010d6:	48 89 c7             	mov    %rax,%rdi
+  4010d9:	e8 bc 18 00 00       	callq  40299a <strcmp>
+  4010de:	85 c0                	test   %eax,%eax
+  4010e0:	75 16                	jne    4010f8 <findEnvVar+0x74>
+			return(envp+count);
+  4010e2:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  4010e5:	48 98                	cltq   
+  4010e7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
+  4010ee:	00 
+  4010ef:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  4010f3:	48 01 d0             	add    %rdx,%rax
+  4010f6:	eb 34                	jmp    40112c <findEnvVar+0xa8>
+		}
+		free(tokens);
+  4010f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  4010fc:	48 89 c7             	mov    %rax,%rdi
+  4010ff:	e8 e1 20 00 00       	callq  4031e5 <free>
+		count++;
+  401104:	ff 45 fc             	incl   -0x4(%rbp)
+	int count=0;
+	Token* tokens;
+
+	//printf("Inside findEnv var\n");
+    
+	while(envp[count]!= NULL){
+  401107:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  40110a:	48 98                	cltq   
+  40110c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
+  401113:	00 
+  401114:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  401118:	48 01 d0             	add    %rdx,%rax
+  40111b:	48 8b 00             	mov    (%rax),%rax
+  40111e:	48 85 c0             	test   %rax,%rax
+  401121:	0f 85 76 ff ff ff    	jne    40109d <findEnvVar+0x19>
+			return(envp+count);
+		}
+		free(tokens);
+		count++;
+	}
+	return (char**)NULL;
+  401127:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  40112c:	c9                   	leaveq 
+  40112d:	c3                   	retq   
+
+000000000040112e <main1>:
+#include <stdio.h>
+
+int main1(int argc, char* argv[], char* envp[]) {
+  40112e:	55                   	push   %rbp
+  40112f:	48 89 e5             	mov    %rsp,%rbp
+  401132:	48 83 ec 20          	sub    $0x20,%rsp
+  401136:	89 7d fc             	mov    %edi,-0x4(%rbp)
+  401139:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
+  40113d:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
+	printf("Hello World!\n");
+  401141:	48 8d 3d 7a 23 00 00 	lea    0x237a(%rip),%rdi        # 4034c2 <chdir+0x24a>
+  401148:	b8 00 00 00 00       	mov    $0x0,%eax
+  40114d:	e8 de 10 00 00       	callq  402230 <printf>
+	return 0;
+  401152:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  401157:	c9                   	leaveq 
+  401158:	c3                   	retq   
+
+0000000000401159 <print_info>:
+#include <shell.h>
+
+
+
+
+void print_info (parseInfo *info) {
+  401159:	55                   	push   %rbp
+  40115a:	48 89 e5             	mov    %rsp,%rbp
+  40115d:	48 83 ec 20          	sub    $0x20,%rsp
+  401161:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+	printf("print_info: printing info about parseInfo struct\n");
+  401165:	48 8d 3d 64 23 00 00 	lea    0x2364(%rip),%rdi        # 4034d0 <chdir+0x258>
+  40116c:	b8 00 00 00 00       	mov    $0x0,%eax
+  401171:	e8 ba 10 00 00       	callq  402230 <printf>
+	//printf("Number of pipe separated commands %d\n",info->pipeNum);
+
+
+	int i,j;
+
+	for(i=0;i<=info->pipeNum;i++){
+  401176:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
+  40117d:	eb 25                	jmp    4011a4 <print_info+0x4b>
+		//printf("Command Name : %s\n",info->CommArray[i]->commandName);
+
+		//printf("Command Arguments :\n");
+		//printf("Number of arguments %d\n",info->CommArray[i]->VarNum);
+
+		for(j=0;j<info->CommArray[i]->VarNum;j++){
+  40117f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
+  401186:	eb 03                	jmp    40118b <print_info+0x32>
+  401188:	ff 45 f8             	incl   -0x8(%rbp)
+  40118b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  40118f:	8b 55 fc             	mov    -0x4(%rbp),%edx
+  401192:	48 63 d2             	movslq %edx,%rdx
+  401195:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
+  401199:	8b 40 58             	mov    0x58(%rax),%eax
+  40119c:	3b 45 f8             	cmp    -0x8(%rbp),%eax
+  40119f:	7f e7                	jg     401188 <print_info+0x2f>
+	//printf("Number of pipe separated commands %d\n",info->pipeNum);
+
+
+	int i,j;
+
+	for(i=0;i<=info->pipeNum;i++){
+  4011a1:	ff 45 fc             	incl   -0x4(%rbp)
+  4011a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  4011a8:	8b 40 50             	mov    0x50(%rax),%eax
+  4011ab:	3b 45 fc             	cmp    -0x4(%rbp),%eax
+  4011ae:	7d cf                	jge    40117f <print_info+0x26>
+			//printf("Argument %d : %s \n", j,info->CommArray[i]->VarList[j]);
+		}
+
+	}
+
+	return;
+  4011b0:	90                   	nop
+}
+  4011b1:	c9                   	leaveq 
+  4011b2:	c3                   	retq   
+
+00000000004011b3 <free_info>:
+
+void free_info (parseInfo *info) {
+  4011b3:	55                   	push   %rbp
+  4011b4:	48 89 e5             	mov    %rsp,%rbp
+  4011b7:	48 83 ec 10          	sub    $0x10,%rsp
+  4011bb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
+	//printf("free_info: freeing memory associated to parseInfo struct\n");
+	free(info);
+  4011bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  4011c3:	48 89 c7             	mov    %rax,%rdi
+  4011c6:	e8 1a 20 00 00       	callq  4031e5 <free>
+}
+  4011cb:	c9                   	leaveq 
+  4011cc:	c3                   	retq   
+
+00000000004011cd <parseModified>:
+
+parseInfo* parseModified(char *cmd,char* envp[]){
+  4011cd:	55                   	push   %rbp
+  4011ce:	48 89 e5             	mov    %rsp,%rbp
+  4011d1:	48 81 ec 40 02 00 00 	sub    $0x240,%rsp
+  4011d8:	48 89 bd c8 fd ff ff 	mov    %rdi,-0x238(%rbp)
+  4011df:	48 89 b5 c0 fd ff ff 	mov    %rsi,-0x240(%rbp)
+
+	parseInfo *Result;
+	Token* tokenPipe;
+	Token* tokenSpace;
+	//Token* path;
+	singleCommand* sc = NULL;
+  4011e6:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
+  4011ed:	00 
+//	char** envVar=NULL;
+	char *fullPath=NULL;
+  4011ee:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
+  4011f5:	00 
+	int i=0,j=0;
+  4011f6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
+  4011fd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
+	char srchPath[500];
+	//printf("In PARSE MODIFIED");
+	Result = (parseInfo*)malloc(sizeof(parseInfo));
+  401204:	bf 58 00 00 00       	mov    $0x58,%edi
+  401209:	e8 78 1e 00 00       	callq  403086 <malloc>
+  40120e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
+
+//	envVar=findEnvVar("PATH",envp);
+    //envVar[0]="PATH=/bin";
+	printf("In parser... full PATH= %s\n\n",cmd);
+  401212:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
+  401219:	48 89 c6             	mov    %rax,%rsi
+  40121c:	48 8d 3d df 22 00 00 	lea    0x22df(%rip),%rdi        # 403502 <chdir+0x28a>
+  401223:	b8 00 00 00 00       	mov    $0x0,%eax
+  401228:	e8 03 10 00 00       	callq  402230 <printf>
+//		printf("PATH is ---> %s",path->tokenArr[1]);
+
+    
+
+	//strcpy(srchPath,path->tokenArr[1]);
+	strcpy(srchPath,"/bin");
+  40122d:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
+  401234:	48 8d 35 e4 22 00 00 	lea    0x22e4(%rip),%rsi        # 40351f <chdir+0x2a7>
+  40123b:	48 89 c7             	mov    %rax,%rdi
+  40123e:	e8 f8 16 00 00       	callq  40293b <strcpy>
+
+	printf("Seatch PAth is %s",srchPath);
+  401243:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
+  40124a:	48 89 c6             	mov    %rax,%rsi
+  40124d:	48 8d 3d d0 22 00 00 	lea    0x22d0(%rip),%rdi        # 403524 <chdir+0x2ac>
+  401254:	b8 00 00 00 00       	mov    $0x0,%eax
+  401259:	e8 d2 0f 00 00       	callq  402230 <printf>
+
+	tokenPipe = tokenize(cmd,"|");
+  40125e:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
+  401265:	48 8d 35 ca 22 00 00 	lea    0x22ca(%rip),%rsi        # 403536 <chdir+0x2be>
+  40126c:	48 89 c7             	mov    %rax,%rdi
+  40126f:	e8 ac 07 00 00       	callq  401a20 <tokenize>
+  401274:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
+
+	printf("In PARSE MODIFIED%d\n",tokenPipe->numOfTokens);
+  401278:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  40127c:	8b 00                	mov    (%rax),%eax
+  40127e:	89 c6                	mov    %eax,%esi
+  401280:	48 8d 3d b1 22 00 00 	lea    0x22b1(%rip),%rdi        # 403538 <chdir+0x2c0>
+  401287:	b8 00 00 00 00       	mov    $0x0,%eax
+  40128c:	e8 9f 0f 00 00       	callq  402230 <printf>
+	for(i=0;i<tokenPipe->numOfTokens;i++){
+  401291:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
+  401298:	e9 14 02 00 00       	jmpq   4014b1 <parseModified+0x2e4>
+
+		//for each pipe separated token find space separated tokens
+		tokenSpace=tokenize(tokenPipe->tokenArr[i]," ");
+  40129d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  4012a1:	8b 55 fc             	mov    -0x4(%rbp),%edx
+  4012a4:	48 63 d2             	movslq %edx,%rdx
+  4012a7:	48 8b 44 d0 08       	mov    0x8(%rax,%rdx,8),%rax
+  4012ac:	48 8d 35 9a 22 00 00 	lea    0x229a(%rip),%rsi        # 40354d <chdir+0x2d5>
+  4012b3:	48 89 c7             	mov    %rax,%rdi
+  4012b6:	e8 65 07 00 00       	callq  401a20 <tokenize>
+  4012bb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
+
+		//initialize the singleCommand Structure
+		sc = (singleCommand*)malloc(sizeof(singleCommand));
+  4012bf:	bf 60 00 00 00       	mov    $0x60,%edi
+  4012c4:	e8 bd 1d 00 00       	callq  403086 <malloc>
+  4012c9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
+		sc->commandName=(char*)malloc(100);
+  4012cd:	bf 64 00 00 00       	mov    $0x64,%edi
+  4012d2:	e8 af 1d 00 00       	callq  403086 <malloc>
+  4012d7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
+  4012db:	48 89 02             	mov    %rax,(%rdx)
+		sc->commandName[0]='\0';
+  4012de:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  4012e2:	48 8b 00             	mov    (%rax),%rax
+  4012e5:	c6 00 00             	movb   $0x0,(%rax)
+		printf("Before find full binary path\n\n\n");
+  4012e8:	48 8d 3d 61 22 00 00 	lea    0x2261(%rip),%rdi        # 403550 <chdir+0x2d8>
+  4012ef:	b8 00 00 00 00       	mov    $0x0,%eax
+  4012f4:	e8 37 0f 00 00       	callq  402230 <printf>
+		sc->commandName=tokenSpace->tokenArr[0];
+  4012f9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
+  4012fd:	48 8b 50 08          	mov    0x8(%rax),%rdx
+  401301:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  401305:	48 89 10             	mov    %rdx,(%rax)
+		if(strcmp(tokenSpace->tokenArr[0],"set") && strcmp(tokenSpace->tokenArr[0],"cd") && strcmp(tokenSpace->tokenArr[0],"exit") )
+  401308:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
+  40130c:	48 8b 40 08          	mov    0x8(%rax),%rax
+  401310:	48 8d 35 59 22 00 00 	lea    0x2259(%rip),%rsi        # 403570 <chdir+0x2f8>
+  401317:	48 89 c7             	mov    %rax,%rdi
+  40131a:	e8 7b 16 00 00       	callq  40299a <strcmp>
+  40131f:	85 c0                	test   %eax,%eax
+  401321:	0f 84 05 01 00 00    	je     40142c <parseModified+0x25f>
+  401327:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
+  40132b:	48 8b 40 08          	mov    0x8(%rax),%rax
+  40132f:	48 8d 35 3e 22 00 00 	lea    0x223e(%rip),%rsi        # 403574 <chdir+0x2fc>
+  401336:	48 89 c7             	mov    %rax,%rdi
+  401339:	e8 5c 16 00 00       	callq  40299a <strcmp>
+  40133e:	85 c0                	test   %eax,%eax
+  401340:	0f 84 e6 00 00 00    	je     40142c <parseModified+0x25f>
+  401346:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
+  40134a:	48 8b 40 08          	mov    0x8(%rax),%rax
+  40134e:	48 8d 35 22 22 00 00 	lea    0x2222(%rip),%rsi        # 403577 <chdir+0x2ff>
+  401355:	48 89 c7             	mov    %rax,%rdi
+  401358:	e8 3d 16 00 00       	callq  40299a <strcmp>
+  40135d:	85 c0                	test   %eax,%eax
+  40135f:	0f 84 c7 00 00 00    	je     40142c <parseModified+0x25f>
+		{
+			printf("Loop %d cmd: %s\n\n",i,tokenSpace->tokenArr[0] );
+  401365:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
+  401369:	48 8b 50 08          	mov    0x8(%rax),%rdx
+  40136d:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  401370:	89 c6                	mov    %eax,%esi
+  401372:	48 8d 3d 03 22 00 00 	lea    0x2203(%rip),%rdi        # 40357c <chdir+0x304>
+  401379:	b8 00 00 00 00       	mov    $0x0,%eax
+  40137e:	e8 ad 0e 00 00       	callq  402230 <printf>
+
+			if(strstr(tokenSpace->tokenArr[0],"/")==NULL){
+  401383:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
+  401387:	48 8b 40 08          	mov    0x8(%rax),%rax
+  40138b:	48 8d 35 fc 21 00 00 	lea    0x21fc(%rip),%rsi        # 40358e <chdir+0x316>
+  401392:	48 89 c7             	mov    %rax,%rdi
+  401395:	e8 87 16 00 00       	callq  402a21 <strstr>
+  40139a:	48 85 c0             	test   %rax,%rax
+  40139d:	0f 85 89 00 00 00    	jne    40142c <parseModified+0x25f>
+
+				fullPath=findBinaryFullPath(srchPath,tokenSpace->tokenArr[0]);
+  4013a3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
+  4013a7:	48 8b 50 08          	mov    0x8(%rax),%rdx
+  4013ab:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
+  4013b2:	48 89 d6             	mov    %rdx,%rsi
+  4013b5:	48 89 c7             	mov    %rax,%rdi
+  4013b8:	e8 21 fc ff ff       	callq  400fde <findBinaryFullPath>
+  4013bd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
+				if(fullPath==NULL)
+  4013c1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
+  4013c6:	75 1b                	jne    4013e3 <parseModified+0x216>
+				{
+					printf("Error:Command Not found.\n");
+  4013c8:	48 8d 3d c1 21 00 00 	lea    0x21c1(%rip),%rdi        # 403590 <chdir+0x318>
+  4013cf:	b8 00 00 00 00       	mov    $0x0,%eax
+  4013d4:	e8 57 0e 00 00       	callq  402230 <printf>
+					return NULL;
+  4013d9:	b8 00 00 00 00       	mov    $0x0,%eax
+  4013de:	e9 f1 00 00 00       	jmpq   4014d4 <parseModified+0x307>
+				}
+				sc->commandName = fullPath;
+  4013e3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  4013e7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
+  4013eb:	48 89 10             	mov    %rdx,(%rax)
+				sc->commandName = strcat(sc->commandName,"/");
+  4013ee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  4013f2:	48 8b 00             	mov    (%rax),%rax
+  4013f5:	48 8d 35 92 21 00 00 	lea    0x2192(%rip),%rsi        # 40358e <chdir+0x316>
+  4013fc:	48 89 c7             	mov    %rax,%rdi
+  4013ff:	e8 fb 16 00 00       	callq  402aff <strcat>
+  401404:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
+  401408:	48 89 02             	mov    %rax,(%rdx)
+				sc->commandName = strcat(sc->commandName,tokenSpace->tokenArr[0]);
+  40140b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
+  40140f:	48 8b 50 08          	mov    0x8(%rax),%rdx
+  401413:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  401417:	48 8b 00             	mov    (%rax),%rax
+  40141a:	48 89 d6             	mov    %rdx,%rsi
+  40141d:	48 89 c7             	mov    %rax,%rdi
+  401420:	e8 da 16 00 00       	callq  402aff <strcat>
+  401425:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
+  401429:	48 89 02             	mov    %rax,(%rdx)
+		}
+
+		//printf("In parser..fullpath for %s is %s\n",tokenSpace->tokenArr[0],fullPath);
+
+
+		printf("COMMAND NAME=%s\n",sc->commandName);
+  40142c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  401430:	48 8b 00             	mov    (%rax),%rax
+  401433:	48 89 c6             	mov    %rax,%rsi
+  401436:	48 8d 3d 6d 21 00 00 	lea    0x216d(%rip),%rdi        # 4035aa <chdir+0x332>
+  40143d:	b8 00 00 00 00       	mov    $0x0,%eax
+  401442:	e8 e9 0d 00 00       	callq  402230 <printf>
+		//sc->VarList[0]=fullPath;
+		sc->VarNum = tokenSpace->numOfTokens;
+  401447:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
+  40144b:	8b 10                	mov    (%rax),%edx
+  40144d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  401451:	89 50 58             	mov    %edx,0x58(%rax)
+		for(j=0;j<tokenSpace->numOfTokens;j++){
+  401454:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
+  40145b:	eb 21                	jmp    40147e <parseModified+0x2b1>
+			sc->VarList[j]=tokenSpace->tokenArr[j];
+  40145d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
+  401461:	8b 55 f8             	mov    -0x8(%rbp),%edx
+  401464:	48 63 d2             	movslq %edx,%rdx
+  401467:	48 8b 4c d0 08       	mov    0x8(%rax,%rdx,8),%rcx
+  40146c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  401470:	8b 55 f8             	mov    -0x8(%rbp),%edx
+  401473:	48 63 d2             	movslq %edx,%rdx
+  401476:	48 89 4c d0 08       	mov    %rcx,0x8(%rax,%rdx,8)
+
+
+		printf("COMMAND NAME=%s\n",sc->commandName);
+		//sc->VarList[0]=fullPath;
+		sc->VarNum = tokenSpace->numOfTokens;
+		for(j=0;j<tokenSpace->numOfTokens;j++){
+  40147b:	ff 45 f8             	incl   -0x8(%rbp)
+  40147e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
+  401482:	8b 00                	mov    (%rax),%eax
+  401484:	3b 45 f8             	cmp    -0x8(%rbp),%eax
+  401487:	7f d4                	jg     40145d <parseModified+0x290>
+			sc->VarList[j]=tokenSpace->tokenArr[j];
+		}
+		sc->VarList[j]=NULL;
+  401489:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  40148d:	8b 55 f8             	mov    -0x8(%rbp),%edx
+  401490:	48 63 d2             	movslq %edx,%rdx
+  401493:	48 c7 44 d0 08 00 00 	movq   $0x0,0x8(%rax,%rdx,8)
+  40149a:	00 00 
+
+		Result->CommArray[i]=sc;
+  40149c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  4014a0:	8b 55 fc             	mov    -0x4(%rbp),%edx
+  4014a3:	48 63 d2             	movslq %edx,%rdx
+  4014a6:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
+  4014aa:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
+	printf("Seatch PAth is %s",srchPath);
+
+	tokenPipe = tokenize(cmd,"|");
+
+	printf("In PARSE MODIFIED%d\n",tokenPipe->numOfTokens);
+	for(i=0;i<tokenPipe->numOfTokens;i++){
+  4014ae:	ff 45 fc             	incl   -0x4(%rbp)
+  4014b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  4014b5:	8b 00                	mov    (%rax),%eax
+  4014b7:	3b 45 fc             	cmp    -0x4(%rbp),%eax
+  4014ba:	0f 8f dd fd ff ff    	jg     40129d <parseModified+0xd0>
+
+		Result->CommArray[i]=sc;
+
+	}
+
+	Result->pipeNum=tokenPipe->numOfTokens-1; //set the number of pipe separated commands
+  4014c0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  4014c4:	8b 00                	mov    (%rax),%eax
+  4014c6:	8d 50 ff             	lea    -0x1(%rax),%edx
+  4014c9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  4014cd:	89 50 50             	mov    %edx,0x50(%rax)
+
+	return Result;
+  4014d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+}
+  4014d4:	c9                   	leaveq 
+  4014d5:	c3                   	retq   
+
+00000000004014d6 <read_line>:
+
+int read_line(int fd, char* buf)
+{
+  4014d6:	55                   	push   %rbp
+  4014d7:	48 89 e5             	mov    %rsp,%rbp
+  4014da:	48 83 ec 10          	sub    $0x10,%rsp
+  4014de:	89 7d fc             	mov    %edi,-0x4(%rbp)
+  4014e1:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
+		//printf("read: %c ",*byte);
+		if (ret == -1)
+			return -1;
+	}
+	*(byte-1)='\0';*/
+    read(0,buf,MAXLINE);
+  4014e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  4014e9:	ba 00 01 00 00       	mov    $0x100,%edx
+  4014ee:	48 89 c6             	mov    %rax,%rsi
+  4014f1:	bf 00 00 00 00       	mov    $0x0,%edi
+  4014f6:	e8 1f 12 00 00       	callq  40271a <read>
+	return 1;
+  4014fb:	b8 01 00 00 00       	mov    $0x1,%eax
+}
+  401500:	c9                   	leaveq 
+  401501:	c3                   	retq   
+
+0000000000401502 <changePS1>:
+#include <parser.h>
+#include <errno.h>
+#include <string.h>
+#include <shell.h>
+
+void changePS1(char*str){
+  401502:	55                   	push   %rbp
+  401503:	48 89 e5             	mov    %rsp,%rbp
+  401506:	48 83 ec 20          	sub    $0x20,%rsp
+  40150a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+	 * The PS1 is a shell variable
+	 *
+	 */
+
+	Token* tokenEqulas;
+	tokenEqulas = tokenize(str,"=");
+  40150e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401512:	48 8d 35 a7 20 00 00 	lea    0x20a7(%rip),%rsi        # 4035c0 <chdir+0x348>
+  401519:	48 89 c7             	mov    %rax,%rdi
+  40151c:	e8 ff 04 00 00       	callq  401a20 <tokenize>
+  401521:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+	//printf("no:%d\n\n",tokenEqulas->numOfTokens);
+
+	if(tokenEqulas->numOfTokens < 2)
+  401525:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  401529:	8b 00                	mov    (%rax),%eax
+  40152b:	83 f8 01             	cmp    $0x1,%eax
+  40152e:	7f 13                	jg     401543 <changePS1+0x41>
+	{
+		printf("Error:Invalid PS1\n");
+  401530:	48 8d 3d 8b 20 00 00 	lea    0x208b(%rip),%rdi        # 4035c2 <chdir+0x34a>
+  401537:	b8 00 00 00 00       	mov    $0x0,%eax
+  40153c:	e8 ef 0c 00 00       	callq  402230 <printf>
+  401541:	eb 5d                	jmp    4015a0 <changePS1+0x9e>
+	}
+	else if(strlen(tokenEqulas->tokenArr[1])>100){
+  401543:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  401547:	48 8b 40 10          	mov    0x10(%rax),%rax
+  40154b:	48 89 c7             	mov    %rax,%rdi
+  40154e:	e8 b3 13 00 00       	callq  402906 <strlen>
+  401553:	83 f8 64             	cmp    $0x64,%eax
+  401556:	7e 13                	jle    40156b <changePS1+0x69>
+		printf("Too long a prompt name.Pleasee try again\n");
+  401558:	48 8d 3d 79 20 00 00 	lea    0x2079(%rip),%rdi        # 4035d8 <chdir+0x360>
+  40155f:	b8 00 00 00 00       	mov    $0x0,%eax
+  401564:	e8 c7 0c 00 00       	callq  402230 <printf>
+  401569:	eb 35                	jmp    4015a0 <changePS1+0x9e>
+	}
+
+
+	else{
+
+		strcpy(PS1,tokenEqulas->tokenArr[1]);
+  40156b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  40156f:	48 8b 40 10          	mov    0x10(%rax),%rax
+  401573:	48 89 c6             	mov    %rax,%rsi
+  401576:	48 8d 05 c3 2e 20 00 	lea    0x202ec3(%rip),%rax        # 604440 <PS1>
+  40157d:	48 89 c7             	mov    %rax,%rdi
+  401580:	e8 b6 13 00 00       	callq  40293b <strcpy>
+		printf("PS1 after change %s\n",PS1);
+  401585:	48 8d 05 b4 2e 20 00 	lea    0x202eb4(%rip),%rax        # 604440 <PS1>
+  40158c:	48 89 c6             	mov    %rax,%rsi
+  40158f:	48 8d 3d 6c 20 00 00 	lea    0x206c(%rip),%rdi        # 403602 <chdir+0x38a>
+  401596:	b8 00 00 00 00       	mov    $0x0,%eax
+  40159b:	e8 90 0c 00 00       	callq  402230 <printf>
+	}
+
+}
+  4015a0:	c9                   	leaveq 
+  4015a1:	c3                   	retq   
+
+00000000004015a2 <removeSpaces>:
+#include<stdio.h>
+#include<string.h>
+#include<stdlib.h>
+
+
+char* removeSpaces(char*str){
+  4015a2:	55                   	push   %rbp
+  4015a3:	48 89 e5             	mov    %rsp,%rbp
+  4015a6:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
+  4015ad:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
+	/*
+	 * This function removes spaces from str without modifying it
+	 * The string returned must be malloced
+	 */
+
+	int i=0,j=0;
+  4015b4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
+  4015bb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
+	char *noSpaceStr=NULL;
+  4015c2:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
+  4015c9:	00 
+	char temp[100];
+
+
+	for(i=0;i<strlen(str);i++){
+  4015ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
+  4015d1:	eb 3c                	jmp    40160f <removeSpaces+0x6d>
+
+		if(str[i]!=' '){
+  4015d3:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  4015d6:	48 63 d0             	movslq %eax,%rdx
+  4015d9:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
+  4015e0:	48 01 d0             	add    %rdx,%rax
+  4015e3:	0f b6 00             	movzbl (%rax),%eax
+  4015e6:	3c 20                	cmp    $0x20,%al
+  4015e8:	74 22                	je     40160c <removeSpaces+0x6a>
+			temp[j++]=str[i];
+  4015ea:	8b 45 f8             	mov    -0x8(%rbp),%eax
+  4015ed:	8d 50 01             	lea    0x1(%rax),%edx
+  4015f0:	89 55 f8             	mov    %edx,-0x8(%rbp)
+  4015f3:	8b 55 fc             	mov    -0x4(%rbp),%edx
+  4015f6:	48 63 ca             	movslq %edx,%rcx
+  4015f9:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
+  401600:	48 01 ca             	add    %rcx,%rdx
+  401603:	0f b6 12             	movzbl (%rdx),%edx
+  401606:	48 98                	cltq   
+  401608:	88 54 05 8c          	mov    %dl,-0x74(%rbp,%rax,1)
+	int i=0,j=0;
+	char *noSpaceStr=NULL;
+	char temp[100];
+
+
+	for(i=0;i<strlen(str);i++){
+  40160c:	ff 45 fc             	incl   -0x4(%rbp)
+  40160f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
+  401616:	48 89 c7             	mov    %rax,%rdi
+  401619:	e8 e8 12 00 00       	callq  402906 <strlen>
+  40161e:	3b 45 fc             	cmp    -0x4(%rbp),%eax
+  401621:	7f b0                	jg     4015d3 <removeSpaces+0x31>
+		if(str[i]!=' '){
+			temp[j++]=str[i];
+		}
+
+	}
+	temp[j]='\0';
+  401623:	8b 45 f8             	mov    -0x8(%rbp),%eax
+  401626:	48 98                	cltq   
+  401628:	c6 44 05 8c 00       	movb   $0x0,-0x74(%rbp,%rax,1)
+
+	noSpaceStr = malloc(sizeof(char)*(strlen(temp)));
+  40162d:	48 8d 45 8c          	lea    -0x74(%rbp),%rax
+  401631:	48 89 c7             	mov    %rax,%rdi
+  401634:	e8 cd 12 00 00       	callq  402906 <strlen>
+  401639:	48 98                	cltq   
+  40163b:	48 89 c7             	mov    %rax,%rdi
+  40163e:	e8 43 1a 00 00       	callq  403086 <malloc>
+  401643:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
+	strcpy(noSpaceStr,temp);
+  401647:	48 8d 55 8c          	lea    -0x74(%rbp),%rdx
+  40164b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  40164f:	48 89 d6             	mov    %rdx,%rsi
+  401652:	48 89 c7             	mov    %rax,%rdi
+  401655:	e8 e1 12 00 00       	callq  40293b <strcpy>
+
+	return noSpaceStr;
+  40165a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+
+}
+  40165e:	c9                   	leaveq 
+  40165f:	c3                   	retq   
+
+0000000000401660 <main>:
+
+
+char PS1[200]="SBUSH";
+
+int main (int argc, char *argv[], char* envp[])
+{
+  401660:	55                   	push   %rbp
+  401661:	48 89 e5             	mov    %rsp,%rbp
+  401664:	48 81 ec 50 01 00 00 	sub    $0x150,%rsp
+  40166b:	89 bd cc fe ff ff    	mov    %edi,-0x134(%rbp)
+  401671:	48 89 b5 c0 fe ff ff 	mov    %rsi,-0x140(%rbp)
+  401678:	48 89 95 b8 fe ff ff 	mov    %rdx,-0x148(%rbp)
+
+
+	char cmdLine[MAXLINE];
+
+
+	int fd=0,ret;
+  40167f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
+	//char x[10] ="akshay";
+	parseInfo *info; //info stores all the information returned by parser.
+	//printf("Akshay Kale %s, \n",x);
+	//exit(0);
+
+	if(argv[1]!=NULL)
+  401686:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
+  40168d:	48 83 c0 08          	add    $0x8,%rax
+  401691:	48 8b 00             	mov    (%rax),%rax
+  401694:	48 85 c0             	test   %rax,%rax
+  401697:	74 1e                	je     4016b7 <main+0x57>
+	{
+		//printf("executing script");
+		fd=open(argv[1],0);
+  401699:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
+  4016a0:	48 83 c0 08          	add    $0x8,%rax
+  4016a4:	48 8b 00             	mov    (%rax),%rax
+  4016a7:	be 00 00 00 00       	mov    $0x0,%esi
+  4016ac:	48 89 c7             	mov    %rax,%rdi
+  4016af:	e8 eb 06 00 00       	callq  401d9f <open>
+  4016b4:	89 45 fc             	mov    %eax,-0x4(%rbp)
+
+	while(1)
+	{
+		//cmdLine = "Santosh 1 2 3 | ls -l";
+
+		if(argv[1] == NULL)
+  4016b7:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
+  4016be:	48 83 c0 08          	add    $0x8,%rax
+  4016c2:	48 8b 00             	mov    (%rax),%rax
+  4016c5:	48 85 c0             	test   %rax,%rax
+  4016c8:	75 1d                	jne    4016e7 <main+0x87>
+		{
+			printf("%s> ",PS1);
+  4016ca:	48 8d 05 6f 2d 20 00 	lea    0x202d6f(%rip),%rax        # 604440 <PS1>
+  4016d1:	48 89 c6             	mov    %rax,%rsi
+  4016d4:	48 8d 3d 3c 1f 00 00 	lea    0x1f3c(%rip),%rdi        # 403617 <chdir+0x39f>
+  4016db:	b8 00 00 00 00       	mov    $0x0,%eax
+  4016e0:	e8 4b 0b 00 00       	callq  402230 <printf>
+  4016e5:	eb 46                	jmp    40172d <main+0xcd>
+			//read_line(0,cmdLine);
+		}
+		else
+		{
+			//printf("here");
+			ret=read_line(fd, cmdLine);
+  4016e7:	48 8d 95 f0 fe ff ff 	lea    -0x110(%rbp),%rdx
+  4016ee:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  4016f1:	48 89 d6             	mov    %rdx,%rsi
+  4016f4:	89 c7                	mov    %eax,%edi
+  4016f6:	e8 db fd ff ff       	callq  4014d6 <read_line>
+  4016fb:	89 45 f8             	mov    %eax,-0x8(%rbp)
+			while (cmdLine[0] == '#')
+  4016fe:	eb 17                	jmp    401717 <main+0xb7>
+				ret=read_line(fd,cmdLine);
+  401700:	48 8d 95 f0 fe ff ff 	lea    -0x110(%rbp),%rdx
+  401707:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  40170a:	48 89 d6             	mov    %rdx,%rsi
+  40170d:	89 c7                	mov    %eax,%edi
+  40170f:	e8 c2 fd ff ff       	callq  4014d6 <read_line>
+  401714:	89 45 f8             	mov    %eax,-0x8(%rbp)
+		}
+		else
+		{
+			//printf("here");
+			ret=read_line(fd, cmdLine);
+			while (cmdLine[0] == '#')
+  401717:	0f b6 85 f0 fe ff ff 	movzbl -0x110(%rbp),%eax
+  40171e:	3c 23                	cmp    $0x23,%al
+  401720:	74 de                	je     401700 <main+0xa0>
+				ret=read_line(fd,cmdLine);
+			if(ret == -1)
+  401722:	83 7d f8 ff          	cmpl   $0xffffffff,-0x8(%rbp)
+  401726:	75 05                	jne    40172d <main+0xcd>
+				break;
+  401728:	e9 72 01 00 00       	jmpq   40189f <main+0x23f>
+		}
+    strcpy(cmdLine,"malluaunty");
+  40172d:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
+  401734:	48 8d 35 e1 1e 00 00 	lea    0x1ee1(%rip),%rsi        # 40361c <chdir+0x3a4>
+  40173b:	48 89 c7             	mov    %rax,%rdi
+  40173e:	e8 f8 11 00 00       	callq  40293b <strcpy>
+        printf("entered: %s",cmdLine);
+  401743:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
+  40174a:	48 89 c6             	mov    %rax,%rsi
+  40174d:	48 8d 3d d3 1e 00 00 	lea    0x1ed3(%rip),%rdi        # 403627 <chdir+0x3af>
+  401754:	b8 00 00 00 00       	mov    $0x0,%eax
+  401759:	e8 d2 0a 00 00       	callq  402230 <printf>
+		if (cmdLine == NULL) {
+			printf("Unable to read last command\n");
+			continue;
+		}
+
+		if(!(*cmdLine)){
+  40175e:	0f b6 85 f0 fe ff ff 	movzbl -0x110(%rbp),%eax
+  401765:	84 c0                	test   %al,%al
+  401767:	75 05                	jne    40176e <main+0x10e>
+			//printf("No command entered\n");
+			continue;
+  401769:	e9 2c 01 00 00       	jmpq   40189a <main+0x23a>
+		}
+
+		printf("Calling parser%s",cmdLine);
+  40176e:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
+  401775:	48 89 c6             	mov    %rax,%rsi
+  401778:	48 8d 3d b4 1e 00 00 	lea    0x1eb4(%rip),%rdi        # 403633 <chdir+0x3bb>
+  40177f:	b8 00 00 00 00       	mov    $0x0,%eax
+  401784:	e8 a7 0a 00 00       	callq  402230 <printf>
+		info = parseModified(cmdLine,envp);
+  401789:	48 8b 95 b8 fe ff ff 	mov    -0x148(%rbp),%rdx
+  401790:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
+  401797:	48 89 d6             	mov    %rdx,%rsi
+  40179a:	48 89 c7             	mov    %rax,%rdi
+  40179d:	e8 2b fa ff ff       	callq  4011cd <parseModified>
+  4017a2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
+		if (info == NULL){
+  4017a6:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
+  4017ab:	75 14                	jne    4017c1 <main+0x161>
+			free(cmdLine);
+  4017ad:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
+  4017b4:	48 89 c7             	mov    %rax,%rdi
+  4017b7:	e8 29 1a 00 00       	callq  4031e5 <free>
+			continue;
+  4017bc:	e9 d9 00 00 00       	jmpq   40189a <main+0x23a>
+		}
+
+		//prints the info struct
+		print_info(info);
+  4017c1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  4017c5:	48 89 c7             	mov    %rax,%rdi
+  4017c8:	e8 8c f9 ff ff       	callq  401159 <print_info>
+
+		strcpy(temp,info->CommArray[0]->commandName);
+  4017cd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  4017d1:	48 8b 00             	mov    (%rax),%rax
+  4017d4:	48 8b 10             	mov    (%rax),%rdx
+  4017d7:	48 8d 85 dc fe ff ff 	lea    -0x124(%rbp),%rax
+  4017de:	48 89 d6             	mov    %rdx,%rsi
+  4017e1:	48 89 c7             	mov    %rax,%rdi
+  4017e4:	e8 52 11 00 00       	callq  40293b <strcpy>
+
+		if(strcmp(temp,"set")==0||strcmp(temp,"cd")==0 || strcmp(temp,"exit")==0){
+  4017e9:	48 8d 85 dc fe ff ff 	lea    -0x124(%rbp),%rax
+  4017f0:	48 8d 35 4d 1e 00 00 	lea    0x1e4d(%rip),%rsi        # 403644 <chdir+0x3cc>
+  4017f7:	48 89 c7             	mov    %rax,%rdi
+  4017fa:	e8 9b 11 00 00       	callq  40299a <strcmp>
+  4017ff:	85 c0                	test   %eax,%eax
+  401801:	74 34                	je     401837 <main+0x1d7>
+  401803:	48 8d 85 dc fe ff ff 	lea    -0x124(%rbp),%rax
+  40180a:	48 8d 35 37 1e 00 00 	lea    0x1e37(%rip),%rsi        # 403648 <chdir+0x3d0>
+  401811:	48 89 c7             	mov    %rax,%rdi
+  401814:	e8 81 11 00 00       	callq  40299a <strcmp>
+  401819:	85 c0                	test   %eax,%eax
+  40181b:	74 1a                	je     401837 <main+0x1d7>
+  40181d:	48 8d 85 dc fe ff ff 	lea    -0x124(%rbp),%rax
+  401824:	48 8d 35 20 1e 00 00 	lea    0x1e20(%rip),%rsi        # 40364b <chdir+0x3d3>
+  40182b:	48 89 c7             	mov    %rax,%rdi
+  40182e:	e8 67 11 00 00       	callq  40299a <strcmp>
+  401833:	85 c0                	test   %eax,%eax
+  401835:	75 29                	jne    401860 <main+0x200>
+
+			printf("Executing Builtin command\n");
+  401837:	48 8d 3d 12 1e 00 00 	lea    0x1e12(%rip),%rdi        # 403650 <chdir+0x3d8>
+  40183e:	b8 00 00 00 00       	mov    $0x0,%eax
+  401843:	e8 e8 09 00 00       	callq  402230 <printf>
+			executeBuiltins(info,envp);
+  401848:	48 8b 95 b8 fe ff ff 	mov    -0x148(%rbp),%rdx
+  40184f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  401853:	48 89 d6             	mov    %rdx,%rsi
+  401856:	48 89 c7             	mov    %rax,%rdi
+  401859:	e8 80 f0 ff ff       	callq  4008de <executeBuiltins>
+  40185e:	eb 27                	jmp    401887 <main+0x227>
+		}
+
+		else{
+            printf("Calling Execute");
+  401860:	48 8d 3d 04 1e 00 00 	lea    0x1e04(%rip),%rdi        # 40366b <chdir+0x3f3>
+  401867:	b8 00 00 00 00       	mov    $0x0,%eax
+  40186c:	e8 bf 09 00 00       	callq  402230 <printf>
+			execute_cmd(info,envp);
+  401871:	48 8b 95 b8 fe ff ff 	mov    -0x148(%rbp),%rdx
+  401878:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  40187c:	48 89 d6             	mov    %rdx,%rsi
+  40187f:	48 89 c7             	mov    %rax,%rdi
+  401882:	e8 24 f2 ff ff       	callq  400aab <execute_cmd>
+		}
+
+
+
+		static int loop=0;
+		loop++;
+  401887:	8b 05 93 2c 20 00    	mov    0x202c93(%rip),%eax        # 604520 <loop.1275>
+  40188d:	ff c0                	inc    %eax
+  40188f:	89 05 8b 2c 20 00    	mov    %eax,0x202c8b(%rip)        # 604520 <loop.1275>
+		//printf("Out of execute%d\n",loop++);
+		//exit(0);
+	}/* while(1) */
+  401895:	e9 1d fe ff ff       	jmpq   4016b7 <main+0x57>
+  40189a:	e9 18 fe ff ff       	jmpq   4016b7 <main+0x57>
+	//printf("BYE BYE");
+	return 0;
+  40189f:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  4018a4:	c9                   	leaveq 
+  4018a5:	c3                   	retq   
+
+00000000004018a6 <onlyWhiteSpace>:
+#include <string.h>
+#include <shell.h>
+
+
+
+int onlyWhiteSpace(char *str){
+  4018a6:	55                   	push   %rbp
+  4018a7:	48 89 e5             	mov    %rsp,%rbp
+  4018aa:	48 83 ec 18          	sub    $0x18,%rsp
+  4018ae:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+
+	//checks if a token is solely composed of white space.
+	//if yes returns 1 else returns 0.So that token is not added to the array.
+
+	int i=0;
+  4018b2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
+
+	while(str[i]!='\0'){
+  4018b9:	eb 32                	jmp    4018ed <onlyWhiteSpace+0x47>
+
+		if(!((str[i]=='\t') || (str[i]==' '))){
+  4018bb:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  4018be:	48 63 d0             	movslq %eax,%rdx
+  4018c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  4018c5:	48 01 d0             	add    %rdx,%rax
+  4018c8:	0f b6 00             	movzbl (%rax),%eax
+  4018cb:	3c 09                	cmp    $0x9,%al
+  4018cd:	74 1b                	je     4018ea <onlyWhiteSpace+0x44>
+  4018cf:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  4018d2:	48 63 d0             	movslq %eax,%rdx
+  4018d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  4018d9:	48 01 d0             	add    %rdx,%rax
+  4018dc:	0f b6 00             	movzbl (%rax),%eax
+  4018df:	3c 20                	cmp    $0x20,%al
+  4018e1:	74 07                	je     4018ea <onlyWhiteSpace+0x44>
+
+			return 0;
+  4018e3:	b8 00 00 00 00       	mov    $0x0,%eax
+  4018e8:	eb 1c                	jmp    401906 <onlyWhiteSpace+0x60>
+		}
+		i++;
+  4018ea:	ff 45 fc             	incl   -0x4(%rbp)
+	//checks if a token is solely composed of white space.
+	//if yes returns 1 else returns 0.So that token is not added to the array.
+
+	int i=0;
+
+	while(str[i]!='\0'){
+  4018ed:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  4018f0:	48 63 d0             	movslq %eax,%rdx
+  4018f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  4018f7:	48 01 d0             	add    %rdx,%rax
+  4018fa:	0f b6 00             	movzbl (%rax),%eax
+  4018fd:	84 c0                	test   %al,%al
+  4018ff:	75 ba                	jne    4018bb <onlyWhiteSpace+0x15>
+			return 0;
+		}
+		i++;
+	}
+
+	return 1;
+  401901:	b8 01 00 00 00       	mov    $0x1,%eax
+
+}
+  401906:	c9                   	leaveq 
+  401907:	c3                   	retq   
+
+0000000000401908 <substring>:
+
+
+char * substring(char* str, int front, int back){
+  401908:	55                   	push   %rbp
+  401909:	48 89 e5             	mov    %rsp,%rbp
+  40190c:	48 81 ec 20 02 00 00 	sub    $0x220,%rsp
+  401913:	48 89 bd e8 fd ff ff 	mov    %rdi,-0x218(%rbp)
+  40191a:	89 b5 e4 fd ff ff    	mov    %esi,-0x21c(%rbp)
+  401920:	89 95 e0 fd ff ff    	mov    %edx,-0x220(%rbp)
+
+	//temporary buffer to hold the token;
+	char n[500];
+	char *p;
+	int i=0;
+  401926:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
+
+	//Must handle condition of consequtive delims, delim at the end.Not done till now.
+
+	if(back==front){
+  40192d:	8b 85 e0 fd ff ff    	mov    -0x220(%rbp),%eax
+  401933:	3b 85 e4 fd ff ff    	cmp    -0x21c(%rbp),%eax
+  401939:	75 0a                	jne    401945 <substring+0x3d>
+
+		return (char*)NULL;
+  40193b:	b8 00 00 00 00       	mov    $0x0,%eax
+  401940:	e9 d9 00 00 00       	jmpq   401a1e <substring+0x116>
+
+	}
+
+	while(back < front){
+  401945:	eb 31                	jmp    401978 <substring+0x70>
+		n[i++]=str[back++];
+  401947:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  40194a:	8d 50 01             	lea    0x1(%rax),%edx
+  40194d:	89 55 fc             	mov    %edx,-0x4(%rbp)
+  401950:	8b 95 e0 fd ff ff    	mov    -0x220(%rbp),%edx
+  401956:	8d 4a 01             	lea    0x1(%rdx),%ecx
+  401959:	89 8d e0 fd ff ff    	mov    %ecx,-0x220(%rbp)
+  40195f:	48 63 ca             	movslq %edx,%rcx
+  401962:	48 8b 95 e8 fd ff ff 	mov    -0x218(%rbp),%rdx
+  401969:	48 01 ca             	add    %rcx,%rdx
+  40196c:	0f b6 12             	movzbl (%rdx),%edx
+  40196f:	48 98                	cltq   
+  401971:	88 94 05 fc fd ff ff 	mov    %dl,-0x204(%rbp,%rax,1)
+
+		return (char*)NULL;
+
+	}
+
+	while(back < front){
+  401978:	8b 85 e0 fd ff ff    	mov    -0x220(%rbp),%eax
+  40197e:	3b 85 e4 fd ff ff    	cmp    -0x21c(%rbp),%eax
+  401984:	7c c1                	jl     401947 <substring+0x3f>
+		n[i++]=str[back++];
+	}
+	n[i] = '\0';
+  401986:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  401989:	48 98                	cltq   
+  40198b:	c6 84 05 fc fd ff ff 	movb   $0x0,-0x204(%rbp,%rax,1)
+  401992:	00 
+	printf("nIn substring... %s\n",n);
+  401993:	48 8d 85 fc fd ff ff 	lea    -0x204(%rbp),%rax
+  40199a:	48 89 c6             	mov    %rax,%rsi
+  40199d:	48 8d 3d d7 1c 00 00 	lea    0x1cd7(%rip),%rdi        # 40367b <chdir+0x403>
+  4019a4:	b8 00 00 00 00       	mov    $0x0,%eax
+  4019a9:	e8 82 08 00 00       	callq  402230 <printf>
+
+	if(onlyWhiteSpace(n)==0){
+  4019ae:	48 8d 85 fc fd ff ff 	lea    -0x204(%rbp),%rax
+  4019b5:	48 89 c7             	mov    %rax,%rdi
+  4019b8:	e8 e9 fe ff ff       	callq  4018a6 <onlyWhiteSpace>
+  4019bd:	85 c0                	test   %eax,%eax
+  4019bf:	75 40                	jne    401a01 <substring+0xf9>
+		p = (char*)malloc(sizeof(char)*(i+1));
+  4019c1:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  4019c4:	ff c0                	inc    %eax
+  4019c6:	48 98                	cltq   
+  4019c8:	48 89 c7             	mov    %rax,%rdi
+  4019cb:	e8 b6 16 00 00       	callq  403086 <malloc>
+  4019d0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
+
+		strcpy(p,n);
+  4019d4:	48 8d 95 fc fd ff ff 	lea    -0x204(%rbp),%rdx
+  4019db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  4019df:	48 89 d6             	mov    %rdx,%rsi
+  4019e2:	48 89 c7             	mov    %rax,%rdi
+  4019e5:	e8 51 0f 00 00       	callq  40293b <strcpy>
+		printf("After white space p=  ");
+  4019ea:	48 8d 3d 9f 1c 00 00 	lea    0x1c9f(%rip),%rdi        # 403690 <chdir+0x418>
+  4019f1:	b8 00 00 00 00       	mov    $0x0,%eax
+  4019f6:	e8 35 08 00 00       	callq  402230 <printf>
+        return p;
+  4019fb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  4019ff:	eb 1d                	jmp    401a1e <substring+0x116>
+	}
+	else
+		p = (char*)NULL;
+  401a01:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
+  401a08:	00 
+
+    printf("Returning %s from substring");
+  401a09:	48 8d 3d 97 1c 00 00 	lea    0x1c97(%rip),%rdi        # 4036a7 <chdir+0x42f>
+  401a10:	b8 00 00 00 00       	mov    $0x0,%eax
+  401a15:	e8 16 08 00 00       	callq  402230 <printf>
+	return p;
+  401a1a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+
+}
+  401a1e:	c9                   	leaveq 
+  401a1f:	c3                   	retq   
+
+0000000000401a20 <tokenize>:
+
+
+Token* tokenize(char *str,char* delim){
+  401a20:	55                   	push   %rbp
+  401a21:	48 89 e5             	mov    %rsp,%rbp
+  401a24:	48 83 ec 30          	sub    $0x30,%rsp
+  401a28:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
+  401a2c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
+
+	Token* token=(Token*)malloc(sizeof(Token));
+  401a30:	bf 98 01 00 00       	mov    $0x198,%edi
+  401a35:	e8 4c 16 00 00       	callq  403086 <malloc>
+  401a3a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
+	//printf("In Tokenize Printing str %s\n",str);
+	int tokenCount=0;
+  401a3e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
+	int front=0,back=0;
+  401a45:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
+  401a4c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
+	int i=0;
+  401a53:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
+	char *p;
+
+	printf("IN TOKENIZER %s %s",str,delim);
+  401a5a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
+  401a5e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  401a62:	48 89 c6             	mov    %rax,%rsi
+  401a65:	48 8d 3d 57 1c 00 00 	lea    0x1c57(%rip),%rdi        # 4036c3 <chdir+0x44b>
+  401a6c:	b8 00 00 00 00       	mov    $0x0,%eax
+  401a71:	e8 ba 07 00 00       	callq  402230 <printf>
+
+	while(str[front]!='\0'){
+  401a76:	e9 c0 00 00 00       	jmpq   401b3b <tokenize+0x11b>
+
+		if(str[front]== *delim){
+  401a7b:	8b 45 f8             	mov    -0x8(%rbp),%eax
+  401a7e:	48 63 d0             	movslq %eax,%rdx
+  401a81:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  401a85:	48 01 d0             	add    %rdx,%rax
+  401a88:	0f b6 10             	movzbl (%rax),%edx
+  401a8b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
+  401a8f:	0f b6 00             	movzbl (%rax),%eax
+  401a92:	38 c2                	cmp    %al,%dl
+  401a94:	0f 85 9e 00 00 00    	jne    401b38 <tokenize+0x118>
+			//delimiter found. Extract substring.
+			p=substring(str,front,back);
+  401a9a:	8b 55 f4             	mov    -0xc(%rbp),%edx
+  401a9d:	8b 4d f8             	mov    -0x8(%rbp),%ecx
+  401aa0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  401aa4:	89 ce                	mov    %ecx,%esi
+  401aa6:	48 89 c7             	mov    %rax,%rdi
+  401aa9:	e8 5a fe ff ff       	callq  401908 <substring>
+  401aae:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
+            printf("Back in token %s %d ",p,p);
+  401ab2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
+  401ab6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  401aba:	48 89 c6             	mov    %rax,%rsi
+  401abd:	48 8d 3d 12 1c 00 00 	lea    0x1c12(%rip),%rdi        # 4036d6 <chdir+0x45e>
+  401ac4:	b8 00 00 00 00       	mov    $0x0,%eax
+  401ac9:	e8 62 07 00 00       	callq  402230 <printf>
+            
+            if(p==NULL)
+  401ace:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
+  401ad3:	75 11                	jne    401ae6 <tokenize+0xc6>
+                printf("p is null");
+  401ad5:	48 8d 3d 0f 1c 00 00 	lea    0x1c0f(%rip),%rdi        # 4036eb <chdir+0x473>
+  401adc:	b8 00 00 00 00       	mov    $0x0,%eax
+  401ae1:	e8 4a 07 00 00       	callq  402230 <printf>
+
+			if(p != NULL){
+  401ae6:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
+  401aeb:	74 3e                	je     401b2b <tokenize+0x10b>
+				token->tokenArr[tokenCount++]=p;
+  401aed:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  401af0:	8d 50 01             	lea    0x1(%rax),%edx
+  401af3:	89 55 fc             	mov    %edx,-0x4(%rbp)
+  401af6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
+  401afa:	48 98                	cltq   
+  401afc:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
+  401b00:	48 89 4c c2 08       	mov    %rcx,0x8(%rdx,%rax,8)
+				printf("\nIn tokenizer..appending %s\n",token->tokenArr[tokenCount-1]);
+  401b05:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  401b08:	8d 50 ff             	lea    -0x1(%rax),%edx
+  401b0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401b0f:	48 63 d2             	movslq %edx,%rdx
+  401b12:	48 8b 44 d0 08       	mov    0x8(%rax,%rdx,8),%rax
+  401b17:	48 89 c6             	mov    %rax,%rsi
+  401b1a:	48 8d 3d d4 1b 00 00 	lea    0x1bd4(%rip),%rdi        # 4036f5 <chdir+0x47d>
+  401b21:	b8 00 00 00 00       	mov    $0x0,%eax
+  401b26:	e8 05 07 00 00       	callq  402230 <printf>
+			}
+
+			back = front +1;
+  401b2b:	8b 45 f8             	mov    -0x8(%rbp),%eax
+  401b2e:	ff c0                	inc    %eax
+  401b30:	89 45 f4             	mov    %eax,-0xc(%rbp)
+			front++;
+  401b33:	ff 45 f8             	incl   -0x8(%rbp)
+  401b36:	eb 03                	jmp    401b3b <tokenize+0x11b>
+			//continue;
+		}
+
+		else{
+			front++;
+  401b38:	ff 45 f8             	incl   -0x8(%rbp)
+	int i=0;
+	char *p;
+
+	printf("IN TOKENIZER %s %s",str,delim);
+
+	while(str[front]!='\0'){
+  401b3b:	8b 45 f8             	mov    -0x8(%rbp),%eax
+  401b3e:	48 63 d0             	movslq %eax,%rdx
+  401b41:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  401b45:	48 01 d0             	add    %rdx,%rax
+  401b48:	0f b6 00             	movzbl (%rax),%eax
+  401b4b:	84 c0                	test   %al,%al
+  401b4d:	0f 85 28 ff ff ff    	jne    401a7b <tokenize+0x5b>
+		else{
+			front++;
+		}
+	}//end while
+
+	p = substring(str,front,back);
+  401b53:	8b 55 f4             	mov    -0xc(%rbp),%edx
+  401b56:	8b 4d f8             	mov    -0x8(%rbp),%ecx
+  401b59:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  401b5d:	89 ce                	mov    %ecx,%esi
+  401b5f:	48 89 c7             	mov    %rax,%rdi
+  401b62:	e8 a1 fd ff ff       	callq  401908 <substring>
+  401b67:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
+	if(p != NULL){
+  401b6b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
+  401b70:	74 18                	je     401b8a <tokenize+0x16a>
+		token->tokenArr[tokenCount++]=p;
+  401b72:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  401b75:	8d 50 01             	lea    0x1(%rax),%edx
+  401b78:	89 55 fc             	mov    %edx,-0x4(%rbp)
+  401b7b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
+  401b7f:	48 98                	cltq   
+  401b81:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
+  401b85:	48 89 4c c2 08       	mov    %rcx,0x8(%rdx,%rax,8)
+	}
+	token->numOfTokens=tokenCount;
+  401b8a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401b8e:	8b 55 fc             	mov    -0x4(%rbp),%edx
+  401b91:	89 10                	mov    %edx,(%rax)
+
+
+	printf("Before Returning Token\n\n");
+  401b93:	48 8d 3d 78 1b 00 00 	lea    0x1b78(%rip),%rdi        # 403712 <chdir+0x49a>
+  401b9a:	b8 00 00 00 00       	mov    $0x0,%eax
+  401b9f:	e8 8c 06 00 00       	callq  402230 <printf>
+
+	for(i=0;i<token->numOfTokens;i++){
+  401ba4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
+  401bab:	eb 2e                	jmp    401bdb <tokenize+0x1bb>
+
+		printf("Token %d : %s %d\n",i,token->tokenArr[i],token->numOfTokens);
+  401bad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401bb1:	8b 08                	mov    (%rax),%ecx
+  401bb3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401bb7:	8b 55 f0             	mov    -0x10(%rbp),%edx
+  401bba:	48 63 d2             	movslq %edx,%rdx
+  401bbd:	48 8b 54 d0 08       	mov    0x8(%rax,%rdx,8),%rdx
+  401bc2:	8b 45 f0             	mov    -0x10(%rbp),%eax
+  401bc5:	89 c6                	mov    %eax,%esi
+  401bc7:	48 8d 3d 5d 1b 00 00 	lea    0x1b5d(%rip),%rdi        # 40372b <chdir+0x4b3>
+  401bce:	b8 00 00 00 00       	mov    $0x0,%eax
+  401bd3:	e8 58 06 00 00       	callq  402230 <printf>
+	token->numOfTokens=tokenCount;
+
+
+	printf("Before Returning Token\n\n");
+
+	for(i=0;i<token->numOfTokens;i++){
+  401bd8:	ff 45 f0             	incl   -0x10(%rbp)
+  401bdb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401bdf:	8b 00                	mov    (%rax),%eax
+  401be1:	3b 45 f0             	cmp    -0x10(%rbp),%eax
+  401be4:	7f c7                	jg     401bad <tokenize+0x18d>
+
+		printf("Token %d : %s %d\n",i,token->tokenArr[i],token->numOfTokens);
+	}
+
+
+	return token;
+  401be6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+
+}
+  401bea:	c9                   	leaveq 
+  401beb:	c3                   	retq   
+
+0000000000401bec <main2>:
+#include<stdlib.h>
+#include<stdio.h>
+int main2 (int argc, char *argv[], char* envp[])
+{
+  401bec:	55                   	push   %rbp
+  401bed:	48 89 e5             	mov    %rsp,%rbp
+  401bf0:	48 83 ec 30          	sub    $0x30,%rsp
+  401bf4:	89 7d ec             	mov    %edi,-0x14(%rbp)
+  401bf7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+  401bfb:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
+char* s=(char*)malloc(10);
+  401bff:	bf 0a 00 00 00       	mov    $0xa,%edi
+  401c04:	e8 7d 14 00 00       	callq  403086 <malloc>
+  401c09:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 
-0000000000400113 <parallel_fork>:
+printf("s=%d",s);
+  401c0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  401c11:	48 89 c6             	mov    %rax,%rsi
+  401c14:	48 8d 3d 22 1b 00 00 	lea    0x1b22(%rip),%rdi        # 40373d <chdir+0x4c5>
+  401c1b:	b8 00 00 00 00       	mov    $0x0,%eax
+  401c20:	e8 0b 06 00 00       	callq  402230 <printf>
+return 0;
+  401c25:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  401c2a:	c9                   	leaveq 
+  401c2b:	c3                   	retq   
+
+0000000000401c2c <test>:
 #include <stdlib.h>
-#include <test.h>
-#include <errno.h>
 #include <string.h>
 
-void parallel_fork(){
-  400113:	55                   	push   %rbp
-  400114:	48 89 e5             	mov    %rsp,%rbp
 
+	
+uint64_t test(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3){
+  401c2c:	55                   	push   %rbp
+  401c2d:	48 89 e5             	mov    %rsp,%rbp
+  401c30:	48 83 ec 30          	sub    $0x30,%rsp
+  401c34:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  401c38:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+  401c3c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
+  401c40:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
+
+	//printf("Inside test\n");
+
+
+	uint64_t ret;
+	__asm__("movq %1,%%rax;"
+  401c44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401c48:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  401c4c:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
+  401c50:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
+  401c54:	cd 80                	int    $0x80
+  401c56:	48 89 c0             	mov    %rax,%rax
+  401c59:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+			"movq %3,%%rsi;"
+			"movq %4, %%rdx;"
+			"int $0x80;"
+			"movq %%rax,%0;"
+			:"=r"(ret):"m"(n),"m"(a1),"m"(a2),"m"(a3));
+	return ret;
+  401c5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+
+
+}
+  401c61:	c9                   	leaveq 
+  401c62:	c3                   	retq   
+
+0000000000401c63 <readdir>:
+
+
+
+
+struct dirent* readdir(void *dir){
+  401c63:	55                   	push   %rbp
+  401c64:	48 89 e5             	mov    %rsp,%rbp
+  401c67:	48 81 ec 20 04 00 00 	sub    $0x420,%rsp
+  401c6e:	48 89 bd e8 fb ff ff 	mov    %rdi,-0x418(%rbp)
+
+	char buff[1024];
+
+	if((uint64_t)dir == -1){
+  401c75:	48 8b 85 e8 fb ff ff 	mov    -0x418(%rbp),%rax
+  401c7c:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
+  401c80:	75 18                	jne    401c9a <readdir+0x37>
+
+		printf("Bad directory stream\n");
+  401c82:	48 8d 3d bf 1a 00 00 	lea    0x1abf(%rip),%rdi        # 403748 <chdir+0x4d0>
+  401c89:	b8 00 00 00 00       	mov    $0x0,%eax
+  401c8e:	e8 9d 05 00 00       	callq  402230 <printf>
+		return NULL;
+  401c93:	b8 00 00 00 00       	mov    $0x0,%eax
+  401c98:	eb 6a                	jmp    401d04 <readdir+0xa1>
+	}
+
+
+	int ret = test(78,(uint64_t)dir,(uint64_t)buff,(uint64_t)1024);
+  401c9a:	48 8d 95 f0 fb ff ff 	lea    -0x410(%rbp),%rdx
+  401ca1:	48 8b 85 e8 fb ff ff 	mov    -0x418(%rbp),%rax
+  401ca8:	b9 00 04 00 00       	mov    $0x400,%ecx
+  401cad:	48 89 c6             	mov    %rax,%rsi
+  401cb0:	bf 4e 00 00 00       	mov    $0x4e,%edi
+  401cb5:	e8 72 ff ff ff       	callq  401c2c <test>
+  401cba:	89 45 fc             	mov    %eax,-0x4(%rbp)
+
+	//printf("Ret value %d\n", ret );
+
+	if(ret == -1){
+  401cbd:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
+  401cc1:	75 18                	jne    401cdb <readdir+0x78>
+
+		//Error
+		printf("Error while reading directory\n");
+  401cc3:	48 8d 3d 96 1a 00 00 	lea    0x1a96(%rip),%rdi        # 403760 <chdir+0x4e8>
+  401cca:	b8 00 00 00 00       	mov    $0x0,%eax
+  401ccf:	e8 5c 05 00 00       	callq  402230 <printf>
+		return NULL;
+  401cd4:	b8 00 00 00 00       	mov    $0x0,%eax
+  401cd9:	eb 29                	jmp    401d04 <readdir+0xa1>
+
+	}
+
+	else if (ret == 0){
+  401cdb:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
+  401cdf:	75 07                	jne    401ce8 <readdir+0x85>
+
+		//End of directory stream
+		return NULL;
+  401ce1:	b8 00 00 00 00       	mov    $0x0,%eax
+  401ce6:	eb 1c                	jmp    401d04 <readdir+0xa1>
+
+	}
+
+	else if(ret !=0){
+  401ce8:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
+  401cec:	74 11                	je     401cff <readdir+0x9c>
+
+		//There is a valid child
+		//printf("Ret of readdir is not 0\n");
+		struct dirent* x = (struct dirent*)buff;
+  401cee:	48 8d 85 f0 fb ff ff 	lea    -0x410(%rbp),%rax
+  401cf5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
+		//printf("Name of entry dir%s\n",x->d_name );
+		return x;
+  401cf9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  401cfd:	eb 05                	jmp    401d04 <readdir+0xa1>
+	}
+
+
+	return NULL;
+  401cff:	b8 00 00 00 00       	mov    $0x0,%eax
+
+}
+  401d04:	c9                   	leaveq 
+  401d05:	c3                   	retq   
+
+0000000000401d06 <syscall_2>:
+				:"=r"(ret):"m"(n),"m"(a1));
+	}
+	return ret;
+}
+
+static __inline uint64_t syscall_2(uint64_t n, uint64_t a1, uint64_t a2) {
+  401d06:	55                   	push   %rbp
+  401d07:	48 89 e5             	mov    %rsp,%rbp
+  401d0a:	48 83 ec 28          	sub    $0x28,%rsp
+  401d0e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  401d12:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+  401d16:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
+
+	uint64_t ret;
+	__asm__("movq %1,%%rax;"
+  401d1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401d1e:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  401d22:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
+  401d26:	cd 80                	int    $0x80
+  401d28:	48 89 c0             	mov    %rax,%rax
+  401d2b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+			"movq %2,%%rdi;"
+			"movq %3,%%rsi;"
+			"int $0x80;"
+			"movq %%rax,%0;"
+			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
+	return ret;
+  401d2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+}
+  401d33:	c9                   	leaveq 
+  401d34:	c3                   	retq   
+
+0000000000401d35 <dup2>:
+#include<sys/syscall.h>
+#include<syscall.h>
+#include<stdlib.h>
+
+int dup2(int oldfd, int newfd)
+{
+  401d35:	55                   	push   %rbp
+  401d36:	48 89 e5             	mov    %rsp,%rbp
+  401d39:	48 83 ec 18          	sub    $0x18,%rsp
+  401d3d:	89 7d ec             	mov    %edi,-0x14(%rbp)
+  401d40:	89 75 e8             	mov    %esi,-0x18(%rbp)
+	int retvalue;
+	retvalue = syscall_2(SYS_dup2, oldfd, newfd);
+  401d43:	8b 45 e8             	mov    -0x18(%rbp),%eax
+  401d46:	48 63 d0             	movslq %eax,%rdx
+  401d49:	8b 45 ec             	mov    -0x14(%rbp),%eax
+  401d4c:	48 98                	cltq   
+  401d4e:	48 89 c6             	mov    %rax,%rsi
+  401d51:	bf 21 00 00 00       	mov    $0x21,%edi
+  401d56:	e8 ab ff ff ff       	callq  401d06 <syscall_2>
+  401d5b:	89 45 fc             	mov    %eax,-0x4(%rbp)
+
+	if(retvalue >=0){
+  401d5e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
+  401d62:	78 05                	js     401d69 <dup2+0x34>
+		return retvalue;
+  401d64:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  401d67:	eb 05                	jmp    401d6e <dup2+0x39>
+	}
+	return -1;
+  401d69:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+
+
+}
+  401d6e:	c9                   	leaveq 
+  401d6f:	c3                   	retq   
 
-    //int *pipe = (int*)malloc(4*sizeof(int));
+0000000000401d70 <syscall_2>:
+				:"=r"(ret):"m"(n),"m"(a1));
+	}
+	return ret;
+}
 
+static __inline uint64_t syscall_2(uint64_t n, uint64_t a1, uint64_t a2) {
+  401d70:	55                   	push   %rbp
+  401d71:	48 89 e5             	mov    %rsp,%rbp
+  401d74:	48 83 ec 28          	sub    $0x28,%rsp
+  401d78:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  401d7c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+  401d80:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
 
+	uint64_t ret;
+	__asm__("movq %1,%%rax;"
+  401d84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401d88:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  401d8c:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
+  401d90:	cd 80                	int    $0x80
+  401d92:	48 89 c0             	mov    %rax,%rax
+  401d95:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+			"movq %2,%%rdi;"
+			"movq %3,%%rsi;"
+			"int $0x80;"
+			"movq %%rax,%0;"
+			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
+	return ret;
+  401d99:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 }
-  400117:	5d                   	pop    %rbp
-  400118:	c3                   	retq   
+  401d9d:	c9                   	leaveq 
+  401d9e:	c3                   	retq   
+
+0000000000401d9f <open>:
+#include <errno.h>
+
+//int errno = 0;
 
-0000000000400119 <main>:
-int main(int argc, char* argv[], char* envp[])
+int open(const char *pathname, int flags)
 {
-  400119:	55                   	push   %rbp
-  40011a:	48 89 e5             	mov    %rsp,%rbp
-  40011d:	48 83 ec 30          	sub    $0x30,%rsp
-  400121:	89 7d ec             	mov    %edi,-0x14(%rbp)
-  400124:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
-  400128:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
-//    parallel_fork();
-    int pid[tot] ;
-
-    int i;
-    int p;
-    int status=(uint64_t)&p;
-  40012c:	48 8d 45 f4          	lea    -0xc(%rbp),%rax
-  400130:	89 45 f0             	mov    %eax,-0x10(%rbp)
-
-    for(i=0;i<tot;i++){
-  400133:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
-  40013a:	eb 36                	jmp    400172 <main+0x59>
-
-
-        pid[i] = fork();
-  40013c:	e8 35 08 00 00       	callq  400976 <fork>
-  400141:	89 c2                	mov    %eax,%edx
-  400143:	8b 45 fc             	mov    -0x4(%rbp),%eax
-  400146:	48 98                	cltq   
-  400148:	89 54 85 f8          	mov    %edx,-0x8(%rbp,%rax,4)
-
-       if(pid[i] == 0){
-  40014c:	8b 45 fc             	mov    -0x4(%rbp),%eax
-  40014f:	48 98                	cltq   
-  400151:	8b 44 85 f8          	mov    -0x8(%rbp,%rax,4),%eax
-  400155:	85 c0                	test   %eax,%eax
-  400157:	75 16                	jne    40016f <main+0x56>
-
-            execve("/bin/malluaunty",NULL,NULL);
-  400159:	ba 00 00 00 00       	mov    $0x0,%edx
-  40015e:	be 00 00 00 00       	mov    $0x0,%esi
-  400163:	48 8d 3d 93 08 00 00 	lea    0x893(%rip),%rdi        # 4009fd <exit+0x1c>
-  40016a:	e8 a6 07 00 00       	callq  400915 <execve>
-
-    int i;
-    int p;
-    int status=(uint64_t)&p;
-
-    for(i=0;i<tot;i++){
-  40016f:	ff 45 fc             	incl   -0x4(%rbp)
-  400172:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
-  400176:	7e c4                	jle    40013c <main+0x23>
-            execve("/bin/malluaunty",NULL,NULL);
+  401d9f:	55                   	push   %rbp
+  401da0:	48 89 e5             	mov    %rsp,%rbp
+  401da3:	48 83 ec 20          	sub    $0x20,%rsp
+  401da7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  401dab:	89 75 e4             	mov    %esi,-0x1c(%rbp)
+	int retvalue;
+	retvalue = syscall_2(SYS_open, (uint64_t)pathname, (uint64_t)flags);
+  401dae:	8b 45 e4             	mov    -0x1c(%rbp),%eax
+  401db1:	48 63 d0             	movslq %eax,%rdx
+  401db4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401db8:	48 89 c6             	mov    %rax,%rsi
+  401dbb:	bf 02 00 00 00       	mov    $0x2,%edi
+  401dc0:	e8 ab ff ff ff       	callq  401d70 <syscall_2>
+  401dc5:	89 45 fc             	mov    %eax,-0x4(%rbp)
+	if(retvalue >=0){
+  401dc8:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
+  401dcc:	78 05                	js     401dd3 <open+0x34>
+		return retvalue;
+  401dce:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  401dd1:	eb 05                	jmp    401dd8 <open+0x39>
+	}
 
-        }
+	return -1;
+  401dd3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+
+}
+  401dd8:	c9                   	leaveq 
+  401dd9:	c3                   	retq   
+
+0000000000401dda <syscall_2>:
+				:"=r"(ret):"m"(n),"m"(a1));
+	}
+	return ret;
+}
+
+static __inline uint64_t syscall_2(uint64_t n, uint64_t a1, uint64_t a2) {
+  401dda:	55                   	push   %rbp
+  401ddb:	48 89 e5             	mov    %rsp,%rbp
+  401dde:	48 83 ec 28          	sub    $0x28,%rsp
+  401de2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  401de6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+  401dea:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
+
+	uint64_t ret;
+	__asm__("movq %1,%%rax;"
+  401dee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401df2:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  401df6:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
+  401dfa:	cd 80                	int    $0x80
+  401dfc:	48 89 c0             	mov    %rax,%rax
+  401dff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+			"movq %2,%%rdi;"
+			"movq %3,%%rsi;"
+			"int $0x80;"
+			"movq %%rax,%0;"
+			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
+	return ret;
+  401e03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+}
+  401e07:	c9                   	leaveq 
+  401e08:	c3                   	retq   
+
+0000000000401e09 <getcwd>:
+#include <stdlib.h>
+#include <errno.h>
+
+//int errno=0; //Only define here. declaration seeps through to the files via stdlib.h
+
+char* getcwd(char *buf, size_t size){
+  401e09:	55                   	push   %rbp
+  401e0a:	48 89 e5             	mov    %rsp,%rbp
+  401e0d:	48 83 ec 20          	sub    $0x20,%rsp
+  401e11:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  401e15:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+
+	int retvalue;
+	retvalue=syscall_2(SYS_getcwd,(uint64_t)buf,(uint64_t)size);
+  401e19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401e1d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
+  401e21:	48 89 c6             	mov    %rax,%rsi
+  401e24:	bf 4f 00 00 00       	mov    $0x4f,%edi
+  401e29:	e8 ac ff ff ff       	callq  401dda <syscall_2>
+  401e2e:	89 45 fc             	mov    %eax,-0x4(%rbp)
+
+	if(retvalue >=0){
+  401e31:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
+  401e35:	78 06                	js     401e3d <getcwd+0x34>
+		return buf;
+  401e37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401e3b:	eb 05                	jmp    401e42 <getcwd+0x39>
+	}
+	return NULL;
+  401e3d:	b8 00 00 00 00       	mov    $0x0,%eax
+
+}
+  401e42:	c9                   	leaveq 
+  401e43:	c3                   	retq   
 
-      }
-    status=status;
-  400178:	8b 45 f0             	mov    -0x10(%rbp),%eax
-  40017b:	89 45 f0             	mov    %eax,-0x10(%rbp)
-     for(i=0;i<tot;i++);;
-  40017e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
-  400185:	eb 03                	jmp    40018a <main+0x71>
-  400187:	ff 45 fc             	incl   -0x4(%rbp)
-  40018a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
-  40018e:	7e f7                	jle    400187 <main+0x6e>
-     {
-         printf("chpid[%d]= %d",0,pid[0]);
-  400190:	8b 45 f8             	mov    -0x8(%rbp),%eax
-  400193:	89 c2                	mov    %eax,%edx
-  400195:	be 00 00 00 00       	mov    $0x0,%esi
-  40019a:	48 8d 3d 6c 08 00 00 	lea    0x86c(%rip),%rdi        # 400a0d <exit+0x2c>
-  4001a1:	b8 00 00 00 00       	mov    $0x0,%eax
-  4001a6:	e8 04 03 00 00       	callq  4004af <printf>
-         waitpid(pid[0],&status,0);
-  4001ab:	8b 45 f8             	mov    -0x8(%rbp),%eax
-  4001ae:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
-  4001b2:	ba 00 00 00 00       	mov    $0x0,%edx
-  4001b7:	48 89 ce             	mov    %rcx,%rsi
-  4001ba:	89 c7                	mov    %eax,%edi
-  4001bc:	e8 bc 00 00 00       	callq  40027d <waitpid>
-   }
-printf("***PARENT EXITNG***\n");
-  4001c1:	48 8d 3d 53 08 00 00 	lea    0x853(%rip),%rdi        # 400a1b <exit+0x3a>
-  4001c8:	b8 00 00 00 00       	mov    $0x0,%eax
-  4001cd:	e8 dd 02 00 00       	callq  4004af <printf>
-  4001d2:	b8 00 00 00 00       	mov    $0x0,%eax
-
-
-}
-  4001d7:	c9                   	leaveq 
-  4001d8:	c3                   	retq   
-
-00000000004001d9 <syscall_0>:
+0000000000401e44 <syscall_1>:
+			:"=r"(ret):"m"(n));
+
+	return ret;
+}
+
+static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
+  401e44:	55                   	push   %rbp
+  401e45:	48 89 e5             	mov    %rsp,%rbp
+  401e48:	48 83 ec 20          	sub    $0x20,%rsp
+  401e4c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  401e50:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+
+	int64_t ret;
+
+	__asm__("movq $78,%r15");
+  401e54:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
+	//__asm__("movq %0,%%rax;"
+	//		::"m"(n));
+
+	//while(1);
+
+	if(n==60){
+  401e5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401e5f:	48 83 f8 3c          	cmp    $0x3c,%rax
+  401e63:	75 0c                	jne    401e71 <syscall_1+0x2d>
+		__asm__("movq %0,%%rax;"
+  401e65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401e69:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  401e6d:	cd 80                	int    $0x80
+  401e6f:	eb 11                	jmp    401e82 <syscall_1+0x3e>
+
+		//while(1);
+	}
+	else{
+
+		__asm__("movq %1,%%rax;"
+  401e71:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401e75:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  401e79:	cd 80                	int    $0x80
+  401e7b:	48 89 c0             	mov    %rax,%rax
+  401e7e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+				"movq %2,%%rdi;"
+				"int $0x80;"
+				"movq %%rax,%0;"
+				:"=r"(ret):"m"(n),"m"(a1));
+	}
+	return ret;
+  401e82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+}
+  401e86:	c9                   	leaveq 
+  401e87:	c3                   	retq   
+
+0000000000401e88 <close>:
+#include<sys/syscall.h>
+#include<syscall.h>
+#include <stdlib.h>
+
+int close(int fd)
+{
+  401e88:	55                   	push   %rbp
+  401e89:	48 89 e5             	mov    %rsp,%rbp
+  401e8c:	48 83 ec 18          	sub    $0x18,%rsp
+  401e90:	89 7d ec             	mov    %edi,-0x14(%rbp)
+	int retvalue;
+	retvalue = syscall_1(SYS_close, fd);
+  401e93:	8b 45 ec             	mov    -0x14(%rbp),%eax
+  401e96:	48 98                	cltq   
+  401e98:	48 89 c6             	mov    %rax,%rsi
+  401e9b:	bf 03 00 00 00       	mov    $0x3,%edi
+  401ea0:	e8 9f ff ff ff       	callq  401e44 <syscall_1>
+  401ea5:	89 45 fc             	mov    %eax,-0x4(%rbp)
+
+	if(retvalue >=0){
+  401ea8:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
+  401eac:	78 05                	js     401eb3 <close+0x2b>
+		return retvalue;
+  401eae:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  401eb1:	eb 05                	jmp    401eb8 <close+0x30>
+	}
+	return -1;
+  401eb3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+
+}
+  401eb8:	c9                   	leaveq 
+  401eb9:	c3                   	retq   
+
+0000000000401eba <syscall_0>:
 #define _SYSCALL_H
 
 #include <sys/defs.h>
 #include <sys/syscall.h>
 
 static __inline uint64_t syscall_0(uint64_t n) {
-  4001d9:	55                   	push   %rbp
-  4001da:	48 89 e5             	mov    %rsp,%rbp
-  4001dd:	48 83 ec 18          	sub    $0x18,%rsp
-  4001e1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  401eba:	55                   	push   %rbp
+  401ebb:	48 89 e5             	mov    %rsp,%rbp
+  401ebe:	48 83 ec 18          	sub    $0x18,%rsp
+  401ec2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 
 	uint64_t ret;
 	__asm__("movq %1,%%rax;"
-  4001e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
-  4001e9:	cd 80                	int    $0x80
-  4001eb:	48 89 c0             	mov    %rax,%rax
-  4001ee:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+  401ec6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401eca:	cd 80                	int    $0x80
+  401ecc:	48 89 c0             	mov    %rax,%rax
+  401ecf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 			"int $0x80;"
 			"movq %%rax,%0;"
 			:"=r"(ret):"m"(n));
 
 	return ret;
-  4001f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  401ed3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 }
-  4001f6:	c9                   	leaveq 
-  4001f7:	c3                   	retq   
+  401ed7:	c9                   	leaveq 
+  401ed8:	c3                   	retq   
 
-00000000004001f8 <syscall_3>:
+0000000000401ed9 <syscall_3>:
 			"movq %%rax,%0;"
 			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
 	return ret;
 }
 
 static __inline uint64_t syscall_3(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3) {
-  4001f8:	55                   	push   %rbp
-  4001f9:	48 89 e5             	mov    %rsp,%rbp
-  4001fc:	48 83 ec 30          	sub    $0x30,%rsp
-  400200:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
-  400204:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
-  400208:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
-  40020c:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
+  401ed9:	55                   	push   %rbp
+  401eda:	48 89 e5             	mov    %rsp,%rbp
+  401edd:	48 83 ec 30          	sub    $0x30,%rsp
+  401ee1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  401ee5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+  401ee9:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
+  401eed:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
 
 	uint64_t ret;
     
 	__asm__("movq %1,%%rax;"
-  400210:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
-  400214:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
-  400218:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
-  40021c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
-  400220:	cd 80                	int    $0x80
-  400222:	48 89 c0             	mov    %rax,%rax
-  400225:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+  401ef1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401ef5:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  401ef9:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
+  401efd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
+  401f01:	cd 80                	int    $0x80
+  401f03:	48 89 c0             	mov    %rax,%rax
+  401f06:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 			"movq %3, %%rsi;"
 			"movq %4, %%rdx;"
 			"int $0x80;"
 			"movq %%rax,%0;"
 			:"=r"(ret):"m"(n),"m"(a1),"m"(a2),"m"(a3));
 	return ret;
-  400229:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  401f0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 }
-  40022d:	c9                   	leaveq 
-  40022e:	c3                   	retq   
+  401f0e:	c9                   	leaveq 
+  401f0f:	c3                   	retq   
 
-000000000040022f <getpid>:
+0000000000401f10 <getpid>:
 #include <sys/defs.h>
 #include <stdlib.h>
 #include <sys/syscall.h>
 
 pid_t getpid()
 {
-  40022f:	55                   	push   %rbp
-  400230:	48 89 e5             	mov    %rsp,%rbp
-  400233:	48 83 ec 10          	sub    $0x10,%rsp
+  401f10:	55                   	push   %rbp
+  401f11:	48 89 e5             	mov    %rsp,%rbp
+  401f14:	48 83 ec 10          	sub    $0x10,%rsp
 	int retvalue;
 	retvalue = syscall_0(SYS_getpid);
-  400237:	bf 27 00 00 00       	mov    $0x27,%edi
-  40023c:	e8 98 ff ff ff       	callq  4001d9 <syscall_0>
-  400241:	89 45 fc             	mov    %eax,-0x4(%rbp)
+  401f18:	bf 27 00 00 00       	mov    $0x27,%edi
+  401f1d:	e8 98 ff ff ff       	callq  401eba <syscall_0>
+  401f22:	89 45 fc             	mov    %eax,-0x4(%rbp)
 	if(retvalue >=0){
-  400244:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
-  400248:	78 05                	js     40024f <getpid+0x20>
+  401f25:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
+  401f29:	78 05                	js     401f30 <getpid+0x20>
 		return retvalue;
-  40024a:	8b 45 fc             	mov    -0x4(%rbp),%eax
-  40024d:	eb 05                	jmp    400254 <getpid+0x25>
+  401f2b:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  401f2e:	eb 05                	jmp    401f35 <getpid+0x25>
 	}
 	return -1;
-  40024f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  401f30:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 
 
 }
-  400254:	c9                   	leaveq 
-  400255:	c3                   	retq   
+  401f35:	c9                   	leaveq 
+  401f36:	c3                   	retq   
 
-0000000000400256 <getppid>:
+0000000000401f37 <getppid>:
 
 pid_t getppid()
 {
-  400256:	55                   	push   %rbp
-  400257:	48 89 e5             	mov    %rsp,%rbp
-  40025a:	48 83 ec 10          	sub    $0x10,%rsp
+  401f37:	55                   	push   %rbp
+  401f38:	48 89 e5             	mov    %rsp,%rbp
+  401f3b:	48 83 ec 10          	sub    $0x10,%rsp
 	int retvalue;
 	retvalue = syscall_0(SYS_getppid);
-  40025e:	bf 6e 00 00 00       	mov    $0x6e,%edi
-  400263:	e8 71 ff ff ff       	callq  4001d9 <syscall_0>
-  400268:	89 45 fc             	mov    %eax,-0x4(%rbp)
+  401f3f:	bf 6e 00 00 00       	mov    $0x6e,%edi
+  401f44:	e8 71 ff ff ff       	callq  401eba <syscall_0>
+  401f49:	89 45 fc             	mov    %eax,-0x4(%rbp)
 	if(retvalue >=0){
-  40026b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
-  40026f:	78 05                	js     400276 <getppid+0x20>
+  401f4c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
+  401f50:	78 05                	js     401f57 <getppid+0x20>
 		return retvalue;
-  400271:	8b 45 fc             	mov    -0x4(%rbp),%eax
-  400274:	eb 05                	jmp    40027b <getppid+0x25>
+  401f52:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  401f55:	eb 05                	jmp    401f5c <getppid+0x25>
 	}
 
 	return -1;
-  400276:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  401f57:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 
 
 }
-  40027b:	c9                   	leaveq 
-  40027c:	c3                   	retq   
+  401f5c:	c9                   	leaveq 
+  401f5d:	c3                   	retq   
 
-000000000040027d <waitpid>:
+0000000000401f5e <waitpid>:
 
 pid_t waitpid(pid_t pid, int *status, int options)
 {
-  40027d:	55                   	push   %rbp
-  40027e:	48 89 e5             	mov    %rsp,%rbp
-  400281:	48 83 ec 20          	sub    $0x20,%rsp
-  400285:	89 7d ec             	mov    %edi,-0x14(%rbp)
-  400288:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
-  40028c:	89 55 e8             	mov    %edx,-0x18(%rbp)
+  401f5e:	55                   	push   %rbp
+  401f5f:	48 89 e5             	mov    %rsp,%rbp
+  401f62:	48 83 ec 20          	sub    $0x20,%rsp
+  401f66:	89 7d ec             	mov    %edi,-0x14(%rbp)
+  401f69:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+  401f6d:	89 55 e8             	mov    %edx,-0x18(%rbp)
 	pid_t retvalue;
 	retvalue = syscall_3(SYS_wait4,(uint64_t)pid,(uint64_t)status,(uint64_t)options);
-  40028f:	8b 45 e8             	mov    -0x18(%rbp),%eax
-  400292:	48 63 c8             	movslq %eax,%rcx
-  400295:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
-  400299:	8b 45 ec             	mov    -0x14(%rbp),%eax
-  40029c:	48 89 c6             	mov    %rax,%rsi
-  40029f:	bf 3d 00 00 00       	mov    $0x3d,%edi
-  4002a4:	e8 4f ff ff ff       	callq  4001f8 <syscall_3>
-  4002a9:	89 45 fc             	mov    %eax,-0x4(%rbp)
+  401f70:	8b 45 e8             	mov    -0x18(%rbp),%eax
+  401f73:	48 63 c8             	movslq %eax,%rcx
+  401f76:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
+  401f7a:	8b 45 ec             	mov    -0x14(%rbp),%eax
+  401f7d:	48 89 c6             	mov    %rax,%rsi
+  401f80:	bf 3d 00 00 00       	mov    $0x3d,%edi
+  401f85:	e8 4f ff ff ff       	callq  401ed9 <syscall_3>
+  401f8a:	89 45 fc             	mov    %eax,-0x4(%rbp)
 	if(retvalue >=0){
 		return retvalue;
-  4002ac:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  401f8d:	8b 45 fc             	mov    -0x4(%rbp),%eax
 	}
 
 	return -1;
 
 }
-  4002af:	c9                   	leaveq 
-  4002b0:	c3                   	retq   
+  401f90:	c9                   	leaveq 
+  401f91:	c3                   	retq   
+
+0000000000401f92 <syscall_1>:
+			:"=r"(ret):"m"(n));
+
+	return ret;
+}
+
+static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
+  401f92:	55                   	push   %rbp
+  401f93:	48 89 e5             	mov    %rsp,%rbp
+  401f96:	48 83 ec 20          	sub    $0x20,%rsp
+  401f9a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  401f9e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+
+	int64_t ret;
+
+	__asm__("movq $78,%r15");
+  401fa2:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
+	//__asm__("movq %0,%%rax;"
+	//		::"m"(n));
+
+	//while(1);
+
+	if(n==60){
+  401fa9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401fad:	48 83 f8 3c          	cmp    $0x3c,%rax
+  401fb1:	75 0c                	jne    401fbf <syscall_1+0x2d>
+		__asm__("movq %0,%%rax;"
+  401fb3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401fb7:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  401fbb:	cd 80                	int    $0x80
+  401fbd:	eb 11                	jmp    401fd0 <syscall_1+0x3e>
+
+		//while(1);
+	}
+	else{
+
+		__asm__("movq %1,%%rax;"
+  401fbf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401fc3:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  401fc7:	cd 80                	int    $0x80
+  401fc9:	48 89 c0             	mov    %rax,%rax
+  401fcc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+				"movq %2,%%rdi;"
+				"int $0x80;"
+				"movq %%rax,%0;"
+				:"=r"(ret):"m"(n),"m"(a1));
+	}
+	return ret;
+  401fd0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+}
+  401fd4:	c9                   	leaveq 
+  401fd5:	c3                   	retq   
+
+0000000000401fd6 <closedir>:
+#include<sys/defs.h>
+#include<stdlib.h>
+#include<errno.h>
+
+
+int closedir(void *dir){
+  401fd6:	55                   	push   %rbp
+  401fd7:	48 89 e5             	mov    %rsp,%rbp
+  401fda:	48 83 ec 20          	sub    $0x20,%rsp
+  401fde:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+
+
+	if((uint64_t)dir == -1){
+  401fe2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  401fe6:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
+  401fea:	75 18                	jne    402004 <closedir+0x2e>
+
+		printf("Cannot close bad directory stream\n");
+  401fec:	48 8d 3d 8d 17 00 00 	lea    0x178d(%rip),%rdi        # 403780 <chdir+0x508>
+  401ff3:	b8 00 00 00 00       	mov    $0x0,%eax
+  401ff8:	e8 33 02 00 00       	callq  402230 <printf>
+		return -1;
+  401ffd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  402002:	eb 2c                	jmp    402030 <closedir+0x5a>
+	}
+	int fd = (uint64_t)dir;
+  402004:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  402008:	89 45 fc             	mov    %eax,-0x4(%rbp)
+
+	int retvalue;
+	retvalue = syscall_1(SYS_close,(uint64_t)fd);
+  40200b:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  40200e:	48 98                	cltq   
+  402010:	48 89 c6             	mov    %rax,%rsi
+  402013:	bf 03 00 00 00       	mov    $0x3,%edi
+  402018:	e8 75 ff ff ff       	callq  401f92 <syscall_1>
+  40201d:	89 45 f8             	mov    %eax,-0x8(%rbp)
+
+	//printf("closedir syscall returned %d\n",retvalue );
+
+	if(retvalue<0){
+  402020:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
+  402024:	79 07                	jns    40202d <closedir+0x57>
+		
+		return -1;
+  402026:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  40202b:	eb 03                	jmp    402030 <closedir+0x5a>
+
+	}
+	return retvalue;
+  40202d:	8b 45 f8             	mov    -0x8(%rbp),%eax
+
+
+}
+  402030:	c9                   	leaveq 
+  402031:	c3                   	retq   
 
-00000000004002b1 <print_num>:
+0000000000402032 <print_num>:
 
 // update errno.
 char screen[1024];
 int screen_ctr;
 void print_num(int num, int base)
 {
-  4002b1:	55                   	push   %rbp
-  4002b2:	48 89 e5             	mov    %rsp,%rbp
-  4002b5:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
-  4002bc:	89 bd 6c ff ff ff    	mov    %edi,-0x94(%rbp)
-  4002c2:	89 b5 68 ff ff ff    	mov    %esi,-0x98(%rbp)
+  402032:	55                   	push   %rbp
+  402033:	48 89 e5             	mov    %rsp,%rbp
+  402036:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
+  40203d:	89 bd 6c ff ff ff    	mov    %edi,-0x94(%rbp)
+  402043:	89 b5 68 ff ff ff    	mov    %esi,-0x98(%rbp)
 	int number[32];
 	int i=0;
-  4002c8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
+  402049:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
 
 	if(base == 16)
-  4002cf:	83 bd 68 ff ff ff 10 	cmpl   $0x10,-0x98(%rbp)
-  4002d6:	75 44                	jne    40031c <print_num+0x6b>
+  402050:	83 bd 68 ff ff ff 10 	cmpl   $0x10,-0x98(%rbp)
+  402057:	75 44                	jne    40209d <print_num+0x6b>
 	{
 		screen[screen_ctr++] = '0';
-  4002d8:	48 8b 05 21 0d 20 00 	mov    0x200d21(%rip),%rax        # 601000 <exit+0x20061f>
-  4002df:	8b 00                	mov    (%rax),%eax
-  4002e1:	8d 48 01             	lea    0x1(%rax),%ecx
-  4002e4:	48 8b 15 15 0d 20 00 	mov    0x200d15(%rip),%rdx        # 601000 <exit+0x20061f>
-  4002eb:	89 0a                	mov    %ecx,(%rdx)
-  4002ed:	48 8b 15 14 0d 20 00 	mov    0x200d14(%rip),%rdx        # 601008 <exit+0x200627>
-  4002f4:	48 98                	cltq   
-  4002f6:	c6 04 02 30          	movb   $0x30,(%rdx,%rax,1)
+  402059:	48 8b 05 a0 23 20 00 	mov    0x2023a0(%rip),%rax        # 604400 <chdir+0x201188>
+  402060:	8b 00                	mov    (%rax),%eax
+  402062:	8d 48 01             	lea    0x1(%rax),%ecx
+  402065:	48 8b 15 94 23 20 00 	mov    0x202394(%rip),%rdx        # 604400 <chdir+0x201188>
+  40206c:	89 0a                	mov    %ecx,(%rdx)
+  40206e:	48 8b 15 93 23 20 00 	mov    0x202393(%rip),%rdx        # 604408 <chdir+0x201190>
+  402075:	48 98                	cltq   
+  402077:	c6 04 02 30          	movb   $0x30,(%rdx,%rax,1)
 		screen[screen_ctr++] = 'x';
-  4002fa:	48 8b 05 ff 0c 20 00 	mov    0x200cff(%rip),%rax        # 601000 <exit+0x20061f>
-  400301:	8b 00                	mov    (%rax),%eax
-  400303:	8d 48 01             	lea    0x1(%rax),%ecx
-  400306:	48 8b 15 f3 0c 20 00 	mov    0x200cf3(%rip),%rdx        # 601000 <exit+0x20061f>
-  40030d:	89 0a                	mov    %ecx,(%rdx)
-  40030f:	48 8b 15 f2 0c 20 00 	mov    0x200cf2(%rip),%rdx        # 601008 <exit+0x200627>
-  400316:	48 98                	cltq   
-  400318:	c6 04 02 78          	movb   $0x78,(%rdx,%rax,1)
+  40207b:	48 8b 05 7e 23 20 00 	mov    0x20237e(%rip),%rax        # 604400 <chdir+0x201188>
+  402082:	8b 00                	mov    (%rax),%eax
+  402084:	8d 48 01             	lea    0x1(%rax),%ecx
+  402087:	48 8b 15 72 23 20 00 	mov    0x202372(%rip),%rdx        # 604400 <chdir+0x201188>
+  40208e:	89 0a                	mov    %ecx,(%rdx)
+  402090:	48 8b 15 71 23 20 00 	mov    0x202371(%rip),%rdx        # 604408 <chdir+0x201190>
+  402097:	48 98                	cltq   
+  402099:	c6 04 02 78          	movb   $0x78,(%rdx,%rax,1)
 	}
 	do
 	{
 		int rem=num%base;
-  40031c:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
-  400322:	99                   	cltd   
-  400323:	f7 bd 68 ff ff ff    	idivl  -0x98(%rbp)
-  400329:	89 55 f8             	mov    %edx,-0x8(%rbp)
+  40209d:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
+  4020a3:	99                   	cltd   
+  4020a4:	f7 bd 68 ff ff ff    	idivl  -0x98(%rbp)
+  4020aa:	89 55 f8             	mov    %edx,-0x8(%rbp)
 		if((rem) >= 10)
-  40032c:	83 7d f8 09          	cmpl   $0x9,-0x8(%rbp)
-  400330:	7e 06                	jle    400338 <print_num+0x87>
+  4020ad:	83 7d f8 09          	cmpl   $0x9,-0x8(%rbp)
+  4020b1:	7e 06                	jle    4020b9 <print_num+0x87>
 		{
 
 			rem = rem-10 + 'a';
-  400332:	83 45 f8 57          	addl   $0x57,-0x8(%rbp)
-  400336:	eb 04                	jmp    40033c <print_num+0x8b>
+  4020b3:	83 45 f8 57          	addl   $0x57,-0x8(%rbp)
+  4020b7:	eb 04                	jmp    4020bd <print_num+0x8b>
 		}
 		else{
 			rem = rem + '0';
-  400338:	83 45 f8 30          	addl   $0x30,-0x8(%rbp)
+  4020b9:	83 45 f8 30          	addl   $0x30,-0x8(%rbp)
 		}
 		number[i]= rem;
-  40033c:	8b 45 fc             	mov    -0x4(%rbp),%eax
-  40033f:	48 98                	cltq   
-  400341:	8b 55 f8             	mov    -0x8(%rbp),%edx
-  400344:	89 94 85 78 ff ff ff 	mov    %edx,-0x88(%rbp,%rax,4)
+  4020bd:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  4020c0:	48 98                	cltq   
+  4020c2:	8b 55 f8             	mov    -0x8(%rbp),%edx
+  4020c5:	89 94 85 78 ff ff ff 	mov    %edx,-0x88(%rbp,%rax,4)
 		i++;
-  40034b:	ff 45 fc             	incl   -0x4(%rbp)
+  4020cc:	ff 45 fc             	incl   -0x4(%rbp)
 	}while((num=num/base) !=0);
-  40034e:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
-  400354:	99                   	cltd   
-  400355:	f7 bd 68 ff ff ff    	idivl  -0x98(%rbp)
-  40035b:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
-  400361:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%rbp)
-  400368:	75 b2                	jne    40031c <print_num+0x6b>
+  4020cf:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
+  4020d5:	99                   	cltd   
+  4020d6:	f7 bd 68 ff ff ff    	idivl  -0x98(%rbp)
+  4020dc:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
+  4020e2:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%rbp)
+  4020e9:	75 b2                	jne    40209d <print_num+0x6b>
 
 
 	while(i-- != 0)
-  40036a:	eb 2e                	jmp    40039a <print_num+0xe9>
+  4020eb:	eb 2e                	jmp    40211b <print_num+0xe9>
 	{
 
 		screen[screen_ctr++] = number[i];
-  40036c:	48 8b 05 8d 0c 20 00 	mov    0x200c8d(%rip),%rax        # 601000 <exit+0x20061f>
-  400373:	8b 00                	mov    (%rax),%eax
-  400375:	8d 48 01             	lea    0x1(%rax),%ecx
-  400378:	48 8b 15 81 0c 20 00 	mov    0x200c81(%rip),%rdx        # 601000 <exit+0x20061f>
-  40037f:	89 0a                	mov    %ecx,(%rdx)
-  400381:	8b 55 fc             	mov    -0x4(%rbp),%edx
-  400384:	48 63 d2             	movslq %edx,%rdx
-  400387:	8b 94 95 78 ff ff ff 	mov    -0x88(%rbp,%rdx,4),%edx
-  40038e:	48 8b 0d 73 0c 20 00 	mov    0x200c73(%rip),%rcx        # 601008 <exit+0x200627>
-  400395:	48 98                	cltq   
-  400397:	88 14 01             	mov    %dl,(%rcx,%rax,1)
+  4020ed:	48 8b 05 0c 23 20 00 	mov    0x20230c(%rip),%rax        # 604400 <chdir+0x201188>
+  4020f4:	8b 00                	mov    (%rax),%eax
+  4020f6:	8d 48 01             	lea    0x1(%rax),%ecx
+  4020f9:	48 8b 15 00 23 20 00 	mov    0x202300(%rip),%rdx        # 604400 <chdir+0x201188>
+  402100:	89 0a                	mov    %ecx,(%rdx)
+  402102:	8b 55 fc             	mov    -0x4(%rbp),%edx
+  402105:	48 63 d2             	movslq %edx,%rdx
+  402108:	8b 94 95 78 ff ff ff 	mov    -0x88(%rbp,%rdx,4),%edx
+  40210f:	48 8b 0d f2 22 20 00 	mov    0x2022f2(%rip),%rcx        # 604408 <chdir+0x201190>
+  402116:	48 98                	cltq   
+  402118:	88 14 01             	mov    %dl,(%rcx,%rax,1)
 		number[i]= rem;
 		i++;
 	}while((num=num/base) !=0);
 
 
 	while(i-- != 0)
-  40039a:	8b 45 fc             	mov    -0x4(%rbp),%eax
-  40039d:	8d 50 ff             	lea    -0x1(%rax),%edx
-  4003a0:	89 55 fc             	mov    %edx,-0x4(%rbp)
-  4003a3:	85 c0                	test   %eax,%eax
-  4003a5:	75 c5                	jne    40036c <print_num+0xbb>
+  40211b:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  40211e:	8d 50 ff             	lea    -0x1(%rax),%edx
+  402121:	89 55 fc             	mov    %edx,-0x4(%rbp)
+  402124:	85 c0                	test   %eax,%eax
+  402126:	75 c5                	jne    4020ed <print_num+0xbb>
 	{
 
 		screen[screen_ctr++] = number[i];
 	}
 }
-  4003a7:	c9                   	leaveq 
-  4003a8:	c3                   	retq   
+  402128:	c9                   	leaveq 
+  402129:	c3                   	retq   
 
-00000000004003a9 <print_ptr>:
+000000000040212a <print_ptr>:
 
 
 
 void print_ptr(long unsigned int num, long unsigned int base)
 {
-  4003a9:	55                   	push   %rbp
-  4003aa:	48 89 e5             	mov    %rsp,%rbp
-  4003ad:	48 81 ec 20 01 00 00 	sub    $0x120,%rsp
-  4003b4:	48 89 bd e8 fe ff ff 	mov    %rdi,-0x118(%rbp)
-  4003bb:	48 89 b5 e0 fe ff ff 	mov    %rsi,-0x120(%rbp)
+  40212a:	55                   	push   %rbp
+  40212b:	48 89 e5             	mov    %rsp,%rbp
+  40212e:	48 81 ec 20 01 00 00 	sub    $0x120,%rsp
+  402135:	48 89 bd e8 fe ff ff 	mov    %rdi,-0x118(%rbp)
+  40213c:	48 89 b5 e0 fe ff ff 	mov    %rsi,-0x120(%rbp)
 	long unsigned int number[32];
 	int i=0;
-  4003c2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
+  402143:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
 
 		screen[screen_ctr++] = '0';
-  4003c9:	48 8b 05 30 0c 20 00 	mov    0x200c30(%rip),%rax        # 601000 <exit+0x20061f>
-  4003d0:	8b 00                	mov    (%rax),%eax
-  4003d2:	8d 48 01             	lea    0x1(%rax),%ecx
-  4003d5:	48 8b 15 24 0c 20 00 	mov    0x200c24(%rip),%rdx        # 601000 <exit+0x20061f>
-  4003dc:	89 0a                	mov    %ecx,(%rdx)
-  4003de:	48 8b 15 23 0c 20 00 	mov    0x200c23(%rip),%rdx        # 601008 <exit+0x200627>
-  4003e5:	48 98                	cltq   
-  4003e7:	c6 04 02 30          	movb   $0x30,(%rdx,%rax,1)
+  40214a:	48 8b 05 af 22 20 00 	mov    0x2022af(%rip),%rax        # 604400 <chdir+0x201188>
+  402151:	8b 00                	mov    (%rax),%eax
+  402153:	8d 48 01             	lea    0x1(%rax),%ecx
+  402156:	48 8b 15 a3 22 20 00 	mov    0x2022a3(%rip),%rdx        # 604400 <chdir+0x201188>
+  40215d:	89 0a                	mov    %ecx,(%rdx)
+  40215f:	48 8b 15 a2 22 20 00 	mov    0x2022a2(%rip),%rdx        # 604408 <chdir+0x201190>
+  402166:	48 98                	cltq   
+  402168:	c6 04 02 30          	movb   $0x30,(%rdx,%rax,1)
 		screen[screen_ctr++] = 'x';
-  4003eb:	48 8b 05 0e 0c 20 00 	mov    0x200c0e(%rip),%rax        # 601000 <exit+0x20061f>
-  4003f2:	8b 00                	mov    (%rax),%eax
-  4003f4:	8d 48 01             	lea    0x1(%rax),%ecx
-  4003f7:	48 8b 15 02 0c 20 00 	mov    0x200c02(%rip),%rdx        # 601000 <exit+0x20061f>
-  4003fe:	89 0a                	mov    %ecx,(%rdx)
-  400400:	48 8b 15 01 0c 20 00 	mov    0x200c01(%rip),%rdx        # 601008 <exit+0x200627>
-  400407:	48 98                	cltq   
-  400409:	c6 04 02 78          	movb   $0x78,(%rdx,%rax,1)
+  40216c:	48 8b 05 8d 22 20 00 	mov    0x20228d(%rip),%rax        # 604400 <chdir+0x201188>
+  402173:	8b 00                	mov    (%rax),%eax
+  402175:	8d 48 01             	lea    0x1(%rax),%ecx
+  402178:	48 8b 15 81 22 20 00 	mov    0x202281(%rip),%rdx        # 604400 <chdir+0x201188>
+  40217f:	89 0a                	mov    %ecx,(%rdx)
+  402181:	48 8b 15 80 22 20 00 	mov    0x202280(%rip),%rdx        # 604408 <chdir+0x201190>
+  402188:	48 98                	cltq   
+  40218a:	c6 04 02 78          	movb   $0x78,(%rdx,%rax,1)
 	
 	do
 	{
 		long unsigned int rem=num%base;
-  40040d:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
-  400414:	ba 00 00 00 00       	mov    $0x0,%edx
-  400419:	48 f7 b5 e0 fe ff ff 	divq   -0x120(%rbp)
-  400420:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
+  40218e:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
+  402195:	ba 00 00 00 00       	mov    $0x0,%edx
+  40219a:	48 f7 b5 e0 fe ff ff 	divq   -0x120(%rbp)
+  4021a1:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
 		if((rem) >= 10)
-  400424:	48 83 7d f0 09       	cmpq   $0x9,-0x10(%rbp)
-  400429:	76 07                	jbe    400432 <print_ptr+0x89>
+  4021a5:	48 83 7d f0 09       	cmpq   $0x9,-0x10(%rbp)
+  4021aa:	76 07                	jbe    4021b3 <print_ptr+0x89>
 		{
 			rem = rem-10 + 'a';
-  40042b:	48 83 45 f0 57       	addq   $0x57,-0x10(%rbp)
-  400430:	eb 05                	jmp    400437 <print_ptr+0x8e>
+  4021ac:	48 83 45 f0 57       	addq   $0x57,-0x10(%rbp)
+  4021b1:	eb 05                	jmp    4021b8 <print_ptr+0x8e>
 		}
 		else{
 			rem = rem + '0';
-  400432:	48 83 45 f0 30       	addq   $0x30,-0x10(%rbp)
+  4021b3:	48 83 45 f0 30       	addq   $0x30,-0x10(%rbp)
 		}
 		number[i]= rem;
-  400437:	8b 45 fc             	mov    -0x4(%rbp),%eax
-  40043a:	48 98                	cltq   
-  40043c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
-  400440:	48 89 94 c5 f0 fe ff 	mov    %rdx,-0x110(%rbp,%rax,8)
-  400447:	ff 
+  4021b8:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  4021bb:	48 98                	cltq   
+  4021bd:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
+  4021c1:	48 89 94 c5 f0 fe ff 	mov    %rdx,-0x110(%rbp,%rax,8)
+  4021c8:	ff 
 		i++;
-  400448:	ff 45 fc             	incl   -0x4(%rbp)
+  4021c9:	ff 45 fc             	incl   -0x4(%rbp)
 	}while((num=num/base) !=0);
-  40044b:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
-  400452:	ba 00 00 00 00       	mov    $0x0,%edx
-  400457:	48 f7 b5 e0 fe ff ff 	divq   -0x120(%rbp)
-  40045e:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
-  400465:	48 83 bd e8 fe ff ff 	cmpq   $0x0,-0x118(%rbp)
-  40046c:	00 
-  40046d:	75 9e                	jne    40040d <print_ptr+0x64>
+  4021cc:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
+  4021d3:	ba 00 00 00 00       	mov    $0x0,%edx
+  4021d8:	48 f7 b5 e0 fe ff ff 	divq   -0x120(%rbp)
+  4021df:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
+  4021e6:	48 83 bd e8 fe ff ff 	cmpq   $0x0,-0x118(%rbp)
+  4021ed:	00 
+  4021ee:	75 9e                	jne    40218e <print_ptr+0x64>
 
 
 	while(i-- != 0)
-  40046f:	eb 2f                	jmp    4004a0 <print_ptr+0xf7>
+  4021f0:	eb 2f                	jmp    402221 <print_ptr+0xf7>
 	{
 
 		screen[screen_ctr++] = number[i];
-  400471:	48 8b 05 88 0b 20 00 	mov    0x200b88(%rip),%rax        # 601000 <exit+0x20061f>
-  400478:	8b 00                	mov    (%rax),%eax
-  40047a:	8d 48 01             	lea    0x1(%rax),%ecx
-  40047d:	48 8b 15 7c 0b 20 00 	mov    0x200b7c(%rip),%rdx        # 601000 <exit+0x20061f>
-  400484:	89 0a                	mov    %ecx,(%rdx)
-  400486:	8b 55 fc             	mov    -0x4(%rbp),%edx
-  400489:	48 63 d2             	movslq %edx,%rdx
-  40048c:	48 8b 94 d5 f0 fe ff 	mov    -0x110(%rbp,%rdx,8),%rdx
-  400493:	ff 
-  400494:	48 8b 0d 6d 0b 20 00 	mov    0x200b6d(%rip),%rcx        # 601008 <exit+0x200627>
-  40049b:	48 98                	cltq   
-  40049d:	88 14 01             	mov    %dl,(%rcx,%rax,1)
+  4021f2:	48 8b 05 07 22 20 00 	mov    0x202207(%rip),%rax        # 604400 <chdir+0x201188>
+  4021f9:	8b 00                	mov    (%rax),%eax
+  4021fb:	8d 48 01             	lea    0x1(%rax),%ecx
+  4021fe:	48 8b 15 fb 21 20 00 	mov    0x2021fb(%rip),%rdx        # 604400 <chdir+0x201188>
+  402205:	89 0a                	mov    %ecx,(%rdx)
+  402207:	8b 55 fc             	mov    -0x4(%rbp),%edx
+  40220a:	48 63 d2             	movslq %edx,%rdx
+  40220d:	48 8b 94 d5 f0 fe ff 	mov    -0x110(%rbp,%rdx,8),%rdx
+  402214:	ff 
+  402215:	48 8b 0d ec 21 20 00 	mov    0x2021ec(%rip),%rcx        # 604408 <chdir+0x201190>
+  40221c:	48 98                	cltq   
+  40221e:	88 14 01             	mov    %dl,(%rcx,%rax,1)
 		number[i]= rem;
 		i++;
 	}while((num=num/base) !=0);
 
 
 	while(i-- != 0)
-  4004a0:	8b 45 fc             	mov    -0x4(%rbp),%eax
-  4004a3:	8d 50 ff             	lea    -0x1(%rax),%edx
-  4004a6:	89 55 fc             	mov    %edx,-0x4(%rbp)
-  4004a9:	85 c0                	test   %eax,%eax
-  4004ab:	75 c4                	jne    400471 <print_ptr+0xc8>
+  402221:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  402224:	8d 50 ff             	lea    -0x1(%rax),%edx
+  402227:	89 55 fc             	mov    %edx,-0x4(%rbp)
+  40222a:	85 c0                	test   %eax,%eax
+  40222c:	75 c4                	jne    4021f2 <print_ptr+0xc8>
 	{
 
 		screen[screen_ctr++] = number[i];
     }
 }
-  4004ad:	c9                   	leaveq 
-  4004ae:	c3                   	retq   
+  40222e:	c9                   	leaveq 
+  40222f:	c3                   	retq   
 
-00000000004004af <printf>:
+0000000000402230 <printf>:
 
 
 
 
 
 int printf(const char *format, ...) {
-  4004af:	55                   	push   %rbp
-  4004b0:	48 89 e5             	mov    %rsp,%rbp
-  4004b3:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
-  4004ba:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
-  4004be:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
-  4004c2:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
-  4004c6:	4c 89 45 f0          	mov    %r8,-0x10(%rbp)
-  4004ca:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
-  4004ce:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
+  402230:	55                   	push   %rbp
+  402231:	48 89 e5             	mov    %rsp,%rbp
+  402234:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
+  40223b:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
+  40223f:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
+  402243:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
+  402247:	4c 89 45 f0          	mov    %r8,-0x10(%rbp)
+  40224b:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
+  40224f:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
 	va_list val;
 	int printed = 0;
-  4004d5:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%rbp)
+  402256:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%rbp)
 	screen_ctr=0;
-  4004dc:	48 8b 05 1d 0b 20 00 	mov    0x200b1d(%rip),%rax        # 601000 <exit+0x20061f>
-  4004e3:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
+  40225d:	48 8b 05 9c 21 20 00 	mov    0x20219c(%rip),%rax        # 604400 <chdir+0x201188>
+  402264:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
 	va_start(val, format);
-  4004e9:	c7 45 88 08 00 00 00 	movl   $0x8,-0x78(%rbp)
-  4004f0:	48 8d 45 10          	lea    0x10(%rbp),%rax
-  4004f4:	48 89 45 90          	mov    %rax,-0x70(%rbp)
-  4004f8:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
-  4004fc:	48 89 45 98          	mov    %rax,-0x68(%rbp)
+  40226a:	c7 45 88 08 00 00 00 	movl   $0x8,-0x78(%rbp)
+  402271:	48 8d 45 10          	lea    0x10(%rbp),%rax
+  402275:	48 89 45 90          	mov    %rax,-0x70(%rbp)
+  402279:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
+  40227d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
 
 	while(*format)
-  400500:	e9 0d 03 00 00       	jmpq   400812 <printf+0x363>
+  402281:	e9 0d 03 00 00       	jmpq   402593 <printf+0x363>
 	{
 		if(*format == '%')
-  400505:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
-  40050c:	0f b6 00             	movzbl (%rax),%eax
-  40050f:	3c 25                	cmp    $0x25,%al
-  400511:	0f 85 c6 02 00 00    	jne    4007dd <printf+0x32e>
+  402286:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
+  40228d:	0f b6 00             	movzbl (%rax),%eax
+  402290:	3c 25                	cmp    $0x25,%al
+  402292:	0f 85 c6 02 00 00    	jne    40255e <printf+0x32e>
 		{
 			switch(*(++format))
-  400517:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
-  40051e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
-  400525:	0f b6 00             	movzbl (%rax),%eax
-  400528:	0f be c0             	movsbl %al,%eax
-  40052b:	83 f8 64             	cmp    $0x64,%eax
-  40052e:	74 3c                	je     40056c <printf+0xbd>
-  400530:	83 f8 64             	cmp    $0x64,%eax
-  400533:	7f 17                	jg     40054c <printf+0x9d>
-  400535:	83 f8 25             	cmp    $0x25,%eax
-  400538:	0f 84 73 02 00 00    	je     4007b1 <printf+0x302>
-  40053e:	83 f8 63             	cmp    $0x63,%eax
-  400541:	0f 84 ae 00 00 00    	je     4005f5 <printf+0x146>
-  400547:	e9 c6 02 00 00       	jmpq   400812 <printf+0x363>
-  40054c:	83 f8 73             	cmp    $0x73,%eax
-  40054f:	0f 84 03 01 00 00    	je     400658 <printf+0x1a9>
-  400555:	83 f8 78             	cmp    $0x78,%eax
-  400558:	0f 84 7b 01 00 00    	je     4006d9 <printf+0x22a>
-  40055e:	83 f8 70             	cmp    $0x70,%eax
-  400561:	0f 84 fb 01 00 00    	je     400762 <printf+0x2b3>
-  400567:	e9 a6 02 00 00       	jmpq   400812 <printf+0x363>
+  402298:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
+  40229f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
+  4022a6:	0f b6 00             	movzbl (%rax),%eax
+  4022a9:	0f be c0             	movsbl %al,%eax
+  4022ac:	83 f8 64             	cmp    $0x64,%eax
+  4022af:	74 3c                	je     4022ed <printf+0xbd>
+  4022b1:	83 f8 64             	cmp    $0x64,%eax
+  4022b4:	7f 17                	jg     4022cd <printf+0x9d>
+  4022b6:	83 f8 25             	cmp    $0x25,%eax
+  4022b9:	0f 84 73 02 00 00    	je     402532 <printf+0x302>
+  4022bf:	83 f8 63             	cmp    $0x63,%eax
+  4022c2:	0f 84 ae 00 00 00    	je     402376 <printf+0x146>
+  4022c8:	e9 c6 02 00 00       	jmpq   402593 <printf+0x363>
+  4022cd:	83 f8 73             	cmp    $0x73,%eax
+  4022d0:	0f 84 03 01 00 00    	je     4023d9 <printf+0x1a9>
+  4022d6:	83 f8 78             	cmp    $0x78,%eax
+  4022d9:	0f 84 7b 01 00 00    	je     40245a <printf+0x22a>
+  4022df:	83 f8 70             	cmp    $0x70,%eax
+  4022e2:	0f 84 fb 01 00 00    	je     4024e3 <printf+0x2b3>
+  4022e8:	e9 a6 02 00 00       	jmpq   402593 <printf+0x363>
 			{
 			case 'd':
 				printed=printed;
 				int num = va_arg(val, int);
-  40056c:	8b 45 88             	mov    -0x78(%rbp),%eax
-  40056f:	83 f8 30             	cmp    $0x30,%eax
-  400572:	73 17                	jae    40058b <printf+0xdc>
-  400574:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
-  400578:	8b 45 88             	mov    -0x78(%rbp),%eax
-  40057b:	89 c0                	mov    %eax,%eax
-  40057d:	48 01 d0             	add    %rdx,%rax
-  400580:	8b 55 88             	mov    -0x78(%rbp),%edx
-  400583:	83 c2 08             	add    $0x8,%edx
-  400586:	89 55 88             	mov    %edx,-0x78(%rbp)
-  400589:	eb 0f                	jmp    40059a <printf+0xeb>
-  40058b:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
-  40058f:	48 89 d0             	mov    %rdx,%rax
-  400592:	48 83 c2 08          	add    $0x8,%rdx
-  400596:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
-  40059a:	8b 00                	mov    (%rax),%eax
-  40059c:	89 45 bc             	mov    %eax,-0x44(%rbp)
+  4022ed:	8b 45 88             	mov    -0x78(%rbp),%eax
+  4022f0:	83 f8 30             	cmp    $0x30,%eax
+  4022f3:	73 17                	jae    40230c <printf+0xdc>
+  4022f5:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
+  4022f9:	8b 45 88             	mov    -0x78(%rbp),%eax
+  4022fc:	89 c0                	mov    %eax,%eax
+  4022fe:	48 01 d0             	add    %rdx,%rax
+  402301:	8b 55 88             	mov    -0x78(%rbp),%edx
+  402304:	83 c2 08             	add    $0x8,%edx
+  402307:	89 55 88             	mov    %edx,-0x78(%rbp)
+  40230a:	eb 0f                	jmp    40231b <printf+0xeb>
+  40230c:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
+  402310:	48 89 d0             	mov    %rdx,%rax
+  402313:	48 83 c2 08          	add    $0x8,%rdx
+  402317:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
+  40231b:	8b 00                	mov    (%rax),%eax
+  40231d:	89 45 bc             	mov    %eax,-0x44(%rbp)
 				if(num<0)
-  40059f:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
-  4005a3:	79 35                	jns    4005da <printf+0x12b>
+  402320:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
+  402324:	79 35                	jns    40235b <printf+0x12b>
 				{
 					screen[screen_ctr++]='-';
-  4005a5:	48 8b 05 54 0a 20 00 	mov    0x200a54(%rip),%rax        # 601000 <exit+0x20061f>
-  4005ac:	8b 00                	mov    (%rax),%eax
-  4005ae:	8d 48 01             	lea    0x1(%rax),%ecx
-  4005b1:	48 8b 15 48 0a 20 00 	mov    0x200a48(%rip),%rdx        # 601000 <exit+0x20061f>
-  4005b8:	89 0a                	mov    %ecx,(%rdx)
-  4005ba:	48 8b 15 47 0a 20 00 	mov    0x200a47(%rip),%rdx        # 601008 <exit+0x200627>
-  4005c1:	48 98                	cltq   
-  4005c3:	c6 04 02 2d          	movb   $0x2d,(%rdx,%rax,1)
+  402326:	48 8b 05 d3 20 20 00 	mov    0x2020d3(%rip),%rax        # 604400 <chdir+0x201188>
+  40232d:	8b 00                	mov    (%rax),%eax
+  40232f:	8d 48 01             	lea    0x1(%rax),%ecx
+  402332:	48 8b 15 c7 20 20 00 	mov    0x2020c7(%rip),%rdx        # 604400 <chdir+0x201188>
+  402339:	89 0a                	mov    %ecx,(%rdx)
+  40233b:	48 8b 15 c6 20 20 00 	mov    0x2020c6(%rip),%rdx        # 604408 <chdir+0x201190>
+  402342:	48 98                	cltq   
+  402344:	c6 04 02 2d          	movb   $0x2d,(%rdx,%rax,1)
 					print_num(-num,10);
-  4005c7:	8b 45 bc             	mov    -0x44(%rbp),%eax
-  4005ca:	f7 d8                	neg    %eax
-  4005cc:	be 0a 00 00 00       	mov    $0xa,%esi
-  4005d1:	89 c7                	mov    %eax,%edi
-  4005d3:	e8 d9 fc ff ff       	callq  4002b1 <print_num>
-  4005d8:	eb 0f                	jmp    4005e9 <printf+0x13a>
+  402348:	8b 45 bc             	mov    -0x44(%rbp),%eax
+  40234b:	f7 d8                	neg    %eax
+  40234d:	be 0a 00 00 00       	mov    $0xa,%esi
+  402352:	89 c7                	mov    %eax,%edi
+  402354:	e8 d9 fc ff ff       	callq  402032 <print_num>
+  402359:	eb 0f                	jmp    40236a <printf+0x13a>
 				}
 				else
 					print_num(num,10);
-  4005da:	8b 45 bc             	mov    -0x44(%rbp),%eax
-  4005dd:	be 0a 00 00 00       	mov    $0xa,%esi
-  4005e2:	89 c7                	mov    %eax,%edi
-  4005e4:	e8 c8 fc ff ff       	callq  4002b1 <print_num>
+  40235b:	8b 45 bc             	mov    -0x44(%rbp),%eax
+  40235e:	be 0a 00 00 00       	mov    $0xa,%esi
+  402363:	89 c7                	mov    %eax,%edi
+  402365:	e8 c8 fc ff ff       	callq  402032 <print_num>
 				format++;
-  4005e9:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
+  40236a:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
 				continue;
-  4005f0:	e9 1d 02 00 00       	jmpq   400812 <printf+0x363>
+  402371:	e9 1d 02 00 00       	jmpq   402593 <printf+0x363>
 
 			case 'c':
 				printed=printed;;
 				int chr = va_arg(val, int);
-  4005f5:	8b 45 88             	mov    -0x78(%rbp),%eax
-  4005f8:	83 f8 30             	cmp    $0x30,%eax
-  4005fb:	73 17                	jae    400614 <printf+0x165>
-  4005fd:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
-  400601:	8b 45 88             	mov    -0x78(%rbp),%eax
-  400604:	89 c0                	mov    %eax,%eax
-  400606:	48 01 d0             	add    %rdx,%rax
-  400609:	8b 55 88             	mov    -0x78(%rbp),%edx
-  40060c:	83 c2 08             	add    $0x8,%edx
-  40060f:	89 55 88             	mov    %edx,-0x78(%rbp)
-  400612:	eb 0f                	jmp    400623 <printf+0x174>
-  400614:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
-  400618:	48 89 d0             	mov    %rdx,%rax
-  40061b:	48 83 c2 08          	add    $0x8,%rdx
-  40061f:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
-  400623:	8b 00                	mov    (%rax),%eax
-  400625:	89 45 b8             	mov    %eax,-0x48(%rbp)
+  402376:	8b 45 88             	mov    -0x78(%rbp),%eax
+  402379:	83 f8 30             	cmp    $0x30,%eax
+  40237c:	73 17                	jae    402395 <printf+0x165>
+  40237e:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
+  402382:	8b 45 88             	mov    -0x78(%rbp),%eax
+  402385:	89 c0                	mov    %eax,%eax
+  402387:	48 01 d0             	add    %rdx,%rax
+  40238a:	8b 55 88             	mov    -0x78(%rbp),%edx
+  40238d:	83 c2 08             	add    $0x8,%edx
+  402390:	89 55 88             	mov    %edx,-0x78(%rbp)
+  402393:	eb 0f                	jmp    4023a4 <printf+0x174>
+  402395:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
+  402399:	48 89 d0             	mov    %rdx,%rax
+  40239c:	48 83 c2 08          	add    $0x8,%rdx
+  4023a0:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
+  4023a4:	8b 00                	mov    (%rax),%eax
+  4023a6:	89 45 b8             	mov    %eax,-0x48(%rbp)
 				screen[screen_ctr++] = chr;
-  400628:	48 8b 05 d1 09 20 00 	mov    0x2009d1(%rip),%rax        # 601000 <exit+0x20061f>
-  40062f:	8b 00                	mov    (%rax),%eax
-  400631:	8d 48 01             	lea    0x1(%rax),%ecx
-  400634:	48 8b 15 c5 09 20 00 	mov    0x2009c5(%rip),%rdx        # 601000 <exit+0x20061f>
-  40063b:	89 0a                	mov    %ecx,(%rdx)
-  40063d:	8b 55 b8             	mov    -0x48(%rbp),%edx
-  400640:	48 8b 0d c1 09 20 00 	mov    0x2009c1(%rip),%rcx        # 601008 <exit+0x200627>
-  400647:	48 98                	cltq   
-  400649:	88 14 01             	mov    %dl,(%rcx,%rax,1)
+  4023a9:	48 8b 05 50 20 20 00 	mov    0x202050(%rip),%rax        # 604400 <chdir+0x201188>
+  4023b0:	8b 00                	mov    (%rax),%eax
+  4023b2:	8d 48 01             	lea    0x1(%rax),%ecx
+  4023b5:	48 8b 15 44 20 20 00 	mov    0x202044(%rip),%rdx        # 604400 <chdir+0x201188>
+  4023bc:	89 0a                	mov    %ecx,(%rdx)
+  4023be:	8b 55 b8             	mov    -0x48(%rbp),%edx
+  4023c1:	48 8b 0d 40 20 20 00 	mov    0x202040(%rip),%rcx        # 604408 <chdir+0x201190>
+  4023c8:	48 98                	cltq   
+  4023ca:	88 14 01             	mov    %dl,(%rcx,%rax,1)
 				format++;
-  40064c:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
+  4023cd:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
 				continue;
-  400653:	e9 ba 01 00 00       	jmpq   400812 <printf+0x363>
+  4023d4:	e9 ba 01 00 00       	jmpq   402593 <printf+0x363>
 
 			case 's':
 				printed=printed;
 				char* str = va_arg(val, char*);
-  400658:	8b 45 88             	mov    -0x78(%rbp),%eax
-  40065b:	83 f8 30             	cmp    $0x30,%eax
-  40065e:	73 17                	jae    400677 <printf+0x1c8>
-  400660:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
-  400664:	8b 45 88             	mov    -0x78(%rbp),%eax
-  400667:	89 c0                	mov    %eax,%eax
-  400669:	48 01 d0             	add    %rdx,%rax
-  40066c:	8b 55 88             	mov    -0x78(%rbp),%edx
-  40066f:	83 c2 08             	add    $0x8,%edx
-  400672:	89 55 88             	mov    %edx,-0x78(%rbp)
-  400675:	eb 0f                	jmp    400686 <printf+0x1d7>
-  400677:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
-  40067b:	48 89 d0             	mov    %rdx,%rax
-  40067e:	48 83 c2 08          	add    $0x8,%rdx
-  400682:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
-  400686:	48 8b 00             	mov    (%rax),%rax
-  400689:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
+  4023d9:	8b 45 88             	mov    -0x78(%rbp),%eax
+  4023dc:	83 f8 30             	cmp    $0x30,%eax
+  4023df:	73 17                	jae    4023f8 <printf+0x1c8>
+  4023e1:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
+  4023e5:	8b 45 88             	mov    -0x78(%rbp),%eax
+  4023e8:	89 c0                	mov    %eax,%eax
+  4023ea:	48 01 d0             	add    %rdx,%rax
+  4023ed:	8b 55 88             	mov    -0x78(%rbp),%edx
+  4023f0:	83 c2 08             	add    $0x8,%edx
+  4023f3:	89 55 88             	mov    %edx,-0x78(%rbp)
+  4023f6:	eb 0f                	jmp    402407 <printf+0x1d7>
+  4023f8:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
+  4023fc:	48 89 d0             	mov    %rdx,%rax
+  4023ff:	48 83 c2 08          	add    $0x8,%rdx
+  402403:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
+  402407:	48 8b 00             	mov    (%rax),%rax
+  40240a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
 				while(*(str) != '\0')
-  40068d:	eb 33                	jmp    4006c2 <printf+0x213>
+  40240e:	eb 33                	jmp    402443 <printf+0x213>
 					screen[screen_ctr++] = *str++;
-  40068f:	48 8b 05 6a 09 20 00 	mov    0x20096a(%rip),%rax        # 601000 <exit+0x20061f>
-  400696:	8b 00                	mov    (%rax),%eax
-  400698:	89 c2                	mov    %eax,%edx
-  40069a:	8d 4a 01             	lea    0x1(%rdx),%ecx
-  40069d:	48 8b 05 5c 09 20 00 	mov    0x20095c(%rip),%rax        # 601000 <exit+0x20061f>
-  4006a4:	89 08                	mov    %ecx,(%rax)
-  4006a6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
-  4006aa:	48 8d 48 01          	lea    0x1(%rax),%rcx
-  4006ae:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
-  4006b2:	0f b6 00             	movzbl (%rax),%eax
-  4006b5:	48 8b 0d 4c 09 20 00 	mov    0x20094c(%rip),%rcx        # 601008 <exit+0x200627>
-  4006bc:	48 63 d2             	movslq %edx,%rdx
-  4006bf:	88 04 11             	mov    %al,(%rcx,%rdx,1)
+  402410:	48 8b 05 e9 1f 20 00 	mov    0x201fe9(%rip),%rax        # 604400 <chdir+0x201188>
+  402417:	8b 00                	mov    (%rax),%eax
+  402419:	89 c2                	mov    %eax,%edx
+  40241b:	8d 4a 01             	lea    0x1(%rdx),%ecx
+  40241e:	48 8b 05 db 1f 20 00 	mov    0x201fdb(%rip),%rax        # 604400 <chdir+0x201188>
+  402425:	89 08                	mov    %ecx,(%rax)
+  402427:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
+  40242b:	48 8d 48 01          	lea    0x1(%rax),%rcx
+  40242f:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
+  402433:	0f b6 00             	movzbl (%rax),%eax
+  402436:	48 8b 0d cb 1f 20 00 	mov    0x201fcb(%rip),%rcx        # 604408 <chdir+0x201190>
+  40243d:	48 63 d2             	movslq %edx,%rdx
+  402440:	88 04 11             	mov    %al,(%rcx,%rdx,1)
 				continue;
 
 			case 's':
 				printed=printed;
 				char* str = va_arg(val, char*);
 				while(*(str) != '\0')
-  4006c2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
-  4006c6:	0f b6 00             	movzbl (%rax),%eax
-  4006c9:	84 c0                	test   %al,%al
-  4006cb:	75 c2                	jne    40068f <printf+0x1e0>
+  402443:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
+  402447:	0f b6 00             	movzbl (%rax),%eax
+  40244a:	84 c0                	test   %al,%al
+  40244c:	75 c2                	jne    402410 <printf+0x1e0>
 					screen[screen_ctr++] = *str++;
 				format++;
-  4006cd:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
+  40244e:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
 				continue;
-  4006d4:	e9 39 01 00 00       	jmpq   400812 <printf+0x363>
+  402455:	e9 39 01 00 00       	jmpq   402593 <printf+0x363>
 
 			case 'x':
 				printed=printed;
 				int hex = va_arg(val, int);
-  4006d9:	8b 45 88             	mov    -0x78(%rbp),%eax
-  4006dc:	83 f8 30             	cmp    $0x30,%eax
-  4006df:	73 17                	jae    4006f8 <printf+0x249>
-  4006e1:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
-  4006e5:	8b 45 88             	mov    -0x78(%rbp),%eax
-  4006e8:	89 c0                	mov    %eax,%eax
-  4006ea:	48 01 d0             	add    %rdx,%rax
-  4006ed:	8b 55 88             	mov    -0x78(%rbp),%edx
-  4006f0:	83 c2 08             	add    $0x8,%edx
-  4006f3:	89 55 88             	mov    %edx,-0x78(%rbp)
-  4006f6:	eb 0f                	jmp    400707 <printf+0x258>
-  4006f8:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
-  4006fc:	48 89 d0             	mov    %rdx,%rax
-  4006ff:	48 83 c2 08          	add    $0x8,%rdx
-  400703:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
-  400707:	8b 00                	mov    (%rax),%eax
-  400709:	89 45 b4             	mov    %eax,-0x4c(%rbp)
+  40245a:	8b 45 88             	mov    -0x78(%rbp),%eax
+  40245d:	83 f8 30             	cmp    $0x30,%eax
+  402460:	73 17                	jae    402479 <printf+0x249>
+  402462:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
+  402466:	8b 45 88             	mov    -0x78(%rbp),%eax
+  402469:	89 c0                	mov    %eax,%eax
+  40246b:	48 01 d0             	add    %rdx,%rax
+  40246e:	8b 55 88             	mov    -0x78(%rbp),%edx
+  402471:	83 c2 08             	add    $0x8,%edx
+  402474:	89 55 88             	mov    %edx,-0x78(%rbp)
+  402477:	eb 0f                	jmp    402488 <printf+0x258>
+  402479:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
+  40247d:	48 89 d0             	mov    %rdx,%rax
+  402480:	48 83 c2 08          	add    $0x8,%rdx
+  402484:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
+  402488:	8b 00                	mov    (%rax),%eax
+  40248a:	89 45 b4             	mov    %eax,-0x4c(%rbp)
 				if(hex<0)
-  40070c:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
-  400710:	79 35                	jns    400747 <printf+0x298>
+  40248d:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
+  402491:	79 35                	jns    4024c8 <printf+0x298>
 				{
 					screen[screen_ctr++]='-';
-  400712:	48 8b 05 e7 08 20 00 	mov    0x2008e7(%rip),%rax        # 601000 <exit+0x20061f>
-  400719:	8b 00                	mov    (%rax),%eax
-  40071b:	8d 48 01             	lea    0x1(%rax),%ecx
-  40071e:	48 8b 15 db 08 20 00 	mov    0x2008db(%rip),%rdx        # 601000 <exit+0x20061f>
-  400725:	89 0a                	mov    %ecx,(%rdx)
-  400727:	48 8b 15 da 08 20 00 	mov    0x2008da(%rip),%rdx        # 601008 <exit+0x200627>
-  40072e:	48 98                	cltq   
-  400730:	c6 04 02 2d          	movb   $0x2d,(%rdx,%rax,1)
+  402493:	48 8b 05 66 1f 20 00 	mov    0x201f66(%rip),%rax        # 604400 <chdir+0x201188>
+  40249a:	8b 00                	mov    (%rax),%eax
+  40249c:	8d 48 01             	lea    0x1(%rax),%ecx
+  40249f:	48 8b 15 5a 1f 20 00 	mov    0x201f5a(%rip),%rdx        # 604400 <chdir+0x201188>
+  4024a6:	89 0a                	mov    %ecx,(%rdx)
+  4024a8:	48 8b 15 59 1f 20 00 	mov    0x201f59(%rip),%rdx        # 604408 <chdir+0x201190>
+  4024af:	48 98                	cltq   
+  4024b1:	c6 04 02 2d          	movb   $0x2d,(%rdx,%rax,1)
 					print_num(-hex,16);
-  400734:	8b 45 b4             	mov    -0x4c(%rbp),%eax
-  400737:	f7 d8                	neg    %eax
-  400739:	be 10 00 00 00       	mov    $0x10,%esi
-  40073e:	89 c7                	mov    %eax,%edi
-  400740:	e8 6c fb ff ff       	callq  4002b1 <print_num>
-  400745:	eb 0f                	jmp    400756 <printf+0x2a7>
+  4024b5:	8b 45 b4             	mov    -0x4c(%rbp),%eax
+  4024b8:	f7 d8                	neg    %eax
+  4024ba:	be 10 00 00 00       	mov    $0x10,%esi
+  4024bf:	89 c7                	mov    %eax,%edi
+  4024c1:	e8 6c fb ff ff       	callq  402032 <print_num>
+  4024c6:	eb 0f                	jmp    4024d7 <printf+0x2a7>
 				}
 				else
 					print_num(hex,16);
-  400747:	8b 45 b4             	mov    -0x4c(%rbp),%eax
-  40074a:	be 10 00 00 00       	mov    $0x10,%esi
-  40074f:	89 c7                	mov    %eax,%edi
-  400751:	e8 5b fb ff ff       	callq  4002b1 <print_num>
+  4024c8:	8b 45 b4             	mov    -0x4c(%rbp),%eax
+  4024cb:	be 10 00 00 00       	mov    $0x10,%esi
+  4024d0:	89 c7                	mov    %eax,%edi
+  4024d2:	e8 5b fb ff ff       	callq  402032 <print_num>
 
 				format++;
-  400756:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
+  4024d7:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
 				continue;
-  40075d:	e9 b0 00 00 00       	jmpq   400812 <printf+0x363>
+  4024de:	e9 b0 00 00 00       	jmpq   402593 <printf+0x363>
 
 			case 'p':
 				printed=printed;
 				long unsigned int ptr =(unsigned long int) va_arg(val, long int );
-  400762:	8b 45 88             	mov    -0x78(%rbp),%eax
-  400765:	83 f8 30             	cmp    $0x30,%eax
-  400768:	73 17                	jae    400781 <printf+0x2d2>
-  40076a:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
-  40076e:	8b 45 88             	mov    -0x78(%rbp),%eax
-  400771:	89 c0                	mov    %eax,%eax
-  400773:	48 01 d0             	add    %rdx,%rax
-  400776:	8b 55 88             	mov    -0x78(%rbp),%edx
-  400779:	83 c2 08             	add    $0x8,%edx
-  40077c:	89 55 88             	mov    %edx,-0x78(%rbp)
-  40077f:	eb 0f                	jmp    400790 <printf+0x2e1>
-  400781:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
-  400785:	48 89 d0             	mov    %rdx,%rax
-  400788:	48 83 c2 08          	add    $0x8,%rdx
-  40078c:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
-  400790:	48 8b 00             	mov    (%rax),%rax
-  400793:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
+  4024e3:	8b 45 88             	mov    -0x78(%rbp),%eax
+  4024e6:	83 f8 30             	cmp    $0x30,%eax
+  4024e9:	73 17                	jae    402502 <printf+0x2d2>
+  4024eb:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
+  4024ef:	8b 45 88             	mov    -0x78(%rbp),%eax
+  4024f2:	89 c0                	mov    %eax,%eax
+  4024f4:	48 01 d0             	add    %rdx,%rax
+  4024f7:	8b 55 88             	mov    -0x78(%rbp),%edx
+  4024fa:	83 c2 08             	add    $0x8,%edx
+  4024fd:	89 55 88             	mov    %edx,-0x78(%rbp)
+  402500:	eb 0f                	jmp    402511 <printf+0x2e1>
+  402502:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
+  402506:	48 89 d0             	mov    %rdx,%rax
+  402509:	48 83 c2 08          	add    $0x8,%rdx
+  40250d:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
+  402511:	48 8b 00             	mov    (%rax),%rax
+  402514:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
 				print_ptr(ptr,16);
-  400797:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
-  40079b:	be 10 00 00 00       	mov    $0x10,%esi
-  4007a0:	48 89 c7             	mov    %rax,%rdi
-  4007a3:	e8 01 fc ff ff       	callq  4003a9 <print_ptr>
+  402518:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
+  40251c:	be 10 00 00 00       	mov    $0x10,%esi
+  402521:	48 89 c7             	mov    %rax,%rdi
+  402524:	e8 01 fc ff ff       	callq  40212a <print_ptr>
 
 				format++;
-  4007a8:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
+  402529:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
 				continue;
-  4007af:	eb 61                	jmp    400812 <printf+0x363>
+  402530:	eb 61                	jmp    402593 <printf+0x363>
 
 
 			case '%':
 				printed=printed;
 				char c='%';
-  4007b1:	c6 45 a7 25          	movb   $0x25,-0x59(%rbp)
+  402532:	c6 45 a7 25          	movb   $0x25,-0x59(%rbp)
 
 				screen[screen_ctr++] = c;
-  4007b5:	48 8b 05 44 08 20 00 	mov    0x200844(%rip),%rax        # 601000 <exit+0x20061f>
-  4007bc:	8b 00                	mov    (%rax),%eax
-  4007be:	8d 48 01             	lea    0x1(%rax),%ecx
-  4007c1:	48 8b 15 38 08 20 00 	mov    0x200838(%rip),%rdx        # 601000 <exit+0x20061f>
-  4007c8:	89 0a                	mov    %ecx,(%rdx)
-  4007ca:	48 8b 0d 37 08 20 00 	mov    0x200837(%rip),%rcx        # 601008 <exit+0x200627>
-  4007d1:	48 63 d0             	movslq %eax,%rdx
-  4007d4:	0f b6 45 a7          	movzbl -0x59(%rbp),%eax
-  4007d8:	88 04 11             	mov    %al,(%rcx,%rdx,1)
-  4007db:	eb 35                	jmp    400812 <printf+0x363>
+  402536:	48 8b 05 c3 1e 20 00 	mov    0x201ec3(%rip),%rax        # 604400 <chdir+0x201188>
+  40253d:	8b 00                	mov    (%rax),%eax
+  40253f:	8d 48 01             	lea    0x1(%rax),%ecx
+  402542:	48 8b 15 b7 1e 20 00 	mov    0x201eb7(%rip),%rdx        # 604400 <chdir+0x201188>
+  402549:	89 0a                	mov    %ecx,(%rdx)
+  40254b:	48 8b 0d b6 1e 20 00 	mov    0x201eb6(%rip),%rcx        # 604408 <chdir+0x201190>
+  402552:	48 63 d0             	movslq %eax,%rdx
+  402555:	0f b6 45 a7          	movzbl -0x59(%rbp),%eax
+  402559:	88 04 11             	mov    %al,(%rcx,%rdx,1)
+  40255c:	eb 35                	jmp    402593 <printf+0x363>
 			}
 		}
 		else
 		{
 
 			screen[screen_ctr++] = *format;
-  4007dd:	48 8b 05 1c 08 20 00 	mov    0x20081c(%rip),%rax        # 601000 <exit+0x20061f>
-  4007e4:	8b 00                	mov    (%rax),%eax
-  4007e6:	8d 48 01             	lea    0x1(%rax),%ecx
-  4007e9:	48 8b 15 10 08 20 00 	mov    0x200810(%rip),%rdx        # 601000 <exit+0x20061f>
-  4007f0:	89 0a                	mov    %ecx,(%rdx)
-  4007f2:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
-  4007f9:	0f b6 12             	movzbl (%rdx),%edx
-  4007fc:	48 8b 0d 05 08 20 00 	mov    0x200805(%rip),%rcx        # 601008 <exit+0x200627>
-  400803:	48 98                	cltq   
-  400805:	88 14 01             	mov    %dl,(%rcx,%rax,1)
+  40255e:	48 8b 05 9b 1e 20 00 	mov    0x201e9b(%rip),%rax        # 604400 <chdir+0x201188>
+  402565:	8b 00                	mov    (%rax),%eax
+  402567:	8d 48 01             	lea    0x1(%rax),%ecx
+  40256a:	48 8b 15 8f 1e 20 00 	mov    0x201e8f(%rip),%rdx        # 604400 <chdir+0x201188>
+  402571:	89 0a                	mov    %ecx,(%rdx)
+  402573:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
+  40257a:	0f b6 12             	movzbl (%rdx),%edx
+  40257d:	48 8b 0d 84 1e 20 00 	mov    0x201e84(%rip),%rcx        # 604408 <chdir+0x201190>
+  402584:	48 98                	cltq   
+  402586:	88 14 01             	mov    %dl,(%rcx,%rax,1)
 			++printed;
-  400808:	ff 45 cc             	incl   -0x34(%rbp)
+  402589:	ff 45 cc             	incl   -0x34(%rbp)
 			++format;
-  40080b:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
+  40258c:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
 	va_list val;
 	int printed = 0;
 	screen_ctr=0;
 	va_start(val, format);
 
 	while(*format)
-  400812:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
-  400819:	0f b6 00             	movzbl (%rax),%eax
-  40081c:	84 c0                	test   %al,%al
-  40081e:	0f 85 e1 fc ff ff    	jne    400505 <printf+0x56>
+  402593:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
+  40259a:	0f b6 00             	movzbl (%rax),%eax
+  40259d:	84 c0                	test   %al,%al
+  40259f:	0f 85 e1 fc ff ff    	jne    402286 <printf+0x56>
 			++printed;
 			++format;
 		}
 	}
 
 	printed = write(1,screen, screen_ctr);
-  400824:	48 8b 05 d5 07 20 00 	mov    0x2007d5(%rip),%rax        # 601000 <exit+0x20061f>
-  40082b:	8b 00                	mov    (%rax),%eax
-  40082d:	48 98                	cltq   
-  40082f:	48 89 c2             	mov    %rax,%rdx
-  400832:	48 8b 05 cf 07 20 00 	mov    0x2007cf(%rip),%rax        # 601008 <exit+0x200627>
-  400839:	48 89 c6             	mov    %rax,%rsi
-  40083c:	bf 01 00 00 00       	mov    $0x1,%edi
-  400841:	e8 52 00 00 00       	callq  400898 <write>
-  400846:	89 45 cc             	mov    %eax,-0x34(%rbp)
+  4025a5:	48 8b 05 54 1e 20 00 	mov    0x201e54(%rip),%rax        # 604400 <chdir+0x201188>
+  4025ac:	8b 00                	mov    (%rax),%eax
+  4025ae:	48 98                	cltq   
+  4025b0:	48 89 c2             	mov    %rax,%rdx
+  4025b3:	48 8b 05 4e 1e 20 00 	mov    0x201e4e(%rip),%rax        # 604408 <chdir+0x201190>
+  4025ba:	48 89 c6             	mov    %rax,%rsi
+  4025bd:	bf 01 00 00 00       	mov    $0x1,%edi
+  4025c2:	e8 52 00 00 00       	callq  402619 <write>
+  4025c7:	89 45 cc             	mov    %eax,-0x34(%rbp)
 	if(printed < 0)
-  400849:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
-  40084d:	79 07                	jns    400856 <printf+0x3a7>
+  4025ca:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
+  4025ce:	79 07                	jns    4025d7 <printf+0x3a7>
 		return -1;
-  40084f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-  400854:	eb 09                	jmp    40085f <printf+0x3b0>
+  4025d0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  4025d5:	eb 09                	jmp    4025e0 <printf+0x3b0>
 	return screen_ctr;
-  400856:	48 8b 05 a3 07 20 00 	mov    0x2007a3(%rip),%rax        # 601000 <exit+0x20061f>
-  40085d:	8b 00                	mov    (%rax),%eax
+  4025d7:	48 8b 05 22 1e 20 00 	mov    0x201e22(%rip),%rax        # 604400 <chdir+0x201188>
+  4025de:	8b 00                	mov    (%rax),%eax
+
+}
+  4025e0:	c9                   	leaveq 
+  4025e1:	c3                   	retq   
+
+00000000004025e2 <syscall_3>:
+			"movq %%rax,%0;"
+			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
+	return ret;
+}
+
+static __inline uint64_t syscall_3(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3) {
+  4025e2:	55                   	push   %rbp
+  4025e3:	48 89 e5             	mov    %rsp,%rbp
+  4025e6:	48 83 ec 30          	sub    $0x30,%rsp
+  4025ea:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  4025ee:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+  4025f2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
+  4025f6:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
+
+	uint64_t ret;
+    
+	__asm__("movq %1,%%rax;"
+  4025fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  4025fe:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  402602:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
+  402606:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
+  40260a:	cd 80                	int    $0x80
+  40260c:	48 89 c0             	mov    %rax,%rax
+  40260f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+			"movq %3, %%rsi;"
+			"movq %4, %%rdx;"
+			"int $0x80;"
+			"movq %%rax,%0;"
+			:"=r"(ret):"m"(n),"m"(a1),"m"(a2),"m"(a3));
+	return ret;
+  402613:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+}
+  402617:	c9                   	leaveq 
+  402618:	c3                   	retq   
+
+0000000000402619 <write>:
+#include <stdlib.h>
+#include <stdio.h>
+#include <errno.h>
+
+
+ssize_t write(int fd, const void *buf, size_t count){
+  402619:	55                   	push   %rbp
+  40261a:	48 89 e5             	mov    %rsp,%rbp
+  40261d:	48 83 ec 28          	sub    $0x28,%rsp
+  402621:	89 7d ec             	mov    %edi,-0x14(%rbp)
+  402624:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+  402628:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
+
+	int retvalue=syscall_3(SYS_write,fd,(uint64_t)buf,(uint64_t)count);
+  40262c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
+  402630:	8b 45 ec             	mov    -0x14(%rbp),%eax
+  402633:	48 98                	cltq   
+  402635:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
+  402639:	48 89 c6             	mov    %rax,%rsi
+  40263c:	bf 01 00 00 00       	mov    $0x1,%edi
+  402641:	e8 9c ff ff ff       	callq  4025e2 <syscall_3>
+  402646:	89 45 fc             	mov    %eax,-0x4(%rbp)
+	if(retvalue >=0){
+  402649:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
+  40264d:	78 07                	js     402656 <write+0x3d>
+		return retvalue;
+  40264f:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  402652:	48 98                	cltq   
+  402654:	eb 07                	jmp    40265d <write+0x44>
+	}
+	return -1;
+  402656:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
+}
+  40265d:	c9                   	leaveq 
+  40265e:	c3                   	retq   
 
+000000000040265f <syscall_2>:
+				:"=r"(ret):"m"(n),"m"(a1));
+	}
+	return ret;
 }
-  40085f:	c9                   	leaveq 
-  400860:	c3                   	retq   
 
-0000000000400861 <syscall_3>:
+static __inline uint64_t syscall_2(uint64_t n, uint64_t a1, uint64_t a2) {
+  40265f:	55                   	push   %rbp
+  402660:	48 89 e5             	mov    %rsp,%rbp
+  402663:	48 83 ec 28          	sub    $0x28,%rsp
+  402667:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  40266b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+  40266f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
+
+	uint64_t ret;
+	__asm__("movq %1,%%rax;"
+  402673:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  402677:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  40267b:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
+  40267f:	cd 80                	int    $0x80
+  402681:	48 89 c0             	mov    %rax,%rax
+  402684:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+			"movq %2,%%rdi;"
+			"movq %3,%%rsi;"
+			"int $0x80;"
 			"movq %%rax,%0;"
 			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
 	return ret;
+  402688:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+}
+  40268c:	c9                   	leaveq 
+  40268d:	c3                   	retq   
+
+000000000040268e <opendir>:
+#include<syscall.h>
+#include<string.h>
+
+
+void *opendir(const char *name)
+{
+  40268e:	55                   	push   %rbp
+  40268f:	48 89 e5             	mov    %rsp,%rbp
+  402692:	48 83 ec 20          	sub    $0x20,%rsp
+  402696:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+
+	
+	uint64_t fd=0;
+  40269a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
+  4026a1:	00 
+
+	//WARNING THIS IS A HACK MUST ALLOCATE SPACE FR FD and return it
+
+	fd = (uint64_t)syscall_2(SYS_open, (uint64_t) name, O_DIRECTORY | O_RDONLY);
+  4026a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  4026a6:	ba 00 00 01 00       	mov    $0x10000,%edx
+  4026ab:	48 89 c6             	mov    %rax,%rsi
+  4026ae:	bf 02 00 00 00       	mov    $0x2,%edi
+  4026b3:	e8 a7 ff ff ff       	callq  40265f <syscall_2>
+  4026b8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+
+	
+
+
+	if(fd == -1){
+  4026bc:	48 83 7d f8 ff       	cmpq   $0xffffffffffffffff,-0x8(%rbp)
+  4026c1:	75 1a                	jne    4026dd <opendir+0x4f>
+		printf("No such file or directory\n");
+  4026c3:	48 8d 3d d9 10 00 00 	lea    0x10d9(%rip),%rdi        # 4037a3 <chdir+0x52b>
+  4026ca:	b8 00 00 00 00       	mov    $0x0,%eax
+  4026cf:	e8 5c fb ff ff       	callq  402230 <printf>
+		return (void*)-1;
+  4026d4:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
+  4026db:	eb 04                	jmp    4026e1 <opendir+0x53>
+	}
+
+	return (void*)fd;
+  4026dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 }
+  4026e1:	c9                   	leaveq 
+  4026e2:	c3                   	retq   
+
+00000000004026e3 <syscall_3>:
 
 static __inline uint64_t syscall_3(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3) {
-  400861:	55                   	push   %rbp
-  400862:	48 89 e5             	mov    %rsp,%rbp
-  400865:	48 83 ec 30          	sub    $0x30,%rsp
-  400869:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
-  40086d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
-  400871:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
-  400875:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
+  4026e3:	55                   	push   %rbp
+  4026e4:	48 89 e5             	mov    %rsp,%rbp
+  4026e7:	48 83 ec 30          	sub    $0x30,%rsp
+  4026eb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  4026ef:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+  4026f3:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
+  4026f7:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
 
 	uint64_t ret;
     
 	__asm__("movq %1,%%rax;"
-  400879:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
-  40087d:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
-  400881:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
-  400885:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
-  400889:	cd 80                	int    $0x80
-  40088b:	48 89 c0             	mov    %rax,%rax
-  40088e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+  4026fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  4026ff:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  402703:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
+  402707:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
+  40270b:	cd 80                	int    $0x80
+  40270d:	48 89 c0             	mov    %rax,%rax
+  402710:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 			"movq %3, %%rsi;"
 			"movq %4, %%rdx;"
 			"int $0x80;"
 			"movq %%rax,%0;"
 			:"=r"(ret):"m"(n),"m"(a1),"m"(a2),"m"(a3));
 	return ret;
-  400892:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  402714:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 }
-  400896:	c9                   	leaveq 
-  400897:	c3                   	retq   
+  402718:	c9                   	leaveq 
+  402719:	c3                   	retq   
 
-0000000000400898 <write>:
+000000000040271a <read>:
+#include <sys/syscall.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <errno.h>
 
+ssize_t read(int fd, void *buf, size_t count){
+  40271a:	55                   	push   %rbp
+  40271b:	48 89 e5             	mov    %rsp,%rbp
+  40271e:	48 83 ec 30          	sub    $0x30,%rsp
+  402722:	89 7d ec             	mov    %edi,-0x14(%rbp)
+  402725:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+  402729:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
 
-ssize_t write(int fd, const void *buf, size_t count){
-  400898:	55                   	push   %rbp
-  400899:	48 89 e5             	mov    %rsp,%rbp
-  40089c:	48 83 ec 28          	sub    $0x28,%rsp
-  4008a0:	89 7d ec             	mov    %edi,-0x14(%rbp)
-  4008a3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
-  4008a7:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
+	int retvalue;
+	retvalue =syscall_3(SYS_read,fd,(uint64_t)buf,(uint64_t)count);
+  40272d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
+  402731:	8b 45 ec             	mov    -0x14(%rbp),%eax
+  402734:	48 98                	cltq   
+  402736:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
+  40273a:	48 89 c6             	mov    %rax,%rsi
+  40273d:	bf 00 00 00 00       	mov    $0x0,%edi
+  402742:	e8 9c ff ff ff       	callq  4026e3 <syscall_3>
+  402747:	89 45 fc             	mov    %eax,-0x4(%rbp)
+	
+	if(retvalue < 0 ){
+  40274a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
+  40274e:	79 1a                	jns    40276a <read+0x50>
+		printf("Error in reading File\n");
+  402750:	48 8d 3d 67 10 00 00 	lea    0x1067(%rip),%rdi        # 4037be <chdir+0x546>
+  402757:	b8 00 00 00 00       	mov    $0x0,%eax
+  40275c:	e8 cf fa ff ff       	callq  402230 <printf>
+		return -1;
+  402761:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
+  402768:	eb 05                	jmp    40276f <read+0x55>
+	}
+	
+	return retvalue;
+  40276a:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  40276d:	48 98                	cltq   
+
+}
+  40276f:	c9                   	leaveq 
+  402770:	c3                   	retq   
+
+0000000000402771 <syscall_1>:
+			:"=r"(ret):"m"(n));
+
+	return ret;
+}
+
+static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
+  402771:	55                   	push   %rbp
+  402772:	48 89 e5             	mov    %rsp,%rbp
+  402775:	48 83 ec 20          	sub    $0x20,%rsp
+  402779:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  40277d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+
+	int64_t ret;
+
+	__asm__("movq $78,%r15");
+  402781:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
+	//__asm__("movq %0,%%rax;"
+	//		::"m"(n));
+
+	//while(1);
+
+	if(n==60){
+  402788:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  40278c:	48 83 f8 3c          	cmp    $0x3c,%rax
+  402790:	75 0c                	jne    40279e <syscall_1+0x2d>
+		__asm__("movq %0,%%rax;"
+  402792:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  402796:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  40279a:	cd 80                	int    $0x80
+  40279c:	eb 11                	jmp    4027af <syscall_1+0x3e>
+
+		//while(1);
+	}
+	else{
+
+		__asm__("movq %1,%%rax;"
+  40279e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  4027a2:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  4027a6:	cd 80                	int    $0x80
+  4027a8:	48 89 c0             	mov    %rax,%rax
+  4027ab:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+				"movq %2,%%rdi;"
+				"int $0x80;"
+				"movq %%rax,%0;"
+				:"=r"(ret):"m"(n),"m"(a1));
+	}
+	return ret;
+  4027af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+}
+  4027b3:	c9                   	leaveq 
+  4027b4:	c3                   	retq   
+
+00000000004027b5 <pipe>:
+#include<sys/defs.h>
+#include<sys/syscall.h>
+#include<syscall.h>
+#include<stdlib.h>
+int pipe(int fd[2])
+{
+  4027b5:	55                   	push   %rbp
+  4027b6:	48 89 e5             	mov    %rsp,%rbp
+  4027b9:	48 83 ec 18          	sub    $0x18,%rsp
+  4027bd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+	int retvalue;
+	retvalue = syscall_1(SYS_pipe, (uint64_t)fd);
+  4027c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  4027c5:	48 89 c6             	mov    %rax,%rsi
+  4027c8:	bf 16 00 00 00       	mov    $0x16,%edi
+  4027cd:	e8 9f ff ff ff       	callq  402771 <syscall_1>
+  4027d2:	89 45 fc             	mov    %eax,-0x4(%rbp)
 
-	int retvalue=syscall_3(SYS_write,fd,(uint64_t)buf,(uint64_t)count);
-  4008ab:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
-  4008af:	8b 45 ec             	mov    -0x14(%rbp),%eax
-  4008b2:	48 98                	cltq   
-  4008b4:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
-  4008b8:	48 89 c6             	mov    %rax,%rsi
-  4008bb:	bf 01 00 00 00       	mov    $0x1,%edi
-  4008c0:	e8 9c ff ff ff       	callq  400861 <syscall_3>
-  4008c5:	89 45 fc             	mov    %eax,-0x4(%rbp)
 	if(retvalue >=0){
-  4008c8:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
-  4008cc:	78 07                	js     4008d5 <write+0x3d>
+  4027d5:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
+  4027d9:	78 05                	js     4027e0 <pipe+0x2b>
 		return retvalue;
-  4008ce:	8b 45 fc             	mov    -0x4(%rbp),%eax
-  4008d1:	48 98                	cltq   
-  4008d3:	eb 07                	jmp    4008dc <write+0x44>
+  4027db:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  4027de:	eb 05                	jmp    4027e5 <pipe+0x30>
 	}
+
 	return -1;
-  4008d5:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
+  4027e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 }
-  4008dc:	c9                   	leaveq 
-  4008dd:	c3                   	retq   
+  4027e5:	c9                   	leaveq 
+  4027e6:	c3                   	retq   
 
-00000000004008de <syscall_3>:
+00000000004027e7 <syscall_3>:
 			"movq %%rax,%0;"
 			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
 	return ret;
 }
 
 static __inline uint64_t syscall_3(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3) {
-  4008de:	55                   	push   %rbp
-  4008df:	48 89 e5             	mov    %rsp,%rbp
-  4008e2:	48 83 ec 30          	sub    $0x30,%rsp
-  4008e6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
-  4008ea:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
-  4008ee:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
-  4008f2:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
+  4027e7:	55                   	push   %rbp
+  4027e8:	48 89 e5             	mov    %rsp,%rbp
+  4027eb:	48 83 ec 30          	sub    $0x30,%rsp
+  4027ef:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  4027f3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+  4027f7:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
+  4027fb:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
 
 	uint64_t ret;
     
 	__asm__("movq %1,%%rax;"
-  4008f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
-  4008fa:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
-  4008fe:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
-  400902:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
-  400906:	cd 80                	int    $0x80
-  400908:	48 89 c0             	mov    %rax,%rax
-  40090b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+  4027ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  402803:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  402807:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
+  40280b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
+  40280f:	cd 80                	int    $0x80
+  402811:	48 89 c0             	mov    %rax,%rax
+  402814:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 			"movq %3, %%rsi;"
 			"movq %4, %%rdx;"
 			"int $0x80;"
 			"movq %%rax,%0;"
 			:"=r"(ret):"m"(n),"m"(a1),"m"(a2),"m"(a3));
 	return ret;
-  40090f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  402818:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 }
-  400913:	c9                   	leaveq 
-  400914:	c3                   	retq   
+  40281c:	c9                   	leaveq 
+  40281d:	c3                   	retq   
 
-0000000000400915 <execve>:
+000000000040281e <execve>:
 #include<sys/syscall.h>
 #include<syscall.h>
 #include<stdlib.h>
 
 int execve(const char *filename, char *const argv[], char *const envp[])
 {
-  400915:	55                   	push   %rbp
-  400916:	48 89 e5             	mov    %rsp,%rbp
-  400919:	48 83 ec 28          	sub    $0x28,%rsp
-  40091d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
-  400921:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
-  400925:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
+  40281e:	55                   	push   %rbp
+  40281f:	48 89 e5             	mov    %rsp,%rbp
+  402822:	48 83 ec 28          	sub    $0x28,%rsp
+  402826:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  40282a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+  40282e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
 		int retvalue;
 		retvalue = syscall_3(SYS_execve, (uint64_t)filename, (uint64_t)argv, (uint64_t)envp);
-  400929:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
-  40092d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
-  400931:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
-  400935:	48 89 c6             	mov    %rax,%rsi
-  400938:	bf 3b 00 00 00       	mov    $0x3b,%edi
-  40093d:	e8 9c ff ff ff       	callq  4008de <syscall_3>
-  400942:	89 45 fc             	mov    %eax,-0x4(%rbp)
+  402832:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
+  402836:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
+  40283a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  40283e:	48 89 c6             	mov    %rax,%rsi
+  402841:	bf 3b 00 00 00       	mov    $0x3b,%edi
+  402846:	e8 9c ff ff ff       	callq  4027e7 <syscall_3>
+  40284b:	89 45 fc             	mov    %eax,-0x4(%rbp)
 		if(retvalue >=0){
-  400945:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
-  400949:	78 05                	js     400950 <execve+0x3b>
+  40284e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
+  402852:	78 05                	js     402859 <execve+0x3b>
 			return retvalue;
-  40094b:	8b 45 fc             	mov    -0x4(%rbp),%eax
-  40094e:	eb 05                	jmp    400955 <execve+0x40>
+  402854:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  402857:	eb 05                	jmp    40285e <execve+0x40>
 		}
 		return -1;
-  400950:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  402859:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 
 }
-  400955:	c9                   	leaveq 
-  400956:	c3                   	retq   
+  40285e:	c9                   	leaveq 
+  40285f:	c3                   	retq   
 
-0000000000400957 <syscall_0>:
+0000000000402860 <syscall_0>:
 #define _SYSCALL_H
 
 #include <sys/defs.h>
 #include <sys/syscall.h>
 
 static __inline uint64_t syscall_0(uint64_t n) {
-  400957:	55                   	push   %rbp
-  400958:	48 89 e5             	mov    %rsp,%rbp
-  40095b:	48 83 ec 18          	sub    $0x18,%rsp
-  40095f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  402860:	55                   	push   %rbp
+  402861:	48 89 e5             	mov    %rsp,%rbp
+  402864:	48 83 ec 18          	sub    $0x18,%rsp
+  402868:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 
 	uint64_t ret;
 	__asm__("movq %1,%%rax;"
-  400963:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
-  400967:	cd 80                	int    $0x80
-  400969:	48 89 c0             	mov    %rax,%rax
-  40096c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+  40286c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  402870:	cd 80                	int    $0x80
+  402872:	48 89 c0             	mov    %rax,%rax
+  402875:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 			"int $0x80;"
 			"movq %%rax,%0;"
 			:"=r"(ret):"m"(n));
 
 	return ret;
-  400970:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  402879:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 }
-  400974:	c9                   	leaveq 
-  400975:	c3                   	retq   
+  40287d:	c9                   	leaveq 
+  40287e:	c3                   	retq   
 
-0000000000400976 <fork>:
+000000000040287f <fork>:
 #include <stdio.h>
 #include <errno.h>
 
 
 pid_t fork()
 {
-  400976:	55                   	push   %rbp
-  400977:	48 89 e5             	mov    %rsp,%rbp
-  40097a:	48 83 ec 10          	sub    $0x10,%rsp
+  40287f:	55                   	push   %rbp
+  402880:	48 89 e5             	mov    %rsp,%rbp
+  402883:	48 83 ec 10          	sub    $0x10,%rsp
 	int retvalue;
 
 	retvalue = syscall_0(SYS_fork);
-  40097e:	bf 39 00 00 00       	mov    $0x39,%edi
-  400983:	e8 cf ff ff ff       	callq  400957 <syscall_0>
-  400988:	89 45 fc             	mov    %eax,-0x4(%rbp)
+  402887:	bf 39 00 00 00       	mov    $0x39,%edi
+  40288c:	e8 cf ff ff ff       	callq  402860 <syscall_0>
+  402891:	89 45 fc             	mov    %eax,-0x4(%rbp)
 
 	if(retvalue >=0){
-  40098b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
-  40098f:	78 05                	js     400996 <fork+0x20>
+  402894:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
+  402898:	78 05                	js     40289f <fork+0x20>
 		return retvalue;
-  400991:	8b 45 fc             	mov    -0x4(%rbp),%eax
-  400994:	eb 05                	jmp    40099b <fork+0x25>
+  40289a:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  40289d:	eb 05                	jmp    4028a4 <fork+0x25>
 	}
 	return -1;
-  400996:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  40289f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 
 }
-  40099b:	c9                   	leaveq 
-  40099c:	c3                   	retq   
+  4028a4:	c9                   	leaveq 
+  4028a5:	c3                   	retq   
 
-000000000040099d <syscall_1>:
+00000000004028a6 <syscall_1>:
 
 static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
-  40099d:	55                   	push   %rbp
-  40099e:	48 89 e5             	mov    %rsp,%rbp
-  4009a1:	48 83 ec 20          	sub    $0x20,%rsp
-  4009a5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
-  4009a9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+  4028a6:	55                   	push   %rbp
+  4028a7:	48 89 e5             	mov    %rsp,%rbp
+  4028aa:	48 83 ec 20          	sub    $0x20,%rsp
+  4028ae:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  4028b2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
 
 	int64_t ret;
 
 	__asm__("movq $78,%r15");
-  4009ad:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
+  4028b6:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
 	//__asm__("movq %0,%%rax;"
 	//		::"m"(n));
 
 	//while(1);
 
 	if(n==60){
-  4009b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
-  4009b8:	48 83 f8 3c          	cmp    $0x3c,%rax
-  4009bc:	75 0c                	jne    4009ca <syscall_1+0x2d>
+  4028bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  4028c1:	48 83 f8 3c          	cmp    $0x3c,%rax
+  4028c5:	75 0c                	jne    4028d3 <syscall_1+0x2d>
 		__asm__("movq %0,%%rax;"
-  4009be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
-  4009c2:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
-  4009c6:	cd 80                	int    $0x80
-  4009c8:	eb 11                	jmp    4009db <syscall_1+0x3e>
+  4028c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  4028cb:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  4028cf:	cd 80                	int    $0x80
+  4028d1:	eb 11                	jmp    4028e4 <syscall_1+0x3e>
 
 		//while(1);
 	}
 	else{
 
 		__asm__("movq %1,%%rax;"
-  4009ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
-  4009ce:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
-  4009d2:	cd 80                	int    $0x80
-  4009d4:	48 89 c0             	mov    %rax,%rax
-  4009d7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+  4028d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  4028d7:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  4028db:	cd 80                	int    $0x80
+  4028dd:	48 89 c0             	mov    %rax,%rax
+  4028e0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 				"movq %2,%%rdi;"
 				"int $0x80;"
 				"movq %%rax,%0;"
 				:"=r"(ret):"m"(n),"m"(a1));
 	}
 	return ret;
-  4009db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  4028e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 }
-  4009df:	c9                   	leaveq 
-  4009e0:	c3                   	retq   
+  4028e8:	c9                   	leaveq 
+  4028e9:	c3                   	retq   
 
-00000000004009e1 <exit>:
+00000000004028ea <exit>:
 #include <sys/defs.h>
 #include <syscall.h>
 #include <stdlib.h>
 #include <sys/syscall.h>
 
 void exit(int status){
-  4009e1:	55                   	push   %rbp
-  4009e2:	48 89 e5             	mov    %rsp,%rbp
-  4009e5:	48 83 ec 08          	sub    $0x8,%rsp
-  4009e9:	89 7d fc             	mov    %edi,-0x4(%rbp)
+  4028ea:	55                   	push   %rbp
+  4028eb:	48 89 e5             	mov    %rsp,%rbp
+  4028ee:	48 83 ec 08          	sub    $0x8,%rsp
+  4028f2:	89 7d fc             	mov    %edi,-0x4(%rbp)
 
 	syscall_1(SYS_exit,44);
-  4009ec:	be 2c 00 00 00       	mov    $0x2c,%esi
-  4009f1:	bf 3c 00 00 00       	mov    $0x3c,%edi
-  4009f6:	e8 a2 ff ff ff       	callq  40099d <syscall_1>
+  4028f5:	be 2c 00 00 00       	mov    $0x2c,%esi
+  4028fa:	bf 3c 00 00 00       	mov    $0x3c,%edi
+  4028ff:	e8 a2 ff ff ff       	callq  4028a6 <syscall_1>
+
+
+}
+  402904:	c9                   	leaveq 
+  402905:	c3                   	retq   
+
+0000000000402906 <strlen>:
+#include <errno.h>
+
+
+
+int strlen(const char *str)
+{
+  402906:	55                   	push   %rbp
+  402907:	48 89 e5             	mov    %rsp,%rbp
+  40290a:	48 83 ec 18          	sub    $0x18,%rsp
+  40290e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+	const char *ptr=str;
+  402912:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  402916:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+	for(;*ptr != '\0'; ptr++);
+  40291a:	eb 04                	jmp    402920 <strlen+0x1a>
+  40291c:	48 ff 45 f8          	incq   -0x8(%rbp)
+  402920:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  402924:	0f b6 00             	movzbl (%rax),%eax
+  402927:	84 c0                	test   %al,%al
+  402929:	75 f1                	jne    40291c <strlen+0x16>
+
+	return ptr-str;
+  40292b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
+  40292f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  402933:	48 29 c2             	sub    %rax,%rdx
+  402936:	48 89 d0             	mov    %rdx,%rax
+}
+  402939:	c9                   	leaveq 
+  40293a:	c3                   	retq   
+
+000000000040293b <strcpy>:
+
+char* strcpy(char* dst, const char* src)
+{
+  40293b:	55                   	push   %rbp
+  40293c:	48 89 e5             	mov    %rsp,%rbp
+  40293f:	48 83 ec 30          	sub    $0x30,%rsp
+  402943:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
+  402947:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
+	////printf("In strcpy\n");
+	int i, len=strlen(src);
+  40294b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
+  40294f:	48 89 c7             	mov    %rax,%rdi
+  402952:	e8 af ff ff ff       	callq  402906 <strlen>
+  402957:	89 45 ec             	mov    %eax,-0x14(%rbp)
+	//printf("In strlen.... length of src %d\n",len);
+	char* ptr=dst;
+  40295a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  40295e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
+
+	for(i=0; i<=len; i++)
+  402962:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
+  402969:	eb 21                	jmp    40298c <strcpy+0x51>
+	{
+		*ptr++ = src[i];
+  40296b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  40296f:	48 8d 50 01          	lea    0x1(%rax),%rdx
+  402973:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
+  402977:	8b 55 fc             	mov    -0x4(%rbp),%edx
+  40297a:	48 63 ca             	movslq %edx,%rcx
+  40297d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
+  402981:	48 01 ca             	add    %rcx,%rdx
+  402984:	0f b6 12             	movzbl (%rdx),%edx
+  402987:	88 10                	mov    %dl,(%rax)
+	////printf("In strcpy\n");
+	int i, len=strlen(src);
+	//printf("In strlen.... length of src %d\n",len);
+	char* ptr=dst;
+
+	for(i=0; i<=len; i++)
+  402989:	ff 45 fc             	incl   -0x4(%rbp)
+  40298c:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  40298f:	3b 45 ec             	cmp    -0x14(%rbp),%eax
+  402992:	7e d7                	jle    40296b <strcpy+0x30>
+	{
+		*ptr++ = src[i];
+	}
+	return dst;
+  402994:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+}
+  402998:	c9                   	leaveq 
+  402999:	c3                   	retq   
+
+000000000040299a <strcmp>:
+
+
+int strcmp(const char *str1, const char *str2)
+{
+  40299a:	55                   	push   %rbp
+  40299b:	48 89 e5             	mov    %rsp,%rbp
+  40299e:	48 83 ec 10          	sub    $0x10,%rsp
+  4029a2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
+  4029a6:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
+
+	while(1)
+	{
+		////printf("In strcmp\n");
+
+		if(*str1 != *str2)
+  4029aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  4029ae:	0f b6 10             	movzbl (%rax),%edx
+  4029b1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  4029b5:	0f b6 00             	movzbl (%rax),%eax
+  4029b8:	38 c2                	cmp    %al,%dl
+  4029ba:	74 1a                	je     4029d6 <strcmp+0x3c>
+			return (*str1 - *str2);
+  4029bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  4029c0:	0f b6 00             	movzbl (%rax),%eax
+  4029c3:	0f be d0             	movsbl %al,%edx
+  4029c6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  4029ca:	0f b6 00             	movzbl (%rax),%eax
+  4029cd:	0f be c0             	movsbl %al,%eax
+  4029d0:	29 c2                	sub    %eax,%edx
+  4029d2:	89 d0                	mov    %edx,%eax
+  4029d4:	eb 49                	jmp    402a1f <strcmp+0x85>
+
+		else if((*str1 == *str2) && (*(str1+1) == *(str2 + 1)) && (*(str1 + 1) == '\0'))
+  4029d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  4029da:	0f b6 10             	movzbl (%rax),%edx
+  4029dd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  4029e1:	0f b6 00             	movzbl (%rax),%eax
+  4029e4:	38 c2                	cmp    %al,%dl
+  4029e6:	75 2d                	jne    402a15 <strcmp+0x7b>
+  4029e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  4029ec:	48 ff c0             	inc    %rax
+  4029ef:	0f b6 10             	movzbl (%rax),%edx
+  4029f2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  4029f6:	48 ff c0             	inc    %rax
+  4029f9:	0f b6 00             	movzbl (%rax),%eax
+  4029fc:	38 c2                	cmp    %al,%dl
+  4029fe:	75 15                	jne    402a15 <strcmp+0x7b>
+  402a00:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  402a04:	48 ff c0             	inc    %rax
+  402a07:	0f b6 00             	movzbl (%rax),%eax
+  402a0a:	84 c0                	test   %al,%al
+  402a0c:	75 07                	jne    402a15 <strcmp+0x7b>
+			return 0;
+  402a0e:	b8 00 00 00 00       	mov    $0x0,%eax
+  402a13:	eb 0a                	jmp    402a1f <strcmp+0x85>
+
+
+		str1++;
+  402a15:	48 ff 45 f8          	incq   -0x8(%rbp)
+		str2++;
+  402a19:	48 ff 45 f0          	incq   -0x10(%rbp)
+
+	}
+  402a1d:	eb 8b                	jmp    4029aa <strcmp+0x10>
+
+	return 0;
+}
+  402a1f:	c9                   	leaveq 
+  402a20:	c3                   	retq   
+
+0000000000402a21 <strstr>:
+
+const char *strstr(const char *haystack, const char *needle)
+{
+  402a21:	55                   	push   %rbp
+  402a22:	48 89 e5             	mov    %rsp,%rbp
+  402a25:	48 83 ec 20          	sub    $0x20,%rsp
+  402a29:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  402a2d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+
+	//printf("In strstrt\n %s %s\n\n", haystack,  needle);
+	int len = strlen(haystack), i, j;
+  402a31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  402a35:	48 89 c7             	mov    %rax,%rdi
+  402a38:	e8 c9 fe ff ff       	callq  402906 <strlen>
+  402a3d:	89 45 f4             	mov    %eax,-0xc(%rbp)
+	for(i=0; i< len; i++)
+  402a40:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
+  402a47:	e9 a0 00 00 00       	jmpq   402aec <strstr+0xcb>
+	{
+		for(j = i; j< strlen(needle); j++)
+  402a4c:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  402a4f:	89 45 f8             	mov    %eax,-0x8(%rbp)
+  402a52:	eb 31                	jmp    402a85 <strstr+0x64>
+		{
+			if(*(haystack+i+j) != *(needle+j))
+  402a54:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  402a57:	48 63 d0             	movslq %eax,%rdx
+  402a5a:	8b 45 f8             	mov    -0x8(%rbp),%eax
+  402a5d:	48 98                	cltq   
+  402a5f:	48 01 c2             	add    %rax,%rdx
+  402a62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  402a66:	48 01 d0             	add    %rdx,%rax
+  402a69:	0f b6 10             	movzbl (%rax),%edx
+  402a6c:	8b 45 f8             	mov    -0x8(%rbp),%eax
+  402a6f:	48 63 c8             	movslq %eax,%rcx
+  402a72:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  402a76:	48 01 c8             	add    %rcx,%rax
+  402a79:	0f b6 00             	movzbl (%rax),%eax
+  402a7c:	38 c2                	cmp    %al,%dl
+  402a7e:	74 02                	je     402a82 <strstr+0x61>
+				break;
+  402a80:	eb 14                	jmp    402a96 <strstr+0x75>
+
+	//printf("In strstrt\n %s %s\n\n", haystack,  needle);
+	int len = strlen(haystack), i, j;
+	for(i=0; i< len; i++)
+	{
+		for(j = i; j< strlen(needle); j++)
+  402a82:	ff 45 f8             	incl   -0x8(%rbp)
+  402a85:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  402a89:	48 89 c7             	mov    %rax,%rdi
+  402a8c:	e8 75 fe ff ff       	callq  402906 <strlen>
+  402a91:	3b 45 f8             	cmp    -0x8(%rbp),%eax
+  402a94:	7f be                	jg     402a54 <strstr+0x33>
+		{
+			if(*(haystack+i+j) != *(needle+j))
+				break;
+		}	
+
+		if( (j == strlen(needle) ) && (*(haystack+i+j-1) == *(needle+j-1)))
+  402a96:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  402a9a:	48 89 c7             	mov    %rax,%rdi
+  402a9d:	e8 64 fe ff ff       	callq  402906 <strlen>
+  402aa2:	3b 45 f8             	cmp    -0x8(%rbp),%eax
+  402aa5:	75 42                	jne    402ae9 <strstr+0xc8>
+  402aa7:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  402aaa:	48 63 d0             	movslq %eax,%rdx
+  402aad:	8b 45 f8             	mov    -0x8(%rbp),%eax
+  402ab0:	48 98                	cltq   
+  402ab2:	48 01 d0             	add    %rdx,%rax
+  402ab5:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
+  402ab9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  402abd:	48 01 d0             	add    %rdx,%rax
+  402ac0:	0f b6 10             	movzbl (%rax),%edx
+  402ac3:	8b 45 f8             	mov    -0x8(%rbp),%eax
+  402ac6:	48 98                	cltq   
+  402ac8:	48 8d 48 ff          	lea    -0x1(%rax),%rcx
+  402acc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  402ad0:	48 01 c8             	add    %rcx,%rax
+  402ad3:	0f b6 00             	movzbl (%rax),%eax
+  402ad6:	38 c2                	cmp    %al,%dl
+  402ad8:	75 0f                	jne    402ae9 <strstr+0xc8>
+		{
+			return (haystack + i);
+  402ada:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  402add:	48 63 d0             	movslq %eax,%rdx
+  402ae0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  402ae4:	48 01 d0             	add    %rdx,%rax
+  402ae7:	eb 14                	jmp    402afd <strstr+0xdc>
+const char *strstr(const char *haystack, const char *needle)
+{
+
+	//printf("In strstrt\n %s %s\n\n", haystack,  needle);
+	int len = strlen(haystack), i, j;
+	for(i=0; i< len; i++)
+  402ae9:	ff 45 fc             	incl   -0x4(%rbp)
+  402aec:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  402aef:	3b 45 f4             	cmp    -0xc(%rbp),%eax
+  402af2:	0f 8c 54 ff ff ff    	jl     402a4c <strstr+0x2b>
+		{
+			return (haystack + i);
+		}
+	}
+
+	return NULL;
+  402af8:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  402afd:	c9                   	leaveq 
+  402afe:	c3                   	retq   
+
+0000000000402aff <strcat>:
+
+char *strcat(char *dst, const char *src)
+{
+  402aff:	55                   	push   %rbp
+  402b00:	48 89 e5             	mov    %rsp,%rbp
+  402b03:	48 83 ec 10          	sub    $0x10,%rsp
+  402b07:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
+  402b0b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
+	strcpy(&dst[strlen(dst)],src);
+  402b0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  402b13:	48 89 c7             	mov    %rax,%rdi
+  402b16:	e8 eb fd ff ff       	callq  402906 <strlen>
+  402b1b:	48 63 d0             	movslq %eax,%rdx
+  402b1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  402b22:	48 01 c2             	add    %rax,%rdx
+  402b25:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  402b29:	48 89 c6             	mov    %rax,%rsi
+  402b2c:	48 89 d7             	mov    %rdx,%rdi
+  402b2f:	e8 07 fe ff ff       	callq  40293b <strcpy>
+	//printf("after cat: %s\n\n\n",dst);
+	return dst;
+  402b34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+}
+  402b38:	c9                   	leaveq 
+  402b39:	c3                   	retq   
+
+0000000000402b3a <strerror>:
+
+uint64_t strerror(int err)
+{
+  402b3a:	55                   	push   %rbp
+  402b3b:	48 89 e5             	mov    %rsp,%rbp
+  402b3e:	48 83 ec 10          	sub    $0x10,%rsp
+  402b42:	89 7d fc             	mov    %edi,-0x4(%rbp)
+
+	switch(err)
+  402b45:	83 7d fc 24          	cmpl   $0x24,-0x4(%rbp)
+  402b49:	0f 87 5a 03 00 00    	ja     402ea9 <strerror+0x36f>
+  402b4f:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  402b52:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
+  402b59:	00 
+  402b5a:	48 8d 05 5b 0f 00 00 	lea    0xf5b(%rip),%rax        # 403abc <chdir+0x844>
+  402b61:	8b 04 02             	mov    (%rdx,%rax,1),%eax
+  402b64:	48 63 d0             	movslq %eax,%rdx
+  402b67:	48 8d 05 4e 0f 00 00 	lea    0xf4e(%rip),%rax        # 403abc <chdir+0x844>
+  402b6e:	48 01 d0             	add    %rdx,%rax
+  402b71:	ff e0                	jmpq   *%rax
+	{
+
+	case EPERM    : {return  printf("Operation not permitted \n");break;}
+  402b73:	48 8d 3d 5e 0c 00 00 	lea    0xc5e(%rip),%rdi        # 4037d8 <chdir+0x560>
+  402b7a:	b8 00 00 00 00       	mov    $0x0,%eax
+  402b7f:	e8 ac f6 ff ff       	callq  402230 <printf>
+  402b84:	48 98                	cltq   
+  402b86:	e9 23 03 00 00       	jmpq   402eae <strerror+0x374>
+	case ENOENT   : {return  printf("No such file or directory \n");break;}
+  402b8b:	48 8d 3d 60 0c 00 00 	lea    0xc60(%rip),%rdi        # 4037f2 <chdir+0x57a>
+  402b92:	b8 00 00 00 00       	mov    $0x0,%eax
+  402b97:	e8 94 f6 ff ff       	callq  402230 <printf>
+  402b9c:	48 98                	cltq   
+  402b9e:	e9 0b 03 00 00       	jmpq   402eae <strerror+0x374>
+	case ESRCH    : {return  printf("No such process \n");;break;}
+  402ba3:	48 8d 3d 64 0c 00 00 	lea    0xc64(%rip),%rdi        # 40380e <chdir+0x596>
+  402baa:	b8 00 00 00 00       	mov    $0x0,%eax
+  402baf:	e8 7c f6 ff ff       	callq  402230 <printf>
+  402bb4:	48 98                	cltq   
+  402bb6:	e9 f3 02 00 00       	jmpq   402eae <strerror+0x374>
+	case EINTR    : {return  printf("Interrupted system call \n");break;}
+  402bbb:	48 8d 3d 5e 0c 00 00 	lea    0xc5e(%rip),%rdi        # 403820 <chdir+0x5a8>
+  402bc2:	b8 00 00 00 00       	mov    $0x0,%eax
+  402bc7:	e8 64 f6 ff ff       	callq  402230 <printf>
+  402bcc:	48 98                	cltq   
+  402bce:	e9 db 02 00 00       	jmpq   402eae <strerror+0x374>
+	case EIO      : {return  printf("error \n");;break;}
+  402bd3:	48 8d 3d 60 0c 00 00 	lea    0xc60(%rip),%rdi        # 40383a <chdir+0x5c2>
+  402bda:	b8 00 00 00 00       	mov    $0x0,%eax
+  402bdf:	e8 4c f6 ff ff       	callq  402230 <printf>
+  402be4:	48 98                	cltq   
+  402be6:	e9 c3 02 00 00       	jmpq   402eae <strerror+0x374>
+	case ENXIO    : {return  printf("No such device or address \n");break;}
+  402beb:	48 8d 3d 50 0c 00 00 	lea    0xc50(%rip),%rdi        # 403842 <chdir+0x5ca>
+  402bf2:	b8 00 00 00 00       	mov    $0x0,%eax
+  402bf7:	e8 34 f6 ff ff       	callq  402230 <printf>
+  402bfc:	48 98                	cltq   
+  402bfe:	e9 ab 02 00 00       	jmpq   402eae <strerror+0x374>
+	case E2BIG    : {return  printf("Argument list too long \n");break;}
+  402c03:	48 8d 3d 54 0c 00 00 	lea    0xc54(%rip),%rdi        # 40385e <chdir+0x5e6>
+  402c0a:	b8 00 00 00 00       	mov    $0x0,%eax
+  402c0f:	e8 1c f6 ff ff       	callq  402230 <printf>
+  402c14:	48 98                	cltq   
+  402c16:	e9 93 02 00 00       	jmpq   402eae <strerror+0x374>
+	case ENOEXEC  : {return  printf("Exec format error \n");break;}
+  402c1b:	48 8d 3d 55 0c 00 00 	lea    0xc55(%rip),%rdi        # 403877 <chdir+0x5ff>
+  402c22:	b8 00 00 00 00       	mov    $0x0,%eax
+  402c27:	e8 04 f6 ff ff       	callq  402230 <printf>
+  402c2c:	48 98                	cltq   
+  402c2e:	e9 7b 02 00 00       	jmpq   402eae <strerror+0x374>
+	case EBADF    : {return  printf("Bad file number \n");break;}
+  402c33:	48 8d 3d 51 0c 00 00 	lea    0xc51(%rip),%rdi        # 40388b <chdir+0x613>
+  402c3a:	b8 00 00 00 00       	mov    $0x0,%eax
+  402c3f:	e8 ec f5 ff ff       	callq  402230 <printf>
+  402c44:	48 98                	cltq   
+  402c46:	e9 63 02 00 00       	jmpq   402eae <strerror+0x374>
+	case ECHILD   : {return  printf("No child processes \n");break;}
+  402c4b:	48 8d 3d 4b 0c 00 00 	lea    0xc4b(%rip),%rdi        # 40389d <chdir+0x625>
+  402c52:	b8 00 00 00 00       	mov    $0x0,%eax
+  402c57:	e8 d4 f5 ff ff       	callq  402230 <printf>
+  402c5c:	48 98                	cltq   
+  402c5e:	e9 4b 02 00 00       	jmpq   402eae <strerror+0x374>
+	case EAGAIN   : {return  printf("Try again \n");;break;}
+  402c63:	48 8d 3d 48 0c 00 00 	lea    0xc48(%rip),%rdi        # 4038b2 <chdir+0x63a>
+  402c6a:	b8 00 00 00 00       	mov    $0x0,%eax
+  402c6f:	e8 bc f5 ff ff       	callq  402230 <printf>
+  402c74:	48 98                	cltq   
+  402c76:	e9 33 02 00 00       	jmpq   402eae <strerror+0x374>
+	case ENOMEM   : {return  printf("Out of memory \n");;break;}
+  402c7b:	48 8d 3d 3c 0c 00 00 	lea    0xc3c(%rip),%rdi        # 4038be <chdir+0x646>
+  402c82:	b8 00 00 00 00       	mov    $0x0,%eax
+  402c87:	e8 a4 f5 ff ff       	callq  402230 <printf>
+  402c8c:	48 98                	cltq   
+  402c8e:	e9 1b 02 00 00       	jmpq   402eae <strerror+0x374>
+	case EACCES   : {return  printf("Permission denied \n");break;}
+  402c93:	48 8d 3d 34 0c 00 00 	lea    0xc34(%rip),%rdi        # 4038ce <chdir+0x656>
+  402c9a:	b8 00 00 00 00       	mov    $0x0,%eax
+  402c9f:	e8 8c f5 ff ff       	callq  402230 <printf>
+  402ca4:	48 98                	cltq   
+  402ca6:	e9 03 02 00 00       	jmpq   402eae <strerror+0x374>
+	case EFAULT   : {return  printf("Bad address \n");;break;}
+  402cab:	48 8d 3d 30 0c 00 00 	lea    0xc30(%rip),%rdi        # 4038e2 <chdir+0x66a>
+  402cb2:	b8 00 00 00 00       	mov    $0x0,%eax
+  402cb7:	e8 74 f5 ff ff       	callq  402230 <printf>
+  402cbc:	48 98                	cltq   
+  402cbe:	e9 eb 01 00 00       	jmpq   402eae <strerror+0x374>
+	case ENOTBLK  : {return  printf("Block device required \n");break;}
+  402cc3:	48 8d 3d 26 0c 00 00 	lea    0xc26(%rip),%rdi        # 4038f0 <chdir+0x678>
+  402cca:	b8 00 00 00 00       	mov    $0x0,%eax
+  402ccf:	e8 5c f5 ff ff       	callq  402230 <printf>
+  402cd4:	48 98                	cltq   
+  402cd6:	e9 d3 01 00 00       	jmpq   402eae <strerror+0x374>
+	case EBUSY    : {return  printf("Device or resource busy \n");break;}
+  402cdb:	48 8d 3d 26 0c 00 00 	lea    0xc26(%rip),%rdi        # 403908 <chdir+0x690>
+  402ce2:	b8 00 00 00 00       	mov    $0x0,%eax
+  402ce7:	e8 44 f5 ff ff       	callq  402230 <printf>
+  402cec:	48 98                	cltq   
+  402cee:	e9 bb 01 00 00       	jmpq   402eae <strerror+0x374>
+	case EEXIST   : {return  printf("File exists \n");;break;}
+  402cf3:	48 8d 3d 28 0c 00 00 	lea    0xc28(%rip),%rdi        # 403922 <chdir+0x6aa>
+  402cfa:	b8 00 00 00 00       	mov    $0x0,%eax
+  402cff:	e8 2c f5 ff ff       	callq  402230 <printf>
+  402d04:	48 98                	cltq   
+  402d06:	e9 a3 01 00 00       	jmpq   402eae <strerror+0x374>
+	case EXDEV    : {return  printf("Cross-device link \n");break;}
+  402d0b:	48 8d 3d 1e 0c 00 00 	lea    0xc1e(%rip),%rdi        # 403930 <chdir+0x6b8>
+  402d12:	b8 00 00 00 00       	mov    $0x0,%eax
+  402d17:	e8 14 f5 ff ff       	callq  402230 <printf>
+  402d1c:	48 98                	cltq   
+  402d1e:	e9 8b 01 00 00       	jmpq   402eae <strerror+0x374>
+	case ENODEV   : {return  printf("No such device \n");break;}
+  402d23:	48 8d 3d 1a 0c 00 00 	lea    0xc1a(%rip),%rdi        # 403944 <chdir+0x6cc>
+  402d2a:	b8 00 00 00 00       	mov    $0x0,%eax
+  402d2f:	e8 fc f4 ff ff       	callq  402230 <printf>
+  402d34:	48 98                	cltq   
+  402d36:	e9 73 01 00 00       	jmpq   402eae <strerror+0x374>
+	case ENOTDIR  : {return  printf("Not a directory \n");break;}
+  402d3b:	48 8d 3d 13 0c 00 00 	lea    0xc13(%rip),%rdi        # 403955 <chdir+0x6dd>
+  402d42:	b8 00 00 00 00       	mov    $0x0,%eax
+  402d47:	e8 e4 f4 ff ff       	callq  402230 <printf>
+  402d4c:	48 98                	cltq   
+  402d4e:	e9 5b 01 00 00       	jmpq   402eae <strerror+0x374>
+	case EISDIR   : {return  printf("Is a directory \n");break;}
+  402d53:	48 8d 3d 0d 0c 00 00 	lea    0xc0d(%rip),%rdi        # 403967 <chdir+0x6ef>
+  402d5a:	b8 00 00 00 00       	mov    $0x0,%eax
+  402d5f:	e8 cc f4 ff ff       	callq  402230 <printf>
+  402d64:	48 98                	cltq   
+  402d66:	e9 43 01 00 00       	jmpq   402eae <strerror+0x374>
+	case EINVAL   : {return  printf("Invalid argument \n");break;}
+  402d6b:	48 8d 3d 06 0c 00 00 	lea    0xc06(%rip),%rdi        # 403978 <chdir+0x700>
+  402d72:	b8 00 00 00 00       	mov    $0x0,%eax
+  402d77:	e8 b4 f4 ff ff       	callq  402230 <printf>
+  402d7c:	48 98                	cltq   
+  402d7e:	e9 2b 01 00 00       	jmpq   402eae <strerror+0x374>
+	case ENFILE   : {return  printf("File table overflow \n");break;}
+  402d83:	48 8d 3d 01 0c 00 00 	lea    0xc01(%rip),%rdi        # 40398b <chdir+0x713>
+  402d8a:	b8 00 00 00 00       	mov    $0x0,%eax
+  402d8f:	e8 9c f4 ff ff       	callq  402230 <printf>
+  402d94:	48 98                	cltq   
+  402d96:	e9 13 01 00 00       	jmpq   402eae <strerror+0x374>
+	case EMFILE   : {return  printf("Too many open files \n");break;}
+  402d9b:	48 8d 3d ff 0b 00 00 	lea    0xbff(%rip),%rdi        # 4039a1 <chdir+0x729>
+  402da2:	b8 00 00 00 00       	mov    $0x0,%eax
+  402da7:	e8 84 f4 ff ff       	callq  402230 <printf>
+  402dac:	48 98                	cltq   
+  402dae:	e9 fb 00 00 00       	jmpq   402eae <strerror+0x374>
+	case ENOTTY   : {return  printf("Not a typewriter \n");break;}
+  402db3:	48 8d 3d fd 0b 00 00 	lea    0xbfd(%rip),%rdi        # 4039b7 <chdir+0x73f>
+  402dba:	b8 00 00 00 00       	mov    $0x0,%eax
+  402dbf:	e8 6c f4 ff ff       	callq  402230 <printf>
+  402dc4:	48 98                	cltq   
+  402dc6:	e9 e3 00 00 00       	jmpq   402eae <strerror+0x374>
+	case ETXTBSY  : {return  printf("Text file busy \n");break;}
+  402dcb:	48 8d 3d f8 0b 00 00 	lea    0xbf8(%rip),%rdi        # 4039ca <chdir+0x752>
+  402dd2:	b8 00 00 00 00       	mov    $0x0,%eax
+  402dd7:	e8 54 f4 ff ff       	callq  402230 <printf>
+  402ddc:	48 98                	cltq   
+  402dde:	e9 cb 00 00 00       	jmpq   402eae <strerror+0x374>
+	case EFBIG    : {return  printf("File too large \n");break;}
+  402de3:	48 8d 3d f1 0b 00 00 	lea    0xbf1(%rip),%rdi        # 4039db <chdir+0x763>
+  402dea:	b8 00 00 00 00       	mov    $0x0,%eax
+  402def:	e8 3c f4 ff ff       	callq  402230 <printf>
+  402df4:	48 98                	cltq   
+  402df6:	e9 b3 00 00 00       	jmpq   402eae <strerror+0x374>
+	case ENOSPC   : {return  printf("No space left on device \n");break;}
+  402dfb:	48 8d 3d ea 0b 00 00 	lea    0xbea(%rip),%rdi        # 4039ec <chdir+0x774>
+  402e02:	b8 00 00 00 00       	mov    $0x0,%eax
+  402e07:	e8 24 f4 ff ff       	callq  402230 <printf>
+  402e0c:	48 98                	cltq   
+  402e0e:	e9 9b 00 00 00       	jmpq   402eae <strerror+0x374>
+	case ESPIPE   : {return  printf("Illegal seek \n");break;}
+  402e13:	48 8d 3d ec 0b 00 00 	lea    0xbec(%rip),%rdi        # 403a06 <chdir+0x78e>
+  402e1a:	b8 00 00 00 00       	mov    $0x0,%eax
+  402e1f:	e8 0c f4 ff ff       	callq  402230 <printf>
+  402e24:	48 98                	cltq   
+  402e26:	e9 83 00 00 00       	jmpq   402eae <strerror+0x374>
+	case EROFS    : {return  printf("Read-only file system \n");break;}
+  402e2b:	48 8d 3d e3 0b 00 00 	lea    0xbe3(%rip),%rdi        # 403a15 <chdir+0x79d>
+  402e32:	b8 00 00 00 00       	mov    $0x0,%eax
+  402e37:	e8 f4 f3 ff ff       	callq  402230 <printf>
+  402e3c:	48 98                	cltq   
+  402e3e:	eb 6e                	jmp    402eae <strerror+0x374>
+	case EMLINK   : {return  printf("Too many links \n");break;}
+  402e40:	48 8d 3d e6 0b 00 00 	lea    0xbe6(%rip),%rdi        # 403a2d <chdir+0x7b5>
+  402e47:	b8 00 00 00 00       	mov    $0x0,%eax
+  402e4c:	e8 df f3 ff ff       	callq  402230 <printf>
+  402e51:	48 98                	cltq   
+  402e53:	eb 59                	jmp    402eae <strerror+0x374>
+	case EPIPE    : {return  printf("Broken pipe \n");break;}
+  402e55:	48 8d 3d e2 0b 00 00 	lea    0xbe2(%rip),%rdi        # 403a3e <chdir+0x7c6>
+  402e5c:	b8 00 00 00 00       	mov    $0x0,%eax
+  402e61:	e8 ca f3 ff ff       	callq  402230 <printf>
+  402e66:	48 98                	cltq   
+  402e68:	eb 44                	jmp    402eae <strerror+0x374>
+	case EDOM     : {return  printf("Math argument out of domain of func \n");break;}
+  402e6a:	48 8d 3d df 0b 00 00 	lea    0xbdf(%rip),%rdi        # 403a50 <chdir+0x7d8>
+  402e71:	b8 00 00 00 00       	mov    $0x0,%eax
+  402e76:	e8 b5 f3 ff ff       	callq  402230 <printf>
+  402e7b:	48 98                	cltq   
+  402e7d:	eb 2f                	jmp    402eae <strerror+0x374>
+	case ERANGE   : {return  printf("Math result not representable \n");break;}
+  402e7f:	48 8d 3d f2 0b 00 00 	lea    0xbf2(%rip),%rdi        # 403a78 <chdir+0x800>
+  402e86:	b8 00 00 00 00       	mov    $0x0,%eax
+  402e8b:	e8 a0 f3 ff ff       	callq  402230 <printf>
+  402e90:	48 98                	cltq   
+  402e92:	eb 1a                	jmp    402eae <strerror+0x374>
+	case ENAMETOOLONG:	{return printf(" The path is too long to search \n");break;}
+  402e94:	48 8d 3d fd 0b 00 00 	lea    0xbfd(%rip),%rdi        # 403a98 <chdir+0x820>
+  402e9b:	b8 00 00 00 00       	mov    $0x0,%eax
+  402ea0:	e8 8b f3 ff ff       	callq  402230 <printf>
+  402ea5:	48 98                	cltq   
+  402ea7:	eb 05                	jmp    402eae <strerror+0x374>
+	
+	//return printf("error occured.\n");
+	}
+return 0;
+  402ea9:	b8 00 00 00 00       	mov    $0x0,%eax
+  402eae:	c9                   	leaveq 
+  402eaf:	c3                   	retq   
+
+0000000000402eb0 <syscall_1>:
+			:"=r"(ret):"m"(n));
+
+	return ret;
+}
+
+static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
+  402eb0:	55                   	push   %rbp
+  402eb1:	48 89 e5             	mov    %rsp,%rbp
+  402eb4:	48 83 ec 20          	sub    $0x20,%rsp
+  402eb8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  402ebc:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+
+	int64_t ret;
+
+	__asm__("movq $78,%r15");
+  402ec0:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
+	//__asm__("movq %0,%%rax;"
+	//		::"m"(n));
+
+	//while(1);
+
+	if(n==60){
+  402ec7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  402ecb:	48 83 f8 3c          	cmp    $0x3c,%rax
+  402ecf:	75 0c                	jne    402edd <syscall_1+0x2d>
+		__asm__("movq %0,%%rax;"
+  402ed1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  402ed5:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  402ed9:	cd 80                	int    $0x80
+  402edb:	eb 11                	jmp    402eee <syscall_1+0x3e>
+
+		//while(1);
+	}
+	else{
+
+		__asm__("movq %1,%%rax;"
+  402edd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  402ee1:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  402ee5:	cd 80                	int    $0x80
+  402ee7:	48 89 c0             	mov    %rax,%rax
+  402eea:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+				"movq %2,%%rdi;"
+				"int $0x80;"
+				"movq %%rax,%0;"
+				:"=r"(ret):"m"(n),"m"(a1));
+	}
+	return ret;
+  402eee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+}
+  402ef2:	c9                   	leaveq 
+  402ef3:	c3                   	retq   
+
+0000000000402ef4 <make_head>:
+
+enum {NEW_MCB, NO_MCB, REUSE_MCB};
+enum {FREE, IN_USE};
+
+void make_head(char *addr, int size) 
+{
+  402ef4:	55                   	push   %rbp
+  402ef5:	48 89 e5             	mov    %rsp,%rbp
+  402ef8:	48 83 ec 1c          	sub    $0x1c,%rsp
+  402efc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  402f00:	89 75 e4             	mov    %esi,-0x1c(%rbp)
+    MCB_P head         = (MCB_P)addr;
+  402f03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  402f07:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+    head->is_available = FREE;
+  402f0b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  402f0f:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
+    head->size         = size;
+  402f15:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  402f19:	8b 55 e4             	mov    -0x1c(%rbp),%edx
+  402f1c:	89 50 04             	mov    %edx,0x4(%rax)
+}
+  402f1f:	c9                   	leaveq 
+  402f20:	c3                   	retq   
+
+0000000000402f21 <alloc_new>:
+
+void *alloc_new(int aligned_size)
+{
+  402f21:	55                   	push   %rbp
+  402f22:	48 89 e5             	mov    %rsp,%rbp
+  402f25:	48 83 ec 30          	sub    $0x30,%rsp
+  402f29:	89 7d dc             	mov    %edi,-0x24(%rbp)
+    char *add;
+    uint64_t no_of_pages = 0, sz;    
+  402f2c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
+  402f33:	00 
+    MCB_P p_mcb;
+    
+    sz          = sizeof(MCB_t);
+  402f34:	48 c7 45 f0 08 00 00 	movq   $0x8,-0x10(%rbp)
+  402f3b:	00 
+    no_of_pages = (aligned_size + sz) /(PAGESIZE + 1) + 1;
+  402f3c:	8b 45 dc             	mov    -0x24(%rbp),%eax
+  402f3f:	48 63 d0             	movslq %eax,%rdx
+  402f42:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  402f46:	48 01 d0             	add    %rdx,%rax
+  402f49:	48 ba f1 ff 00 f0 ff 	movabs $0xfff000fff000fff1,%rdx
+  402f50:	00 f0 ff 
+  402f53:	48 f7 e2             	mul    %rdx
+  402f56:	48 89 d0             	mov    %rdx,%rax
+  402f59:	48 c1 e8 0c          	shr    $0xc,%rax
+  402f5d:	48 ff c0             	inc    %rax
+  402f60:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+    add = (char*)syscall_1(SYS_brk, (uint64_t)no_of_pages*4096);    
+  402f64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  402f68:	48 c1 e0 0c          	shl    $0xc,%rax
+  402f6c:	48 89 c6             	mov    %rax,%rsi
+  402f6f:	bf 0c 00 00 00       	mov    $0xc,%edi
+  402f74:	e8 37 ff ff ff       	callq  402eb0 <syscall_1>
+  402f79:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
+
+    if (heap_end == 0) {
+  402f7d:	48 8b 05 ac 15 20 00 	mov    0x2015ac(%rip),%rax        # 604530 <heap_end>
+  402f84:	48 85 c0             	test   %rax,%rax
+  402f87:	75 2a                	jne    402fb3 <alloc_new+0x92>
+        mem_start_p   = add;
+  402f89:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  402f8d:	48 89 05 94 15 20 00 	mov    %rax,0x201594(%rip)        # 604528 <mem_start_p>
+        mcb_count     = 0;
+  402f94:	c7 05 a2 15 20 00 00 	movl   $0x0,0x2015a2(%rip)        # 604540 <mcb_count>
+  402f9b:	00 00 00 
+        allocated_mem = 0;
+  402f9e:	c7 05 94 15 20 00 00 	movl   $0x0,0x201594(%rip)        # 60453c <allocated_mem>
+  402fa5:	00 00 00 
+        heap_end = add; 
+  402fa8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  402fac:	48 89 05 7d 15 20 00 	mov    %rax,0x20157d(%rip)        # 604530 <heap_end>
+    }
+    
+    heap_end = (char*)((uint64_t)add + (uint64_t)(PAGESIZE * no_of_pages));
+  402fb3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  402fb7:	48 c1 e0 0c          	shl    $0xc,%rax
+  402fbb:	48 89 c2             	mov    %rax,%rdx
+  402fbe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  402fc2:	48 01 d0             	add    %rdx,%rax
+  402fc5:	48 89 05 64 15 20 00 	mov    %rax,0x201564(%rip)        # 604530 <heap_end>
+    max_mem += PAGESIZE * no_of_pages; 
+  402fcc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  402fd0:	c1 e0 0c             	shl    $0xc,%eax
+  402fd3:	89 c2                	mov    %eax,%edx
+  402fd5:	8b 05 5d 15 20 00    	mov    0x20155d(%rip),%eax        # 604538 <max_mem>
+  402fdb:	01 d0                	add    %edx,%eax
+  402fdd:	89 05 55 15 20 00    	mov    %eax,0x201555(%rip)        # 604538 <max_mem>
+    
+    p_mcb               = (MCB_P)add; 
+  402fe3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  402fe7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
+    p_mcb->is_available = IN_USE;
+  402feb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  402fef:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
+    p_mcb->size         = aligned_size + sz; 
+  402ff5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  402ff9:	89 c2                	mov    %eax,%edx
+  402ffb:	8b 45 dc             	mov    -0x24(%rbp),%eax
+  402ffe:	01 d0                	add    %edx,%eax
+  403000:	89 c2                	mov    %eax,%edx
+  403002:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
+  403006:	89 50 04             	mov    %edx,0x4(%rax)
+    mcb_count++;    
+  403009:	8b 05 31 15 20 00    	mov    0x201531(%rip),%eax        # 604540 <mcb_count>
+  40300f:	ff c0                	inc    %eax
+  403011:	89 05 29 15 20 00    	mov    %eax,0x201529(%rip)        # 604540 <mcb_count>
+
+    if (PAGESIZE * no_of_pages > aligned_size + sz) {
+  403017:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  40301b:	48 c1 e0 0c          	shl    $0xc,%rax
+  40301f:	48 89 c1             	mov    %rax,%rcx
+  403022:	8b 45 dc             	mov    -0x24(%rbp),%eax
+  403025:	48 63 d0             	movslq %eax,%rdx
+  403028:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  40302c:	48 01 d0             	add    %rdx,%rax
+  40302f:	48 39 c1             	cmp    %rax,%rcx
+  403032:	76 34                	jbe    403068 <alloc_new+0x147>
+        make_head(((char *)p_mcb + aligned_size + sz), (PAGESIZE * no_of_pages - aligned_size - sz));
+  403034:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  403038:	c1 e0 0c             	shl    $0xc,%eax
+  40303b:	89 c2                	mov    %eax,%edx
+  40303d:	8b 45 dc             	mov    -0x24(%rbp),%eax
+  403040:	29 c2                	sub    %eax,%edx
+  403042:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  403046:	29 c2                	sub    %eax,%edx
+  403048:	89 d0                	mov    %edx,%eax
+  40304a:	8b 55 dc             	mov    -0x24(%rbp),%edx
+  40304d:	48 63 ca             	movslq %edx,%rcx
+  403050:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
+  403054:	48 01 d1             	add    %rdx,%rcx
+  403057:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
+  40305b:	48 01 ca             	add    %rcx,%rdx
+  40305e:	89 c6                	mov    %eax,%esi
+  403060:	48 89 d7             	mov    %rdx,%rdi
+  403063:	e8 8c fe ff ff       	callq  402ef4 <make_head>
+    }
+
+    allocated_mem += aligned_size; 
+  403068:	8b 15 ce 14 20 00    	mov    0x2014ce(%rip),%edx        # 60453c <allocated_mem>
+  40306e:	8b 45 dc             	mov    -0x24(%rbp),%eax
+  403071:	01 d0                	add    %edx,%eax
+  403073:	89 05 c3 14 20 00    	mov    %eax,0x2014c3(%rip)        # 60453c <allocated_mem>
+    
+    return ((void *) p_mcb + sz);
+  403079:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
+  40307d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
+  403081:	48 01 d0             	add    %rdx,%rax
+}
+  403084:	c9                   	leaveq 
+  403085:	c3                   	retq   
+
+0000000000403086 <malloc>:
+
+void* malloc(size_t elem_size)
+{
+  403086:	55                   	push   %rbp
+  403087:	48 89 e5             	mov    %rsp,%rbp
+  40308a:	48 83 ec 30          	sub    $0x30,%rsp
+  40308e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
+    MCB_P p_mcb;
+    int flag, sz, temp = 0, aligned_size;
+  403092:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
+
+    // Align elem_size to header size
+    aligned_size = ((((elem_size - 1) >> 3) + 1) << 3);
+  403099:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
+  40309d:	48 ff c8             	dec    %rax
+  4030a0:	48 c1 e8 03          	shr    $0x3,%rax
+  4030a4:	48 ff c0             	inc    %rax
+  4030a7:	48 c1 e0 03          	shl    $0x3,%rax
+  4030ab:	89 45 ec             	mov    %eax,-0x14(%rbp)
+
+    if (heap_end == 0) {
+  4030ae:	48 8b 05 7b 14 20 00 	mov    0x20147b(%rip),%rax        # 604530 <heap_end>
+  4030b5:	48 85 c0             	test   %rax,%rax
+  4030b8:	75 0f                	jne    4030c9 <malloc+0x43>
+        /*no heap has been assigned yet*/
+        return alloc_new(aligned_size);
+  4030ba:	8b 45 ec             	mov    -0x14(%rbp),%eax
+  4030bd:	89 c7                	mov    %eax,%edi
+  4030bf:	e8 5d fe ff ff       	callq  402f21 <alloc_new>
+  4030c4:	e9 1a 01 00 00       	jmpq   4031e3 <malloc+0x15d>
+    } else {
+
+        flag  = NO_MCB;
+  4030c9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
+        p_mcb = (MCB_P)mem_start_p;
+  4030d0:	48 8b 05 51 14 20 00 	mov    0x201451(%rip),%rax        # 604528 <mem_start_p>
+  4030d7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+        sz    = sizeof(MCB_t);
+  4030db:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%rbp)
+
+        //printf("\nheap_end : %p\treqd size: %p",heap_end, ((char *)p_mcb + aligned_size + sz));
+        while (heap_end >= ((char *)p_mcb + aligned_size + sz)) {
+  4030e2:	eb 33                	jmp    403117 <malloc+0x91>
+            if (p_mcb->is_available == FREE) {
+  4030e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  4030e8:	8b 00                	mov    (%rax),%eax
+  4030ea:	85 c0                	test   %eax,%eax
+  4030ec:	75 1c                	jne    40310a <malloc+0x84>
+                if (p_mcb->size >= (aligned_size + sz)) {
+  4030ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  4030f2:	8b 40 04             	mov    0x4(%rax),%eax
+  4030f5:	8b 55 e8             	mov    -0x18(%rbp),%edx
+  4030f8:	8b 4d ec             	mov    -0x14(%rbp),%ecx
+  4030fb:	01 ca                	add    %ecx,%edx
+  4030fd:	39 d0                	cmp    %edx,%eax
+  4030ff:	7c 09                	jl     40310a <malloc+0x84>
+                    flag = REUSE_MCB;
+  403101:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%rbp)
+                    break;
+  403108:	eb 2e                	jmp    403138 <malloc+0xb2>
+                }
+            }
+            p_mcb = (MCB_P) ((char *)p_mcb + p_mcb->size);
+  40310a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  40310e:	8b 40 04             	mov    0x4(%rax),%eax
+  403111:	48 98                	cltq   
+  403113:	48 01 45 f8          	add    %rax,-0x8(%rbp)
+        flag  = NO_MCB;
+        p_mcb = (MCB_P)mem_start_p;
+        sz    = sizeof(MCB_t);
+
+        //printf("\nheap_end : %p\treqd size: %p",heap_end, ((char *)p_mcb + aligned_size + sz));
+        while (heap_end >= ((char *)p_mcb + aligned_size + sz)) {
+  403117:	8b 45 ec             	mov    -0x14(%rbp),%eax
+  40311a:	48 63 d0             	movslq %eax,%rdx
+  40311d:	8b 45 e8             	mov    -0x18(%rbp),%eax
+  403120:	48 98                	cltq   
+  403122:	48 01 c2             	add    %rax,%rdx
+  403125:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  403129:	48 01 c2             	add    %rax,%rdx
+  40312c:	48 8b 05 fd 13 20 00 	mov    0x2013fd(%rip),%rax        # 604530 <heap_end>
+  403133:	48 39 c2             	cmp    %rax,%rdx
+  403136:	76 ac                	jbe    4030e4 <malloc+0x5e>
+                }
+            }
+            p_mcb = (MCB_P) ((char *)p_mcb + p_mcb->size);
+        }
+
+        if (flag != NO_MCB) {
+  403138:	83 7d f4 01          	cmpl   $0x1,-0xc(%rbp)
+  40313c:	0f 84 97 00 00 00    	je     4031d9 <malloc+0x153>
+            p_mcb->is_available = IN_USE;
+  403142:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  403146:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
+
+            if (flag == REUSE_MCB) {
+  40314c:	83 7d f4 02          	cmpl   $0x2,-0xc(%rbp)
+  403150:	75 67                	jne    4031b9 <malloc+0x133>
+                if (p_mcb->size > aligned_size + sz) {
+  403152:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  403156:	8b 40 04             	mov    0x4(%rax),%eax
+  403159:	8b 55 e8             	mov    -0x18(%rbp),%edx
+  40315c:	8b 4d ec             	mov    -0x14(%rbp),%ecx
+  40315f:	01 ca                	add    %ecx,%edx
+  403161:	39 d0                	cmp    %edx,%eax
+  403163:	7e 46                	jle    4031ab <malloc+0x125>
+                    temp        = p_mcb->size; 
+  403165:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  403169:	8b 40 04             	mov    0x4(%rax),%eax
+  40316c:	89 45 f0             	mov    %eax,-0x10(%rbp)
+                    p_mcb->size = aligned_size + sz;
+  40316f:	8b 45 e8             	mov    -0x18(%rbp),%eax
+  403172:	8b 55 ec             	mov    -0x14(%rbp),%edx
+  403175:	01 c2                	add    %eax,%edx
+  403177:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  40317b:	89 50 04             	mov    %edx,0x4(%rax)
+
+                    make_head(((char *)p_mcb + aligned_size + sz),(temp - aligned_size - sz));
+  40317e:	8b 45 ec             	mov    -0x14(%rbp),%eax
+  403181:	8b 55 f0             	mov    -0x10(%rbp),%edx
+  403184:	29 c2                	sub    %eax,%edx
+  403186:	89 d0                	mov    %edx,%eax
+  403188:	2b 45 e8             	sub    -0x18(%rbp),%eax
+  40318b:	8b 55 ec             	mov    -0x14(%rbp),%edx
+  40318e:	48 63 ca             	movslq %edx,%rcx
+  403191:	8b 55 e8             	mov    -0x18(%rbp),%edx
+  403194:	48 63 d2             	movslq %edx,%rdx
+  403197:	48 01 d1             	add    %rdx,%rcx
+  40319a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
+  40319e:	48 01 ca             	add    %rcx,%rdx
+  4031a1:	89 c6                	mov    %eax,%esi
+  4031a3:	48 89 d7             	mov    %rdx,%rdi
+  4031a6:	e8 49 fd ff ff       	callq  402ef4 <make_head>
+                }        
+                mcb_count++;
+  4031ab:	8b 05 8f 13 20 00    	mov    0x20138f(%rip),%eax        # 604540 <mcb_count>
+  4031b1:	ff c0                	inc    %eax
+  4031b3:	89 05 87 13 20 00    	mov    %eax,0x201387(%rip)        # 604540 <mcb_count>
+            }
+            allocated_mem += aligned_size;
+  4031b9:	8b 15 7d 13 20 00    	mov    0x20137d(%rip),%edx        # 60453c <allocated_mem>
+  4031bf:	8b 45 ec             	mov    -0x14(%rbp),%eax
+  4031c2:	01 d0                	add    %edx,%eax
+  4031c4:	89 05 72 13 20 00    	mov    %eax,0x201372(%rip)        # 60453c <allocated_mem>
+            return ((char *) p_mcb + sz);
+  4031ca:	8b 45 e8             	mov    -0x18(%rbp),%eax
+  4031cd:	48 63 d0             	movslq %eax,%rdx
+  4031d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  4031d4:	48 01 d0             	add    %rdx,%rax
+  4031d7:	eb 0a                	jmp    4031e3 <malloc+0x15d>
+        }
+
+        /*when no hole is found to match the request*/
+        return alloc_new(aligned_size); 
+  4031d9:	8b 45 ec             	mov    -0x14(%rbp),%eax
+  4031dc:	89 c7                	mov    %eax,%edi
+  4031de:	e8 3e fd ff ff       	callq  402f21 <alloc_new>
+    }
+
+}
+  4031e3:	c9                   	leaveq 
+  4031e4:	c3                   	retq   
+
+00000000004031e5 <free>:
+
+void free(void *p)
+{
+  4031e5:	55                   	push   %rbp
+  4031e6:	48 89 e5             	mov    %rsp,%rbp
+  4031e9:	48 83 ec 18          	sub    $0x18,%rsp
+  4031ed:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+    MCB_P ptr = (MCB_P)p;
+  4031f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  4031f5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+    ptr--;
+  4031f9:	48 83 6d f8 08       	subq   $0x8,-0x8(%rbp)
+
+    mcb_count--;
+  4031fe:	8b 05 3c 13 20 00    	mov    0x20133c(%rip),%eax        # 604540 <mcb_count>
+  403204:	ff c8                	dec    %eax
+  403206:	89 05 34 13 20 00    	mov    %eax,0x201334(%rip)        # 604540 <mcb_count>
+    ptr->is_available = FREE;
+  40320c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  403210:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
+    allocated_mem    -= (ptr->size - sizeof(MCB_t));
+  403216:	8b 05 20 13 20 00    	mov    0x201320(%rip),%eax        # 60453c <allocated_mem>
+  40321c:	89 c2                	mov    %eax,%edx
+  40321e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+  403222:	8b 40 04             	mov    0x4(%rax),%eax
+  403225:	29 c2                	sub    %eax,%edx
+  403227:	89 d0                	mov    %edx,%eax
+  403229:	83 c0 08             	add    $0x8,%eax
+  40322c:	89 05 0a 13 20 00    	mov    %eax,0x20130a(%rip)        # 60453c <allocated_mem>
+
+}
+  403232:	c9                   	leaveq 
+  403233:	c3                   	retq   
+
+0000000000403234 <syscall_1>:
+			:"=r"(ret):"m"(n));
+
+	return ret;
+}
+
+static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
+  403234:	55                   	push   %rbp
+  403235:	48 89 e5             	mov    %rsp,%rbp
+  403238:	48 83 ec 20          	sub    $0x20,%rsp
+  40323c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+  403240:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
+
+	int64_t ret;
+
+	__asm__("movq $78,%r15");
+  403244:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
+	//__asm__("movq %0,%%rax;"
+	//		::"m"(n));
+
+	//while(1);
+
+	if(n==60){
+  40324b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  40324f:	48 83 f8 3c          	cmp    $0x3c,%rax
+  403253:	75 0c                	jne    403261 <syscall_1+0x2d>
+		__asm__("movq %0,%%rax;"
+  403255:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  403259:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  40325d:	cd 80                	int    $0x80
+  40325f:	eb 11                	jmp    403272 <syscall_1+0x3e>
+
+		//while(1);
+	}
+	else{
+
+		__asm__("movq %1,%%rax;"
+  403261:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  403265:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
+  403269:	cd 80                	int    $0x80
+  40326b:	48 89 c0             	mov    %rax,%rax
+  40326e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
+				"movq %2,%%rdi;"
+				"int $0x80;"
+				"movq %%rax,%0;"
+				:"=r"(ret):"m"(n),"m"(a1));
+	}
+	return ret;
+  403272:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
+}
+  403276:	c9                   	leaveq 
+  403277:	c3                   	retq   
+
+0000000000403278 <chdir>:
+#include <sys/syscall.h>
+#include <syscall.h>
+#include <errno.h>
+#include <stdlib.h>
+
+int chdir(const char *path){
+  403278:	55                   	push   %rbp
+  403279:	48 89 e5             	mov    %rsp,%rbp
+  40327c:	48 83 ec 18          	sub    $0x18,%rsp
+  403280:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
+
+	int retvalue;
+	retvalue=syscall_1(SYS_chdir,(uint64_t)path);
+  403284:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
+  403288:	48 89 c6             	mov    %rax,%rsi
+  40328b:	bf 50 00 00 00       	mov    $0x50,%edi
+  403290:	e8 9f ff ff ff       	callq  403234 <syscall_1>
+  403295:	89 45 fc             	mov    %eax,-0x4(%rbp)
 
+	if(retvalue >=0){
+  403298:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
+  40329c:	78 05                	js     4032a3 <chdir+0x2b>
+		return retvalue;
+  40329e:	8b 45 fc             	mov    -0x4(%rbp),%eax
+  4032a1:	eb 05                	jmp    4032a8 <chdir+0x30>
+	}
+	return -1;
+  4032a3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 
 }
-  4009fb:	c9                   	leaveq 
-  4009fc:	c3                   	retq   
+  4032a8:	c9                   	leaveq 
+  4032a9:	c3                   	retq   
diff --git a/include/errno.h b/include/errno.h
index 162bdf9..36c2ed8 100644
--- a/include/errno.h
+++ b/include/errno.h
@@ -4,7 +4,7 @@
 #include <sys/defs.h>
 
 
-extern int errno;
+ int errno;
 
 
 #define EPERM        1  /* Operation not permitted */
diff --git a/include/string.h b/include/string.h
index fdf40e5..0312bbf 100644
--- a/include/string.h
+++ b/include/string.h
@@ -1,7 +1,7 @@
 
 #ifndef STRING_H_
 #define STRING_H_
-
+#include <sys/defs.h>
 char* strcpy(char* dst, const char* src);
 int strlen(const char *str);
 int strcmp(const char *str1, const char *str2);
diff --git a/include/sys/paging.h b/include/sys/paging.h
index a7f9983..1df6f09 100644
--- a/include/sys/paging.h
+++ b/include/sys/paging.h
@@ -19,7 +19,7 @@
 #define AVAIL2_LIM  0xffffffff87ffd000 //check this value o sbrocks
 
 #define VIDEO_START  0xffffffff800B8000 
-#define USERSTACKTOP PGSIZE
+#define USERSTACKTOP 0x000000000f000000
 
 typedef struct PageStruct {
 	// Next page on the free list.
diff --git a/kernel b/kernel
index 2f2bb22..04478b1 100755
Binary files a/kernel and b/kernel differ
diff --git a/libc/malloc.c b/libc/malloc.c
index 9a44cea..7d68779 100644
--- a/libc/malloc.c
+++ b/libc/malloc.c
@@ -1,312 +1,123 @@
-#include <memory.h>
-#include <stdio.h>
-#include <sys/defs.h>
 #include <sys/syscall.h>
+#include <sys/defs.h>
 #include <stdlib.h>
-#include <errno.h>
 #include<syscall.h>
-
-void *base = NULL;
-
-blockPTR find_block(blockPTR* last,size_t size){
-
-	//printf("In find block... starting search at %x\n",base);
-	blockPTR b= base;
-	while (b && !(b->free && b->size >= size )) {
-		*last = b;
-		b = (blockPTR)b->next;
-	}
-	//printf("Block returned : %x\n",b);
-	return (b);
-}
-
-
-blockPTR extend_heap(blockPTR last, size_t size){
-
-	blockPTR currentHeapEnd,newHeapEnd;
-	currentHeapEnd = (blockPTR)syscall_1(SYS_brk,(uint64_t)0);	//get current heap brk point
-
-	char* increment=(char*)syscall_1(SYS_brk,0);
-
-	newHeapEnd = (blockPTR)(increment + (METADATA_SIZE + size));
-	//printf("New heap end %x\n",newHeapEnd);
-
-	newHeapEnd = (blockPTR)syscall_1(SYS_brk,(uint64_t)newHeapEnd);
-
-	//printf("After xtension...%x\n",syscall_1(SYS_brk,0));
-
-	if(newHeapEnd == currentHeapEnd){
-
-		//Not possible to xtend heap
-		//printf("sbrk fails\n");
-		return (NULL);
-
-	}
-
-	//system call to extend succeded..
-
-	currentHeapEnd->size = size;
-	currentHeapEnd->next = NULL;
-	currentHeapEnd->prev =(blockPTR)last;
-	currentHeapEnd->magic = 1234;
-
-	if(last){
-
-		/*
-		 * The last ptr if not null means that this is not the first time
-		 * So we set next of last to current block
-		 */
-		last->next = (struct block*)currentHeapEnd;
-	}
-	currentHeapEnd->free=0; //This block is now used
-
-	//printf("Heap extended..Current heap end %x\n",syscall_1(SYS_brk,(uint64_t)0));
-
-	return (currentHeapEnd);
-
-}
-
-
-void splitblockPTR ( blockPTR b, size_t s){
-
-	/*
-	 * This function will split block b and create a free block called "new" of size
-	 * b->size - s - METADATA_SIZE
-	 *
-	 */
-	//struct block* temp=NULL;
-	//printf("In split.. old block size %x and size: %d",b,b->size);
-	blockPTR new; // new is a pointer to the new split block which is free
-
-	//b-> data is a char pointer so that we can increment our pointer in 1 byte granularity
-	new = (blockPTR)(b->data + s);
-
-	new ->size = b->size - s - METADATA_SIZE ;
-
-	//Link the new block to next block which was previously b's next
-	new ->next = (struct block*)b->next;
-	new->prev =(struct block*)b;
-
-	//make new block free
-	new ->free = 1 ;
-	new->magic = 1234;
-
-	//Modify size of block b which was split into b and new blocks
-	b->size = s;
-	b->next= (struct block*)new;
-
-	if (new->next){
-		new->next->prev = new;
-		//temp->prev=(struct block*)new;
-	}
-
-
-	//printf("After split.. old block %x and new block %x\n",b,new);
-	//printf("Old block size: %d\n New block size: %d\n",b->size,new->size);
-
+#define PAGESIZE 4096
+
+static char *mem_start_p;
+static char *heap_end;
+static int max_mem;
+static int allocated_mem; 
+static int mcb_count;
+
+typedef struct MCB_header_t {
+    int is_available;
+    int size;
+} MCB_t, *MCB_P;
+
+enum {NEW_MCB, NO_MCB, REUSE_MCB};
+enum {FREE, IN_USE};
+
+void make_head(char *addr, int size) 
+{
+    MCB_P head         = (MCB_P)addr;
+    head->is_available = FREE;
+    head->size         = size;
 }
 
-
-blockPTR getblock(void* p){
-
-	char *tmp;
-	tmp = p;
-	tmp = tmp - METADATA_SIZE;
-	p=tmp;
-	return (p);
-
+void *alloc_new(int aligned_size)
+{
+    char *add;
+    uint64_t no_of_pages = 0, sz;    
+    MCB_P p_mcb;
+    
+    sz          = sizeof(MCB_t);
+    no_of_pages = (aligned_size + sz) /(PAGESIZE + 1) + 1;
+    add = (char*)syscall_1(SYS_brk, (uint64_t)no_of_pages*4096);    
+
+    if (heap_end == 0) {
+        mem_start_p   = add;
+        mcb_count     = 0;
+        allocated_mem = 0;
+        heap_end = add; 
+    }
+    
+    heap_end = (char*)((uint64_t)add + (uint64_t)(PAGESIZE * no_of_pages));
+    max_mem += PAGESIZE * no_of_pages; 
+    
+    p_mcb               = (MCB_P)add; 
+    p_mcb->is_available = IN_USE;
+    p_mcb->size         = aligned_size + sz; 
+    mcb_count++;    
+
+    if (PAGESIZE * no_of_pages > aligned_size + sz) {
+        make_head(((char *)p_mcb + aligned_size + sz), (PAGESIZE * no_of_pages - aligned_size - sz));
+    }
+
+    allocated_mem += aligned_size; 
+    
+    return ((void *) p_mcb + sz);
 }
 
-
-blockPTR fuseBlocks(blockPTR b){
-
-	blockPTR  tmp;
-	tmp = (blockPTR)b->next;
-
-	//printf("In fuseBlocks...Before fuseBlocks size %d\n",b->size);
-
-	if (b->next && tmp->free ){
-		b->size += METADATA_SIZE + tmp->size;
-		b->next = (struct block*)tmp->next;
-		if (b->next)
-			tmp->prev = (struct block*)b;
-	}
-
-	//printf("After fuseBlocks size: %d\n",b->size);
-	return (b);
+void* malloc(size_t elem_size)
+{
+    MCB_P p_mcb;
+    int flag, sz, temp = 0, aligned_size;
+
+    // Align elem_size to header size
+    aligned_size = ((((elem_size - 1) >> 3) + 1) << 3);
+
+    if (heap_end == 0) {
+        /*no heap has been assigned yet*/
+        return alloc_new(aligned_size);
+    } else {
+
+        flag  = NO_MCB;
+        p_mcb = (MCB_P)mem_start_p;
+        sz    = sizeof(MCB_t);
+
+        //printf("\nheap_end : %p\treqd size: %p",heap_end, ((char *)p_mcb + aligned_size + sz));
+        while (heap_end >= ((char *)p_mcb + aligned_size + sz)) {
+            if (p_mcb->is_available == FREE) {
+                if (p_mcb->size >= (aligned_size + sz)) {
+                    flag = REUSE_MCB;
+                    break;
+                }
+            }
+            p_mcb = (MCB_P) ((char *)p_mcb + p_mcb->size);
+        }
+
+        if (flag != NO_MCB) {
+            p_mcb->is_available = IN_USE;
+
+            if (flag == REUSE_MCB) {
+                if (p_mcb->size > aligned_size + sz) {
+                    temp        = p_mcb->size; 
+                    p_mcb->size = aligned_size + sz;
+
+                    make_head(((char *)p_mcb + aligned_size + sz),(temp - aligned_size - sz));
+                }        
+                mcb_count++;
+            }
+            allocated_mem += aligned_size;
+            return ((char *) p_mcb + sz);
+        }
+
+        /*when no hole is found to match the request*/
+        return alloc_new(aligned_size); 
+    }
 
 }
 
-int valid_addr(void *p){
+void free(void *p)
+{
+    MCB_P ptr = (MCB_P)p;
+    ptr--;
 
-	void* heapEnd;
-	blockPTR temp;
-	//printf("In vaild adress. before call p= %d",p);
-	heapEnd = (void*)syscall_1(SYS_brk,(uint64_t)0);
-	//printf("In vaild adress. before call p= %d",p);
-	//printf("In valid address\np = %d\nbase = %d\nheapEnd = %d",p,base,heapEnd);
+    mcb_count--;
+    ptr->is_available = FREE;
+    allocated_mem    -= (ptr->size - sizeof(MCB_t));
 
-	if (base)
-	{
-		//printf("In base \n");
-		if ((p > base)&&(p < heapEnd))
-		{
-			//printf("Valid address\n");
-			temp = getblock(p);
-			//printf("Address of data block %x\nAddress of Metablock %x:\n",p,temp);
-			//printf("ptr poits to %x\n",temp->data);
-			return (p == temp->data );
-		}
-	}
-	//printf("Base address %d",base);
-	return (0);
 }
 
 
-
-
-int brk(void *end_data_segment){
-
-	//printf("\n\nbrk called\n\n");
-	blockPTR currentHeapEnd,newHeapEnd;
-	currentHeapEnd = (blockPTR)syscall_1(SYS_brk,0);
-
-	newHeapEnd = (blockPTR)syscall_1(SYS_brk,(uint64_t)end_data_segment);
-
-	if(newHeapEnd == currentHeapEnd){
-			return -1;
-
-	}
-	else
-		return 0;
-}
-
-
-void free(void *p){
-
-	blockPTR b,temp;
-	//heapProfiler();
-	//printf("In free. P = %d",p);
-	if ( valid_addr(p))
-	{
-		b = getblock(p);
-		//printf("Freeing block %x\n",b);
-		b->free = 1;
-		temp = (blockPTR)b->prev;
-		/* fuseBlocks with previous if possible */
-		if(b->prev && temp->free)
-			b = fuseBlocks((blockPTR)b->prev );
-		/* then fuseBlocks with next */
-		if (b->next){
-			fuseBlocks(b);
-		}
-		else
-		{
-			/* free the end of the heap */
-			if (b->prev)
-				temp->next = NULL;
-			else
-				/* No more block !*/
-				base = NULL;
-
-			//printf("Heap shrunk by %d bytes\n",b->size);
-			brk(b);
-		}
-	}
-
-}
-
-
-
-
-void *malloc(size_t size){
-
-	blockPTR last; //last keeps track of the the last visited block
-	blockPTR b;
-	size_t s;
-	s = align4(size);
-
-
-	if(base){
-		/*
-		 * This is not the first time
-		 */
-		//printf("Not first block\t..Looking for first fit block\n");
-		//1. Look for first fit free block
-		last = base; //This is done incase there is no free block last will be uninitialised.
-		//So we cant use last to extend_heap
-
-		//Last variable is only modified here
-		b = find_block(&last,s);
-
-		if(b){
-			// if a block is found then check if we can split it
-			if((b->size - s )>=(METADATA_SIZE+16)){
-				//printf("Split possible..splitting block %x\n",b);
-				//splitblockPTR(b,s);
-			}
-			b->free = 0;
-		}
-		else{
-
-			//printf("No fitting block found...Extending heap\n");
-			//No fitting block has been found
-			b = extend_heap(last,s);
-			if(!b){
-				return(NULL);
-			}
-		}
-	}
-	else{
-
-		/*
-		 * This is the first time. Extend heap
-		 */
-		//printf("First time extend heap\n");
-		b = extend_heap(NULL,s);
-		if(!b){
-			return(NULL);
-		}
-		base = b; //initialise global base. This is the head of the Heap LL. base is initialised here only
-	}
-
-	//printf("End malloc\n");
-	return b->data;
-
-}
-
-
-void heapProfiler(){
-
-
-	blockPTR temp;
-	int freeSize=0,usedSize=0;
-	//printf("\n========HEAP PROFILER=======\n");
-
-	if(base){
-
-		temp=(blockPTR)base;
-
-		while(temp!=NULL){
-
-			if(temp->free == 1){
-				freeSize += temp->size;
-				//printf("Free block %x. Free Size: %d\n",temp,temp->size);
-			}
-			else if(temp->free == 0){
-				usedSize += temp->size;
-				//printf("Used block %x. Used Size: %d\n",temp,temp->size);
-			}
-
-			temp=(blockPTR)temp->next;
-		}
-
-		//printf("\n========Summary Ststistics========\n");
-		//printf("Free Blocks size = %d\nUsed Blocks size = %d\n",freeSize,usedSize);
-
-	}
-
-
-
-}
-
diff --git a/obj/bin/hello/shell.o b/obj/bin/hello/shell.o
index 81b7293..5288d1c 100644
Binary files a/obj/bin/hello/shell.o and b/obj/bin/hello/shell.o differ
diff --git a/obj/bin/malluaunty/tp.o b/obj/bin/malluaunty/tp.o
index af490e9..98c02b9 100644
Binary files a/obj/bin/malluaunty/tp.o and b/obj/bin/malluaunty/tp.o differ
diff --git a/obj/crt/crt1.o b/obj/crt/crt1.o
index f9365ad..5e45ff2 100644
Binary files a/obj/crt/crt1.o and b/obj/crt/crt1.o differ
diff --git a/obj/libc/chdir.o b/obj/libc/chdir.o
index ee73181..d095fcf 100644
Binary files a/obj/libc/chdir.o and b/obj/libc/chdir.o differ
diff --git a/obj/libc/closedir.o b/obj/libc/closedir.o
index f331384..26fea6e 100644
Binary files a/obj/libc/closedir.o and b/obj/libc/closedir.o differ
diff --git a/obj/libc/fork.o b/obj/libc/fork.o
index 61e0c21..126c345 100644
Binary files a/obj/libc/fork.o and b/obj/libc/fork.o differ
diff --git a/obj/libc/getcwd.o b/obj/libc/getcwd.o
index b9c81cd..aa3d989 100644
Binary files a/obj/libc/getcwd.o and b/obj/libc/getcwd.o differ
diff --git a/obj/libc/malloc.o b/obj/libc/malloc.o
index 4558505..7d71e93 100644
Binary files a/obj/libc/malloc.o and b/obj/libc/malloc.o differ
diff --git a/obj/libc/open.o b/obj/libc/open.o
index cef132d..e784ab4 100644
Binary files a/obj/libc/open.o and b/obj/libc/open.o differ
diff --git a/obj/libc/opendir.o b/obj/libc/opendir.o
index 5897bce..74db2bc 100644
Binary files a/obj/libc/opendir.o and b/obj/libc/opendir.o differ
diff --git a/obj/libc/ps.o b/obj/libc/ps.o
index 9931403..a1e8d0b 100644
Binary files a/obj/libc/ps.o and b/obj/libc/ps.o differ
diff --git a/obj/libc/read.o b/obj/libc/read.o
index 60e378c..6beadf0 100644
Binary files a/obj/libc/read.o and b/obj/libc/read.o differ
diff --git a/obj/libc/readdir.o b/obj/libc/readdir.o
index e413407..87c7426 100644
Binary files a/obj/libc/readdir.o and b/obj/libc/readdir.o differ
diff --git a/obj/libc/string.o b/obj/libc/string.o
index d24d076..07b5c12 100644
Binary files a/obj/libc/string.o and b/obj/libc/string.o differ
diff --git a/obj/libc/testCases.o b/obj/libc/testCases.o
index 82df223..ba7e638 100644
Binary files a/obj/libc/testCases.o and b/obj/libc/testCases.o differ
diff --git a/obj/libc/write.o b/obj/libc/write.o
index 0bca14e..90ff768 100644
Binary files a/obj/libc/write.o and b/obj/libc/write.o differ
diff --git a/obj/sys/isr.o b/obj/sys/isr.o
index 1c46176..519f3ea 100644
Binary files a/obj/sys/isr.o and b/obj/sys/isr.o differ
diff --git a/obj/sys/keyboard.o b/obj/sys/keyboard.o
index 606b69c..e3da67f 100644
Binary files a/obj/sys/keyboard.o and b/obj/sys/keyboard.o differ
diff --git a/obj/sys/main.o b/obj/sys/main.o
index 3f70d38..8037d6b 100644
Binary files a/obj/sys/main.o and b/obj/sys/main.o differ
diff --git a/obj/sys/paging.o b/obj/sys/paging.o
index ce7280d..330ec33 100644
Binary files a/obj/sys/paging.o and b/obj/sys/paging.o differ
diff --git a/obj/sys/pipe.o b/obj/sys/pipe.o
index 24f488f..924d7ff 100644
Binary files a/obj/sys/pipe.o and b/obj/sys/pipe.o differ
diff --git a/obj/sys/printf.o b/obj/sys/printf.o
index 9fc285c..6557ee3 100644
Binary files a/obj/sys/printf.o and b/obj/sys/printf.o differ
diff --git a/obj/sys/process.o b/obj/sys/process.o
index 88b82ee..aaf2329 100644
Binary files a/obj/sys/process.o and b/obj/sys/process.o differ
diff --git a/obj/sys/syscall.o b/obj/sys/syscall.o
index 8328d2c..703eae1 100644
Binary files a/obj/sys/syscall.o and b/obj/sys/syscall.o differ
diff --git a/obj/sys/tarfs.o b/obj/sys/tarfs.o
index d76a2f3..311d5c2 100644
Binary files a/obj/sys/tarfs.o and b/obj/sys/tarfs.o differ
diff --git a/obj/tarfs.o b/obj/tarfs.o
index ee438cc..09dcb3d 100644
Binary files a/obj/tarfs.o and b/obj/tarfs.o differ
diff --git a/rootfs/bin/hello b/rootfs/bin/hello
index 77f8d35..bef0635 100755
Binary files a/rootfs/bin/hello and b/rootfs/bin/hello differ
diff --git a/rootfs/bin/init b/rootfs/bin/init
index c92293d..a17d7fe 100755
Binary files a/rootfs/bin/init and b/rootfs/bin/init differ
diff --git a/rootfs/bin/malluaunty b/rootfs/bin/malluaunty
index 2a13fc3..4e08b2a 100755
Binary files a/rootfs/bin/malluaunty and b/rootfs/bin/malluaunty differ
diff --git a/rootfs/bin/tabz b/rootfs/bin/tabz
index 8f2f57d..5218105 100755
Binary files a/rootfs/bin/tabz and b/rootfs/bin/tabz differ
diff --git a/rootfs/boot/kernel/kernel b/rootfs/boot/kernel/kernel
index 2f2bb22..04478b1 100755
Binary files a/rootfs/boot/kernel/kernel and b/rootfs/boot/kernel/kernel differ
diff --git a/rootfs/lib/libc.a b/rootfs/lib/libc.a
index 60a8db8..008936b 100644
Binary files a/rootfs/lib/libc.a and b/rootfs/lib/libc.a differ
diff --git a/sys/.isr.c.swp b/sys/.isr.c.swp
deleted file mode 100644
index a16f6f2..0000000
Binary files a/sys/.isr.c.swp and /dev/null differ
diff --git a/sys/.process.c.swo b/sys/.process.c.swo
deleted file mode 100644
index 59e6985..0000000
Binary files a/sys/.process.c.swo and /dev/null differ
diff --git a/sys/main.c b/sys/main.c
index 77c12d6..c71d3f4 100644
--- a/sys/main.c
+++ b/sys/main.c
@@ -41,7 +41,7 @@ void start(uint32_t* modulep, void* physbase, void* physfree)
   //printf("After initializing vm\n");
 
    i=499999999;
-    while(i--);
+   //while(i--);
 
   tarfs_init();
 
diff --git a/sys/process.c b/sys/process.c
index d942e78..7ffe9a1 100644
--- a/sys/process.c
+++ b/sys/process.c
@@ -576,6 +576,7 @@ if(vma)
     //printf("inc_brk:in if\n");
     vma->vm_end=vma->vm_end+n;
     curproc->mm->end_brk+=n;
+//    printf("incbrk return%d ",vma->vm_end);
     return vma->vm_end;
 
 }
diff --git a/sys/tarfs.c b/sys/tarfs.c
index 9781d3e..00a61d6 100644
--- a/sys/tarfs.c
+++ b/sys/tarfs.c
@@ -597,10 +597,10 @@ int kread(int fd,char* buf, int numBytesToRead){
 
 	int file_table_index = curproc->fd_table[fd];
 
-	 printf("In read fd passed :%d",fd);
+	/* printf("In read fd passed :%d",fd);
 	 printf("file_table_index %d\n",file_table_index );
 	 printf("read: %p\n",file_table[file_table_index].read );
-
+*/
 	return file_table[file_table_index].read(file_table_index,buf,numBytesToRead);
 
 }
diff --git a/tags b/tags
index 9b3f888..f37a3fd 100644
--- a/tags
+++ b/tags
@@ -238,6 +238,7 @@ POPA	include/sys/process.h	99;"	d
 POPA2	include/sys/utils.h	20;"	d
 PORT_H_	include/sys/port.h	2;"	d
 PPN	include/sys/mmu.h	30;"	d
+PS1	bin/hello/shell.c	/^char PS1[200]="SBUSH";$/;"	v
 PTE_A	include/sys/mmu.h	77;"	d
 PTE_ADDR	include/sys/mmu.h	93;"	d
 PTE_AVAIL	include/sys/mmu.h	84;"	d
@@ -348,7 +349,6 @@ _TARFS_H	include/sys/tarfs.h	2;"	d
 __SBUNIX_H	include/sys/sbunix.h	2;"	d
 __SYS_SYSCALL_H	include/sys/syscall.h	2;"	d
 _start	crt/crt1.c	/^void _start(void) {$/;"	f
-_start	tp.s	/^_start:$/;"	l
 _x86_64_asm_lgdt	sys/gdt.s	/^_x86_64_asm_lgdt:$/;"	l
 addr	sys/gdt.c	/^	uint64_t addr;$/;"	m	struct:gdtr_t	file:
 addr	sys/idt.c	/^        uint64_t addr;$/;"	m	struct:idtr_t	file:
@@ -361,7 +361,6 @@ allocate_proc_area	sys/process.c	/^int allocate_proc_area(ProcStruct* p, void* v
 allocate_process	sys/process.c	/^ProcStruct* allocate_process(unsigned char parentid)$/;"	f
 allocate_vma	sys/process.c	/^struct vma_struct* allocate_vma(mm_struct* mem)$/;"	f
 args	sys/process.c	/^char args[15][60];$/;"	v
-argv	tp.c	/^    ; push argv$/;"	v
 base	libc/malloc.c	/^void *base = NULL;$/;"	v
 binary	include/sys/process.h	/^uint64_t *binary;$/;"	m	struct:ProcStruct
 block	include/memory.h	/^struct block{$/;"	s
@@ -378,6 +377,8 @@ callq	bin/hello/tp.s	/^callq main$/;"	l
 capslock	sys/keyboard.c	/^unsigned char capslock = FALSE;$/;"	v
 cat	libc/cat.c	/^void cat(char* filename){$/;"	f
 cd	libc/testCases.c	/^void cd(char *path){$/;"	f
+changePS1	bin/hello/PS1.c	/^void changePS1(char*str){$/;"	f
+changedir	bin/hello/cd.c	/^void changedir(char* path){$/;"	f
 chdir	libc/chdir.c	/^int chdir(const char *path){$/;"	f
 checksum	include/sys/tarfs.h	/^	char checksum[8];$/;"	m	struct:posix_header_ustar
 close	include/sys/file_table.h	/^	int (*close)(); \/\/pointer to the device specific close call$/;"	m	struct:__anon9
@@ -411,6 +412,7 @@ d_reclen	include/sys/tarfs.h	/^	unsigned short d_reclen;$/;"	m	struct:K_dirent
 data	include/memory.h	/^	char data[1];$/;"	m	struct:block
 devmajor	include/sys/tarfs.h	/^	char devmajor[8];$/;"	m	struct:posix_header_ustar
 devminor	include/sys/tarfs.h	/^	char devminor[8];$/;"	m	struct:posix_header_ustar
+dir_traverse	bin/hello/readdir.c	/^static int dir_traverse=0;$/;"	v	file:
 directroy_test_case	libc/testCases.c	/^void directroy_test_case(){$/;"	f
 dirent	include/stdlib.h	/^struct dirent$/;"	s
 dpl	sys/idt.c	/^    unsigned dpl : 2;$/;"	m	struct:idt_t	file:
@@ -438,8 +440,11 @@ elf	include/sys/process.h	/^uint64_t *elf;$/;"	m	struct:ProcStruct
 end_brk	include/sys/process.h	/^    uint64_t end_brk,start_brk;$/;"	m	struct:mm_struct
 enter_pressed	sys/keyboard.c	/^volatile int enter_pressed = 0; \/\/A flag that indicates whetehr user finished pressing keys$/;"	v
 env_pop_tf	sys/process.c	/^void env_pop_tf(struct Trapframe *tf1)$/;"	f
+errno	include/errno.h	/^ int errno;$/;"	v
 errno	sys/main.c	/^int errno = 0;$/;"	v
 errorCode	include/sys/isr.h	/^    uint64_t errorCode;$/;"	m	struct:faultStruct
+executeBuiltins	bin/hello/executeBuiltins.c	/^void executeBuiltins(parseInfo* command,char*envp[]){$/;"	f
+execute_cmd	bin/hello/execute.c	/^void execute_cmd(parseInfo * info,char*envp[])$/;"	f
 execve	libc/execve.c	/^int execve(const char *filename, char *const argv[], char *const envp[])$/;"	f
 execve	sys/process.c	/^uint64_t execve(const char *arg1,const char *arg2[],const  char* arg3[])$/;"	f
 exit	libc/exit.c	/^void exit(int status){$/;"	f
@@ -451,12 +456,17 @@ fileTable_entry	include/sys/file_table.h	/^} fileTable_entry;$/;"	t	typeref:stru
 file_read_test_case	libc/testCases.c	/^void file_read_test_case(){$/;"	f
 file_table	sys/tarfs.c	/^fileTable_entry file_table[10];$/;"	v
 filesz	include/sys/process.h	/^uint64_t filesz;$/;"	m	struct:vma_struct
+findBinaryFullPath	bin/hello/findBinaryFullPath.c	/^char* findBinaryFullPath(char* srchPath,char* binaryName){$/;"	f
+findEnvVar	bin/hello/getEnvironmentVarLoc.c	/^char** findEnvVar(char* envVar, char* envp[]){$/;"	f
 find_block	libc/malloc.c	/^blockPTR find_block(blockPTR* last,size_t size){$/;"	f
+find_file_in_dir	bin/hello/findBinaryFullPath.c	/^char* find_file_in_dir (char *path, char *file)$/;"	f
 fork	libc/fork.c	/^pid_t fork()$/;"	f
 fork_process	sys/process.c	/^int fork_process(struct Trapframe* tf)$/;"	f
 fork_test_case	libc/testCases.c	/^void fork_test_case(){$/;"	f
 free	include/memory.h	/^	int free;$/;"	m	struct:block
 free	libc/malloc.c	/^void free(void *p){$/;"	f
+free_info	bin/hello/parser.c	/^void free_info (parseInfo *info) {$/;"	f
+free_pages	sys/paging.c	/^int free_pages=1;$/;"	v
 fuseBlocks	libc/malloc.c	/^blockPTR fuseBlocks(blockPTR b){$/;"	f
 gdt	sys/gdt.c	/^uint64_t gdt[MAX_GDT] = {$/;"	v
 gdtr	sys/gdt.c	/^static struct gdtr_t gdtr = {$/;"	v	typeref:struct:gdtr_t	file:
@@ -489,7 +499,6 @@ initialize_vm_64	sys/paging.c	/^void initialize_vm_64(void){$/;"	f
 inode	newfs/newfs.c	/^struct inode {$/;"	s	file:
 inode_num	include/sys/file_table.h	/^	int inode_num; \/\/the entry in the tarfs table$/;"	m	struct:__anon9
 int	bin/hello/tp.s	/^int $80$/;"	l
-int	tp.s	/^int $80$/;"	l
 int16_t	include/sys/defs.h	/^typedef          short  int16_t;$/;"	t
 int32_t	include/sys/defs.h	/^typedef          int    int32_t;$/;"	t
 int64_t	include/sys/defs.h	/^typedef          long   int64_t;$/;"	t
@@ -546,15 +555,16 @@ ltr	include/sys/paging.h	/^ltr(uint16_t sel)$/;"	f
 magic	include/memory.h	/^	int magic;$/;"	m	struct:block
 magic	include/sys/tarfs.h	/^	char magic[6];$/;"	m	struct:posix_header_ustar
 magic	newfs/newfs.c	/^	uint32_t magic;$/;"	m	struct:superblock	file:
-main	bin/hello/shell.c	/^int main(int argc, char* argv[], char* envp[])$/;"	f
+main	bin/hello/shell.c	/^int main (int argc, char *argv[], char* envp[])$/;"	f
 main	bin/hello/tp.s	/^main:$/;"	l
 main	bin/init/init.c	/^int main()$/;"	f
 main	bin/malluaunty/tp.c	/^int main(int argc, char* argv[], char* envp[])$/;"	f
 main	bin/tabz/tab.c	/^int main()$/;"	f
 main	newfs/newfs.c	/^int main(int argc, char* argv[]) {$/;"	f
-main	tp.c	/^    call main$/;"	v
+main1	bin/hello/hello.c	/^int main1(int argc, char* argv[], char* envp[]) {$/;"	f
 malloc	libc/malloc.c	/^void *malloc(size_t size){$/;"	f
 map_vm_pm	sys/paging.c	/^uint16_t  map_vm_pm(pml4e_t* pml4e, uint64_t va,uint64_t pa,uint64_t size, uint16_t perm)$/;"	f
+maxcount	sys/process.c	/^int maxcount=0;$/;"	v
 mm	include/sys/process.h	/^struct mm_struct *mm;$/;"	m	struct:ProcStruct	typeref:struct:ProcStruct::mm_struct
 mm_struct	include/sys/process.h	/^typedef struct mm_struct {$/;"	s
 mm_struct	include/sys/process.h	/^}mm_struct;$/;"	t	typeref:struct:mm_struct
@@ -564,7 +574,6 @@ mode	include/sys/tarfs.h	/^	char mode[8];$/;"	m	struct:posix_header_ustar
 mov	bin/hello/tp.s	/^mov  %eax, 1$/;"	l
 mov	bin/hello/tp.s	/^mov  %eax, 2$/;"	l
 mov	bin/hello/tp.s	/^mov  %eax, 3$/;"	l
-mov	tp.s	/^mov  %eax, 1$/;"	l
 mtime	include/sys/tarfs.h	/^	char mtime[12];$/;"	m	struct:posix_header_ustar
 name	include/sys/tarfs.h	/^	char name[100];$/;"	m	struct:posix_header_ustar
 name	include/sys/tarfs.h	/^    char name[100];$/;"	m	struct:__anon5
@@ -573,6 +582,7 @@ next	include/sys/paging.h	/^        struct PageStruct *next;$/;"	m	struct:PageSt
 next	include/sys/process.h	/^struct ProcStruct* next;$/;"	m	struct:ProcStruct	typeref:struct:ProcStruct::ProcStruct
 nextfree	sys/paging.c	/^static char* nextfree;$/;"	v	file:
 npages	include/sys/paging.h	/^uint64_t npages;$/;"	v
+nread	bin/hello/readdir.c	/^static int nread=-1;$/;"	v	file:
 numOfEntries	sys/tarfs.c	/^int numOfEntries = 1; \/\/index into the tarfs table..after tarfs_init() it has the total number of entries in FS$/;"	v
 numOfTokens	include/stringTokenizer.h	/^	int numOfTokens;$/;"	m	struct:__anon4
 numOfTokens	include/stringtokenizer.h	/^	int numOfTokens;$/;"	m	struct:__anon1
@@ -582,7 +592,9 @@ off_t	include/stdlib.h	/^typedef uint64_t off_t;$/;"	t
 offset_0_15	sys/idt.c	/^    uint16_t offset_0_15;$/;"	m	struct:idt_t	file:
 offset_16_31	sys/idt.c	/^    uint16_t offset_16_31;$/;"	m	struct:idt_t	file:
 offset_63_32	sys/idt.c	/^    uint32_t offset_63_32;$/;"	m	struct:idt_t	file:
+onlyWhiteSpace	bin/hello/stringTokenizer.c	/^int onlyWhiteSpace(char *str){$/;"	f
 open	libc/open.c	/^int open(const char *pathname, int flags)$/;"	f
+opendir	bin/hello/readdir.c	/^void *opendir(const char *name){$/;"	f
 opendir	libc/opendir.c	/^void *opendir(const char *name)$/;"	f
 outb	include/sys/port.h	/^static inline void outb(uint16_t port, unsigned char val)$/;"	f
 p	sys/idt.c	/^    unsigned p : 1;$/;"	m	struct:idt_t	file:
@@ -599,9 +611,9 @@ pageToPhysicalAddress	sys/paging.c	/^uint64_t* pageToPhysicalAddress(PageStruct*
 page_free_list	sys/paging.c	/^static struct PageStruct *page_free_list;	\/\/ Free list of physical pages. page_free_list is the head of the free list$/;"	v	typeref:struct:PageStruct	file:
 pages	sys/paging.c	/^struct PageStruct *pages;$/;"	v	typeref:struct:PageStruct
 par_ind	include/sys/tarfs.h	/^    int par_ind;$/;"	m	struct:__anon5
-parallel_fork	bin/hello/shell.c	/^void parallel_fork(){$/;"	f
 parent_id	include/sys/process.h	/^unsigned char parent_id;$/;"	m	struct:ProcStruct
 parseInfo	include/parser.h	/^} parseInfo;$/;"	t	typeref:struct:__anon3
+parseModified	bin/hello/parser.c	/^parseInfo* parseModified(char *cmd,char* envp[]){$/;"	f
 pde_t	include/sys/defs.h	/^typedef uint64_t pde_t;$/;"	t
 pdpe_t	include/sys/defs.h	/^typedef uint64_t pdpe_t;$/;"	t
 physaddr_t	include/sys/defs.h	/^typedef uint64_t physaddr_t;$/;"	t
@@ -621,6 +633,7 @@ power	sys/utils.c	/^uint64_t power(uint64_t x, int e) {$/;"	f
 prefix	include/sys/tarfs.h	/^	char prefix[155];$/;"	m	struct:posix_header_ustar
 present	include/sys/file_table.h	/^	int present; \/\/indicates if this entry is valid or not 0->free 1->present$/;"	m	struct:__anon9
 prev	include/memory.h	/^	struct block* prev;$/;"	m	struct:block	typeref:struct:block::block
+print_info	bin/hello/parser.c	/^void print_info (parseInfo *info) {$/;"	f
 print_keyboard_buff	sys/keyboard.c	/^void print_keyboard_buff(){$/;"	f
 print_num	libc/printf.c	/^void print_num(int num, int base)$/;"	f
 print_num	sys/printf.c	/^void print_num(int num, int base)$/;"	f
@@ -646,7 +659,9 @@ read	libc/read.c	/^ssize_t read(int fd, void *buf, size_t count){$/;"	f
 read_cr2_register	sys/isr.c	/^uint64_t read_cr2_register(){$/;"	f
 read_cursor	include/sys/file_table.h	/^	uint64_t read_cursor;$/;"	m	struct:__anon8
 read_file	sys/tarfs.c	/^int read_file(int file_table_index,char *buf,int numBytesToRead){$/;"	f
+read_line	bin/hello/parser.c	/^int read_line(int fd, char* buf)$/;"	f
 read_line	libc/testCases.c	/^void read_line(int fd, char* buf)$/;"	f
+readdir	bin/hello/readdir.c	/^struct dirent *readdir(void *dir){$/;"	f
 readdir	libc/readdir.c	/^struct dirent* readdir(void *dir){$/;"	f
 readers	include/sys/file_table.h	/^	int readers;$/;"	m	struct:__anon8
 ref_count	include/sys/file_table.h	/^	int ref_count; \/\/number of processes which have this file open$/;"	m	struct:__anon9
@@ -668,11 +683,11 @@ reg_rdi	include/sys/idt.h	/^	uint64_t reg_rdi;$/;"	m	struct:GpRegs
 reg_rdx	include/sys/idt.h	/^	uint64_t reg_rdx;$/;"	m	struct:GpRegs
 reg_rsi	include/sys/idt.h	/^	uint64_t reg_rsi;$/;"	m	struct:GpRegs
 reload_gdt	sys/gdt.c	/^void reload_gdt() {$/;"	f
+removeSpaces	bin/hello/removeSpaces.c	/^char* removeSpaces(char*str){$/;"	f
 remove_page	sys/paging.c	/^int remove_page(uint64_t* pa)$/;"	f
 reserved	include/sys/gdt.h	/^	uint32_t reserved;$/;"	m	struct:tss_t
 reserved0	sys/idt.c	/^    unsigned reserved0 : 5;$/;"	m	struct:idt_t	file:
 reserved1	sys/idt.c	/^    uint32_t reserved1;$/;"	m	struct:idt_t	file:
-returned	tp.c	/^    ; main has returned, eax is return value$/;"	v
 rflags	include/sys/isr.h	/^    uint64_t rflags;$/;"	m	struct:faultStruct
 rip	include/sys/isr.h	/^    uint64_t rip;$/;"	m	struct:faultStruct
 rsp	include/sys/isr.h	/^    uint64_t rsp;$/;"	m	struct:faultStruct
@@ -699,6 +714,8 @@ sd_xx2	sys/gdt.c	/^	uint64_t sd_xx2:8;     \/* reserved *\/$/;"	m	struct:sys_seg
 sd_xx3	sys/gdt.c	/^	uint64_t sd_xx3:19;    \/* reserved *\/$/;"	m	struct:sys_segment_descriptor	file:
 sd_zero	sys/gdt.c	/^	uint64_t sd_zero:5;    \/* must be zero *\/$/;"	m	struct:sys_segment_descriptor	file:
 selector	sys/idt.c	/^    uint16_t selector;$/;"	m	struct:idt_t	file:
+set	bin/hello/changePath.c	/^void set(char * args, char** envp){$/;"	f
+setPath	bin/hello/changePath.c	/^char * setPath(char* env,char* path,int mode){$/;"	f
 setup_tss	sys/gdt.c	/^void setup_tss() {$/;"	f
 setupt_proc_vm	sys/process.c	/^setupt_proc_vm(ProcStruct* NewProc)$/;"	f
 sh_addr	include/sys/elf.h	/^	uint64_t sh_addr;$/;"	m	struct:Secthdr
@@ -740,6 +757,7 @@ strcpy	libc/string.c	/^char* strcpy(char* dst, const char* src)$/;"	f
 strerror	libc/string.c	/^uint64_t strerror(int err)$/;"	f
 strlen	libc/string.c	/^int strlen(const char *str)$/;"	f
 strstr	libc/string.c	/^const char *strstr(const char *haystack, const char *needle)$/;"	f
+substring	bin/hello/stringTokenizer.c	/^char * substring(char* str, int front, int back){$/;"	f
 superblock	newfs/newfs.c	/^struct superblock {$/;"	s	file:
 sys_brk	sys/syscall.c	/^uint64_t sys_brk(uint64_t n)$/;"	f
 sys_chdir	sys/syscall.c	/^int sys_chdir(char* path){$/;"	f
@@ -798,6 +816,7 @@ timespec	libc/sleep.c	/^struct timespec$/;"	s	file:
 tlb_invalidate	sys/paging.c	/^tlb_invalidate(pml4e_t *pml4e, void *va)$/;"	f
 tokenArr	include/stringTokenizer.h	/^	char *tokenArr[50];$/;"	m	struct:__anon4
 tokenArr	include/stringtokenizer.h	/^	char *tokenArr[50];$/;"	m	struct:__anon1
+tokenize	bin/hello/stringTokenizer.c	/^Token* tokenize(char *str,char* delim){$/;"	f
 tss	sys/main.c	/^struct tss_t tss;$/;"	v	typeref:struct:tss_t
 tss_t	include/sys/gdt.h	/^struct tss_t {$/;"	s
 tv_nsec	include/sys/process.h	/^	int64_t tv_nsec;$/;"	m	struct:K_timespec
