
rootfs/bin/hello:     file format elf64-x86-64


Disassembly of section .text:

00000000004000e8 <_start>:
#include <stdlib.h>
#include <stdio.h>
int main(int argc, char* argv[], char* envp[]);

void _start(void) {
  4000e8:	55                   	push   %rbp
  4000e9:	48 89 e5             	mov    %rsp,%rbp
  4000ec:	48 83 ec 10          	sub    $0x10,%rsp
//	int argc = 1;
//	char* argv[0];
//	char* envp[0];
	int res;
//	res = main(0, NULL, NULL);
 volatile int x=89;
  4000f0:	c7 45 f8 59 00 00 00 	movl   $0x59,-0x8(%rbp)
  res=  main(*((uint64_t*)(&x+0x3UL)),(char**)(uint64_t*)(&x+0x5UL), (char **)((&x+5) +  (2*(*(&x+3)+ 1))));
  4000f7:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  4000fb:	48 83 c0 0c          	add    $0xc,%rax
  4000ff:	8b 00                	mov    (%rax),%eax
  400101:	ff c0                	inc    %eax
  400103:	48 98                	cltq   
  400105:	48 c1 e0 03          	shl    $0x3,%rax
  400109:	48 8d 50 14          	lea    0x14(%rax),%rdx
  40010d:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  400111:	48 01 c2             	add    %rax,%rdx
  400114:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  400118:	48 83 c0 0c          	add    $0xc,%rax
  40011c:	48 8b 00             	mov    (%rax),%rax
  40011f:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  400123:	48 83 c1 14          	add    $0x14,%rcx
  400127:	48 89 ce             	mov    %rcx,%rsi
  40012a:	89 c7                	mov    %eax,%edi
  40012c:	e8 0a 16 00 00       	callq  40173b <main>
  400131:	89 45 fc             	mov    %eax,-0x4(%rbp)

    exit(res);
  400134:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400137:	89 c7                	mov    %eax,%edi
  400139:	e8 87 28 00 00       	callq  4029c5 <exit>
  }
  40013e:	c9                   	leaveq 
  40013f:	c3                   	retq   

0000000000400140 <changedir>:
#include <errno.h>
#include <string.h>
#include <shell.h>


void changedir(char* path){
  400140:	55                   	push   %rbp
  400141:	48 89 e5             	mov    %rsp,%rbp
  400144:	48 81 ec 40 02 00 00 	sub    $0x240,%rsp
  40014b:	48 89 bd c8 fd ff ff 	mov    %rdi,-0x238(%rbp)

int pathLen = strlen(path);
  400152:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  400159:	48 89 c7             	mov    %rax,%rdi
  40015c:	e8 80 28 00 00       	callq  4029e1 <strlen>
  400161:	89 45 ec             	mov    %eax,-0x14(%rbp)

    int forward=0;
  400164:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    int back = 0;
  40016b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
    char temp[20];
    int i=0;
  400172:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    int x=0;
  400179:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
    int numOfComponents = 0;
  400180:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)

    char components[10][20];

    for(forward=0;forward<pathLen;){
  400187:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  40018e:	e9 1a 01 00 00       	jmpq   4002ad <changedir+0x16d>
        
        if(forward == 0 && path[forward] == '/'){
  400193:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  400197:	75 3b                	jne    4001d4 <changedir+0x94>
  400199:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40019c:	48 63 d0             	movslq %eax,%rdx
  40019f:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  4001a6:	48 01 d0             	add    %rdx,%rax
  4001a9:	0f b6 00             	movzbl (%rax),%eax
  4001ac:	3c 2f                	cmp    $0x2f,%al
  4001ae:	75 24                	jne    4001d4 <changedir+0x94>
            strcpy(components[0],"/");
  4001b0:	48 8d 85 08 ff ff ff 	lea    -0xf8(%rbp),%rax
  4001b7:	48 8d 35 da 31 00 00 	lea    0x31da(%rip),%rsi        # 403398 <chdir+0x37>
  4001be:	48 89 c7             	mov    %rax,%rdi
  4001c1:	e8 50 28 00 00       	callq  402a16 <strcpy>
            back++;
  4001c6:	ff 45 f8             	incl   -0x8(%rbp)
            forward++;
  4001c9:	ff 45 fc             	incl   -0x4(%rbp)
            numOfComponents++;
  4001cc:	ff 45 f0             	incl   -0x10(%rbp)
            continue;
  4001cf:	e9 d9 00 00 00       	jmpq   4002ad <changedir+0x16d>
        }

        if(path[forward] == '/'){
  4001d4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4001d7:	48 63 d0             	movslq %eax,%rdx
  4001da:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  4001e1:	48 01 d0             	add    %rdx,%rax
  4001e4:	0f b6 00             	movzbl (%rax),%eax
  4001e7:	3c 2f                	cmp    $0x2f,%al
  4001e9:	0f 85 bb 00 00 00    	jne    4002aa <changedir+0x16a>

            if(path[forward-1] == '/'){
  4001ef:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4001f2:	48 98                	cltq   
  4001f4:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  4001f8:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  4001ff:	48 01 d0             	add    %rdx,%rax
  400202:	0f b6 00             	movzbl (%rax),%eax
  400205:	3c 2f                	cmp    $0x2f,%al
  400207:	75 16                	jne    40021f <changedir+0xdf>
                printf("Malformed path\n");
  400209:	48 8d 3d 8a 31 00 00 	lea    0x318a(%rip),%rdi        # 40339a <chdir+0x39>
  400210:	b8 00 00 00 00       	mov    $0x0,%eax
  400215:	e8 f1 20 00 00       	callq  40230b <printf>
  40021a:	e9 4d 03 00 00       	jmpq   40056c <changedir+0x42c>
                return;
            }

            //copy from back till forward-1
            i=0;
  40021f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
            
            x = (forward-back);
  400226:	8b 45 f8             	mov    -0x8(%rbp),%eax
  400229:	8b 55 fc             	mov    -0x4(%rbp),%edx
  40022c:	29 c2                	sub    %eax,%edx
  40022e:	89 d0                	mov    %edx,%eax
  400230:	89 45 e8             	mov    %eax,-0x18(%rbp)
            while(i< x){
  400233:	eb 28                	jmp    40025d <changedir+0x11d>

                temp[i++] = path[back++];
  400235:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400238:	8d 50 01             	lea    0x1(%rax),%edx
  40023b:	89 55 f4             	mov    %edx,-0xc(%rbp)
  40023e:	8b 55 f8             	mov    -0x8(%rbp),%edx
  400241:	8d 4a 01             	lea    0x1(%rdx),%ecx
  400244:	89 4d f8             	mov    %ecx,-0x8(%rbp)
  400247:	48 63 ca             	movslq %edx,%rcx
  40024a:	48 8b 95 c8 fd ff ff 	mov    -0x238(%rbp),%rdx
  400251:	48 01 ca             	add    %rcx,%rdx
  400254:	0f b6 12             	movzbl (%rdx),%edx
  400257:	48 98                	cltq   
  400259:	88 54 05 d0          	mov    %dl,-0x30(%rbp,%rax,1)

            //copy from back till forward-1
            i=0;
            
            x = (forward-back);
            while(i< x){
  40025d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400260:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  400263:	7c d0                	jl     400235 <changedir+0xf5>

                temp[i++] = path[back++];
              
            }
            temp[i]= '\0';
  400265:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400268:	48 98                	cltq   
  40026a:	c6 44 05 d0 00       	movb   $0x0,-0x30(%rbp,%rax,1)
            //printf("%s\n", temp );
            
            strcpy(components[numOfComponents],temp);
  40026f:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
  400276:	8b 45 f0             	mov    -0x10(%rbp),%eax
  400279:	48 98                	cltq   
  40027b:	48 c1 e0 02          	shl    $0x2,%rax
  40027f:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  400286:	00 
  400287:	48 01 c8             	add    %rcx,%rax
  40028a:	48 01 c2             	add    %rax,%rdx
  40028d:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  400291:	48 89 c6             	mov    %rax,%rsi
  400294:	48 89 d7             	mov    %rdx,%rdi
  400297:	e8 7a 27 00 00       	callq  402a16 <strcpy>
            //printf("%s\n", &components[0] );
            forward++;
  40029c:	ff 45 fc             	incl   -0x4(%rbp)
            back = forward;
  40029f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4002a2:	89 45 f8             	mov    %eax,-0x8(%rbp)
            numOfComponents++;
  4002a5:	ff 45 f0             	incl   -0x10(%rbp)
            continue;
  4002a8:	eb 03                	jmp    4002ad <changedir+0x16d>

        }

        forward++;
  4002aa:	ff 45 fc             	incl   -0x4(%rbp)
    int x=0;
    int numOfComponents = 0;

    char components[10][20];

    for(forward=0;forward<pathLen;){
  4002ad:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4002b0:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  4002b3:	0f 8c da fe ff ff    	jl     400193 <changedir+0x53>

        forward++;

    } //End of for

    if(path[forward-1] != '/'){
  4002b9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4002bc:	48 98                	cltq   
  4002be:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  4002c2:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  4002c9:	48 01 d0             	add    %rdx,%rax
  4002cc:	0f b6 00             	movzbl (%rax),%eax
  4002cf:	3c 2f                	cmp    $0x2f,%al
  4002d1:	0f 84 83 00 00 00    	je     40035a <changedir+0x21a>

        i=0;
  4002d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
        x = forward-back;
  4002de:	8b 45 f8             	mov    -0x8(%rbp),%eax
  4002e1:	8b 55 fc             	mov    -0x4(%rbp),%edx
  4002e4:	29 c2                	sub    %eax,%edx
  4002e6:	89 d0                	mov    %edx,%eax
  4002e8:	89 45 e8             	mov    %eax,-0x18(%rbp)
        while(i<x){
  4002eb:	eb 28                	jmp    400315 <changedir+0x1d5>
            temp[i++]=path[back++];
  4002ed:	8b 45 f4             	mov    -0xc(%rbp),%eax
  4002f0:	8d 50 01             	lea    0x1(%rax),%edx
  4002f3:	89 55 f4             	mov    %edx,-0xc(%rbp)
  4002f6:	8b 55 f8             	mov    -0x8(%rbp),%edx
  4002f9:	8d 4a 01             	lea    0x1(%rdx),%ecx
  4002fc:	89 4d f8             	mov    %ecx,-0x8(%rbp)
  4002ff:	48 63 ca             	movslq %edx,%rcx
  400302:	48 8b 95 c8 fd ff ff 	mov    -0x238(%rbp),%rdx
  400309:	48 01 ca             	add    %rcx,%rdx
  40030c:	0f b6 12             	movzbl (%rdx),%edx
  40030f:	48 98                	cltq   
  400311:	88 54 05 d0          	mov    %dl,-0x30(%rbp,%rax,1)

    if(path[forward-1] != '/'){

        i=0;
        x = forward-back;
        while(i<x){
  400315:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400318:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  40031b:	7c d0                	jl     4002ed <changedir+0x1ad>
            temp[i++]=path[back++];
        }
        temp[i] = '\0';
  40031d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400320:	48 98                	cltq   
  400322:	c6 44 05 d0 00       	movb   $0x0,-0x30(%rbp,%rax,1)
        strcpy(components[numOfComponents++],temp);
  400327:	8b 45 f0             	mov    -0x10(%rbp),%eax
  40032a:	8d 50 01             	lea    0x1(%rax),%edx
  40032d:	89 55 f0             	mov    %edx,-0x10(%rbp)
  400330:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
  400337:	48 98                	cltq   
  400339:	48 c1 e0 02          	shl    $0x2,%rax
  40033d:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  400344:	00 
  400345:	48 01 c8             	add    %rcx,%rax
  400348:	48 01 c2             	add    %rax,%rdx
  40034b:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  40034f:	48 89 c6             	mov    %rax,%rsi
  400352:	48 89 d7             	mov    %rdx,%rdi
  400355:	e8 bc 26 00 00       	callq  402a16 <strcpy>

    char buff[100];
    char originalWorkingDirectory[100];
    char toSend[100];

    getcwd(originalWorkingDirectory,100);
  40035a:	48 8d 85 40 fe ff ff 	lea    -0x1c0(%rbp),%rax
  400361:	be 64 00 00 00       	mov    $0x64,%esi
  400366:	48 89 c7             	mov    %rax,%rdi
  400369:	e8 76 1b 00 00       	callq  401ee4 <getcwd>

   
    i=0;
  40036e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

    
    while(i < numOfComponents){
  400375:	e9 e4 01 00 00       	jmpq   40055e <changedir+0x41e>

        if(i == numOfComponents){
  40037a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  40037d:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  400380:	75 05                	jne    400387 <changedir+0x247>
            break;
  400382:	e9 e5 01 00 00       	jmpq   40056c <changedir+0x42c>
        }

        if(i==0){
  400387:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  40038b:	75 5c                	jne    4003e9 <changedir+0x2a9>
            strcpy(toSend,components[i]);
  40038d:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
  400394:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400397:	48 98                	cltq   
  400399:	48 c1 e0 02          	shl    $0x2,%rax
  40039d:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  4003a4:	00 
  4003a5:	48 01 c8             	add    %rcx,%rax
  4003a8:	48 01 c2             	add    %rax,%rdx
  4003ab:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  4003b2:	48 89 d6             	mov    %rdx,%rsi
  4003b5:	48 89 c7             	mov    %rax,%rdi
  4003b8:	e8 59 26 00 00       	callq  402a16 <strcpy>
            
            if(chdir(toSend) == -1){
  4003bd:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  4003c4:	48 89 c7             	mov    %rax,%rdi
  4003c7:	e8 95 2f 00 00       	callq  403361 <chdir>
  4003cc:	83 f8 ff             	cmp    $0xffffffff,%eax
  4003cf:	0f 85 7c 01 00 00    	jne    400551 <changedir+0x411>
            chdir(originalWorkingDirectory);
  4003d5:	48 8d 85 40 fe ff ff 	lea    -0x1c0(%rbp),%rax
  4003dc:	48 89 c7             	mov    %rax,%rdi
  4003df:	e8 7d 2f 00 00       	callq  403361 <chdir>
            break;
  4003e4:	e9 83 01 00 00       	jmpq   40056c <changedir+0x42c>
            }
        }

        else if(strcmp(components[i],".")==0){
  4003e9:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
  4003f0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  4003f3:	48 98                	cltq   
  4003f5:	48 c1 e0 02          	shl    $0x2,%rax
  4003f9:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  400400:	00 
  400401:	48 01 c8             	add    %rcx,%rax
  400404:	48 01 d0             	add    %rdx,%rax
  400407:	48 8d 35 9c 2f 00 00 	lea    0x2f9c(%rip),%rsi        # 4033aa <chdir+0x49>
  40040e:	48 89 c7             	mov    %rax,%rdi
  400411:	e8 5f 26 00 00       	callq  402a75 <strcmp>
  400416:	85 c0                	test   %eax,%eax
  400418:	75 08                	jne    400422 <changedir+0x2e2>

        	//nothing to do
        	i++;
  40041a:	ff 45 f4             	incl   -0xc(%rbp)
        	continue;
  40041d:	e9 3c 01 00 00       	jmpq   40055e <changedir+0x41e>

        }

        else if(strcmp(components[i],"..")==0){
  400422:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
  400429:	8b 45 f4             	mov    -0xc(%rbp),%eax
  40042c:	48 98                	cltq   
  40042e:	48 c1 e0 02          	shl    $0x2,%rax
  400432:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  400439:	00 
  40043a:	48 01 c8             	add    %rcx,%rax
  40043d:	48 01 d0             	add    %rdx,%rax
  400440:	48 8d 35 65 2f 00 00 	lea    0x2f65(%rip),%rsi        # 4033ac <chdir+0x4b>
  400447:	48 89 c7             	mov    %rax,%rdi
  40044a:	e8 26 26 00 00       	callq  402a75 <strcmp>
  40044f:	85 c0                	test   %eax,%eax
  400451:	75 4b                	jne    40049e <changedir+0x35e>

            if(i == numOfComponents){
  400453:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400456:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  400459:	75 05                	jne    400460 <changedir+0x320>
                break;
  40045b:	e9 0c 01 00 00       	jmpq   40056c <changedir+0x42c>
            }

            chdir("..");
  400460:	48 8d 3d 45 2f 00 00 	lea    0x2f45(%rip),%rdi        # 4033ac <chdir+0x4b>
  400467:	e8 f5 2e 00 00       	callq  403361 <chdir>
            getcwd(buff,100);
  40046c:	48 8d 85 a4 fe ff ff 	lea    -0x15c(%rbp),%rax
  400473:	be 64 00 00 00       	mov    $0x64,%esi
  400478:	48 89 c7             	mov    %rax,%rdi
  40047b:	e8 64 1a 00 00       	callq  401ee4 <getcwd>
            strcpy(toSend,buff);
  400480:	48 8d 95 a4 fe ff ff 	lea    -0x15c(%rbp),%rdx
  400487:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  40048e:	48 89 d6             	mov    %rdx,%rsi
  400491:	48 89 c7             	mov    %rax,%rdi
  400494:	e8 7d 25 00 00       	callq  402a16 <strcpy>
  400499:	e9 b3 00 00 00       	jmpq   400551 <changedir+0x411>
        }


        else{

            if(i == numOfComponents){
  40049e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  4004a1:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  4004a4:	75 05                	jne    4004ab <changedir+0x36b>
                break;
  4004a6:	e9 c1 00 00 00       	jmpq   40056c <changedir+0x42c>
            }


            if(toSend[strlen(toSend)-1] != '/'){
  4004ab:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  4004b2:	48 89 c7             	mov    %rax,%rdi
  4004b5:	e8 27 25 00 00       	callq  4029e1 <strlen>
  4004ba:	ff c8                	dec    %eax
  4004bc:	48 98                	cltq   
  4004be:	0f b6 84 05 dc fd ff 	movzbl -0x224(%rbp,%rax,1),%eax
  4004c5:	ff 
  4004c6:	3c 2f                	cmp    $0x2f,%al
  4004c8:	74 16                	je     4004e0 <changedir+0x3a0>
                
                strcat(toSend,"/");
  4004ca:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  4004d1:	48 8d 35 c0 2e 00 00 	lea    0x2ec0(%rip),%rsi        # 403398 <chdir+0x37>
  4004d8:	48 89 c7             	mov    %rax,%rdi
  4004db:	e8 fa 26 00 00       	callq  402bda <strcat>
            }
            
            strcat(toSend,components[i]);
  4004e0:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
  4004e7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  4004ea:	48 98                	cltq   
  4004ec:	48 c1 e0 02          	shl    $0x2,%rax
  4004f0:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  4004f7:	00 
  4004f8:	48 01 c8             	add    %rcx,%rax
  4004fb:	48 01 c2             	add    %rax,%rdx
  4004fe:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  400505:	48 89 d6             	mov    %rdx,%rsi
  400508:	48 89 c7             	mov    %rax,%rdi
  40050b:	e8 ca 26 00 00       	callq  402bda <strcat>

            if(chdir(toSend) == -1){
  400510:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  400517:	48 89 c7             	mov    %rax,%rdi
  40051a:	e8 42 2e 00 00       	callq  403361 <chdir>
  40051f:	83 f8 ff             	cmp    $0xffffffff,%eax
  400522:	75 2d                	jne    400551 <changedir+0x411>
            //Invalid path
            //restore to the cwd
           int ret= chdir(originalWorkingDirectory);
  400524:	48 8d 85 40 fe ff ff 	lea    -0x1c0(%rbp),%rax
  40052b:	48 89 c7             	mov    %rax,%rdi
  40052e:	e8 2e 2e 00 00       	callq  403361 <chdir>
  400533:	89 45 e4             	mov    %eax,-0x1c(%rbp)
           if(ret<0)
  400536:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  40053a:	79 13                	jns    40054f <changedir+0x40f>
               printf("Could Not Change Directory");
  40053c:	48 8d 3d 6c 2e 00 00 	lea    0x2e6c(%rip),%rdi        # 4033af <chdir+0x4e>
  400543:	b8 00 00 00 00       	mov    $0x0,%eax
  400548:	e8 be 1d 00 00       	callq  40230b <printf>
            break;
  40054d:	eb 1d                	jmp    40056c <changedir+0x42c>
  40054f:	eb 1b                	jmp    40056c <changedir+0x42c>
            }
        }

        i = i + 1;
  400551:	ff 45 f4             	incl   -0xc(%rbp)

        if(i == numOfComponents){
  400554:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400557:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  40055a:	75 02                	jne    40055e <changedir+0x41e>
            break;
  40055c:	eb 0e                	jmp    40056c <changedir+0x42c>

   
    i=0;

    
    while(i < numOfComponents){
  40055e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400561:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  400564:	0f 8c 10 fe ff ff    	jl     40037a <changedir+0x23a>
  40056a:	eb 00                	jmp    40056c <changedir+0x42c>
        }

    }
	

}
  40056c:	c9                   	leaveq 
  40056d:	c3                   	retq   

000000000040056e <setPath>:
#include <errno.h>
#include <string.h>
#include <shell.h>


char * setPath(char* env,char* path,int mode){
  40056e:	55                   	push   %rbp
  40056f:	48 89 e5             	mov    %rsp,%rbp
  400572:	53                   	push   %rbx
  400573:	48 83 ec 38          	sub    $0x38,%rsp
  400577:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  40057b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  40057f:	89 55 cc             	mov    %edx,-0x34(%rbp)

	int newEnvVarLength;
	//char p[500];
	char *new;

	if(mode == EASIS){
  400582:	83 7d cc 01          	cmpl   $0x1,-0x34(%rbp)
  400586:	75 6f                	jne    4005f7 <setPath+0x89>

		//Calculate new space for the path
		newEnvVarLength = strlen("PATH=") + strlen(path)+1;
  400588:	48 8d 3d 3b 2e 00 00 	lea    0x2e3b(%rip),%rdi        # 4033ca <chdir+0x69>
  40058f:	e8 4d 24 00 00       	callq  4029e1 <strlen>
  400594:	89 c3                	mov    %eax,%ebx
  400596:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40059a:	48 89 c7             	mov    %rax,%rdi
  40059d:	e8 3f 24 00 00       	callq  4029e1 <strlen>
  4005a2:	01 d8                	add    %ebx,%eax
  4005a4:	ff c0                	inc    %eax
  4005a6:	89 45 e4             	mov    %eax,-0x1c(%rbp)

		//printf("In setPath.... passed path is :%s:\n newEnvVarLength :%d\n",path,newEnvVarLength);


		//Allocate that space fr the new path
		new = (char*)malloc(sizeof(char)*newEnvVarLength);
  4005a9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  4005ac:	48 98                	cltq   
  4005ae:	48 89 c7             	mov    %rax,%rdi
  4005b1:	e8 ab 2b 00 00       	callq  403161 <malloc>
  4005b6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		strcpy(new,"PATH=");//copy the old env variable
  4005ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4005be:	48 8d 35 05 2e 00 00 	lea    0x2e05(%rip),%rsi        # 4033ca <chdir+0x69>
  4005c5:	48 89 c7             	mov    %rax,%rdi
  4005c8:	e8 49 24 00 00       	callq  402a16 <strcpy>
		strcpy(new+strlen("PATH="),path);
  4005cd:	48 8d 3d f6 2d 00 00 	lea    0x2df6(%rip),%rdi        # 4033ca <chdir+0x69>
  4005d4:	e8 08 24 00 00       	callq  4029e1 <strlen>
  4005d9:	48 63 d0             	movslq %eax,%rdx
  4005dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4005e0:	48 01 c2             	add    %rax,%rdx
  4005e3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4005e7:	48 89 c6             	mov    %rax,%rsi
  4005ea:	48 89 d7             	mov    %rdx,%rdi
  4005ed:	e8 24 24 00 00       	callq  402a16 <strcpy>
  4005f2:	e9 92 00 00 00       	jmpq   400689 <setPath+0x11b>
	}
	else{


		//Calculate new space for the path
		newEnvVarLength = strlen(env) + strlen(path)+1;
  4005f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4005fb:	48 89 c7             	mov    %rax,%rdi
  4005fe:	e8 de 23 00 00       	callq  4029e1 <strlen>
  400603:	89 c3                	mov    %eax,%ebx
  400605:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  400609:	48 89 c7             	mov    %rax,%rdi
  40060c:	e8 d0 23 00 00       	callq  4029e1 <strlen>
  400611:	01 d8                	add    %ebx,%eax
  400613:	ff c0                	inc    %eax
  400615:	89 45 e4             	mov    %eax,-0x1c(%rbp)

		//Allocate that space fr the new path
		new = (char*)malloc(sizeof(char)*newEnvVarLength);
  400618:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  40061b:	48 98                	cltq   
  40061d:	48 89 c7             	mov    %rax,%rdi
  400620:	e8 3c 2b 00 00       	callq  403161 <malloc>
  400625:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		strcpy(new,env);//copy the old env variable
  400629:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  40062d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400631:	48 89 d6             	mov    %rdx,%rsi
  400634:	48 89 c7             	mov    %rax,%rdi
  400637:	e8 da 23 00 00       	callq  402a16 <strcpy>
		strcpy(new+strlen(env),":");
  40063c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400640:	48 89 c7             	mov    %rax,%rdi
  400643:	e8 99 23 00 00       	callq  4029e1 <strlen>
  400648:	48 63 d0             	movslq %eax,%rdx
  40064b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40064f:	48 01 d0             	add    %rdx,%rax
  400652:	48 8d 35 77 2d 00 00 	lea    0x2d77(%rip),%rsi        # 4033d0 <chdir+0x6f>
  400659:	48 89 c7             	mov    %rax,%rdi
  40065c:	e8 b5 23 00 00       	callq  402a16 <strcpy>
		strcpy(new+strlen(env)+1,path);
  400661:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400665:	48 89 c7             	mov    %rax,%rdi
  400668:	e8 74 23 00 00       	callq  4029e1 <strlen>
  40066d:	48 98                	cltq   
  40066f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  400673:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400677:	48 01 c2             	add    %rax,%rdx
  40067a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40067e:	48 89 c6             	mov    %rax,%rsi
  400681:	48 89 d7             	mov    %rdx,%rdi
  400684:	e8 8d 23 00 00       	callq  402a16 <strcpy>
	}


	//printf("Returning new path from setPath %s\n",new);

	return new;
  400689:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  40068d:	48 83 c4 38          	add    $0x38,%rsp
  400691:	5b                   	pop    %rbx
  400692:	5d                   	pop    %rbp
  400693:	c3                   	retq   

0000000000400694 <set>:



void set(char * args, char** envp){
  400694:	55                   	push   %rbp
  400695:	48 89 e5             	mov    %rsp,%rbp
  400698:	48 81 ec 30 04 00 00 	sub    $0x430,%rsp
  40069f:	48 89 bd d8 fb ff ff 	mov    %rdi,-0x428(%rbp)
  4006a6:	48 89 b5 d0 fb ff ff 	mov    %rsi,-0x430(%rbp)

	char *path=NULL;
  4006ad:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  4006b4:	00 
	//include logic to check for entire string ${PATH} or $PATH


	//printf("In set path\n\n");

	tokenEquals = tokenize(args,"=");
  4006b5:	48 8b 85 d8 fb ff ff 	mov    -0x428(%rbp),%rax
  4006bc:	48 8d 35 0f 2d 00 00 	lea    0x2d0f(%rip),%rsi        # 4033d2 <chdir+0x71>
  4006c3:	48 89 c7             	mov    %rax,%rdi
  4006c6:	e8 30 14 00 00       	callq  401afb <tokenize>
  4006cb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	 * Get the location in the envp array where PATH
	 * is stored. We will keep the modified PATH string in this location only.
	 */


	envLoc=findEnvVar("PATH",envp);
  4006cf:	48 8b 85 d0 fb ff ff 	mov    -0x430(%rbp),%rax
  4006d6:	48 89 c6             	mov    %rax,%rsi
  4006d9:	48 8d 3d f4 2c 00 00 	lea    0x2cf4(%rip),%rdi        # 4033d4 <chdir+0x73>
  4006e0:	e8 9f 09 00 00       	callq  401084 <findEnvVar>
  4006e5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	if(tokenEquals->numOfTokens==1){
  4006e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4006ed:	8b 00                	mov    (%rax),%eax
  4006ef:	83 f8 01             	cmp    $0x1,%eax
  4006f2:	75 3d                	jne    400731 <set+0x9d>

		//printf("PATH= case.......\n\n");
		strcpy(tokentoPass,"");
  4006f4:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  4006fb:	48 8d 35 d7 2c 00 00 	lea    0x2cd7(%rip),%rsi        # 4033d9 <chdir+0x78>
  400702:	48 89 c7             	mov    %rax,%rdi
  400705:	e8 0c 23 00 00       	callq  402a16 <strcpy>
		path = setPath(*envLoc,tokentoPass,EASIS);
  40070a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40070e:	48 8b 00             	mov    (%rax),%rax
  400711:	48 8d 8d dc fd ff ff 	lea    -0x224(%rbp),%rcx
  400718:	ba 01 00 00 00       	mov    $0x1,%edx
  40071d:	48 89 ce             	mov    %rcx,%rsi
  400720:	48 89 c7             	mov    %rax,%rdi
  400723:	e8 46 fe ff ff       	callq  40056e <setPath>
  400728:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  40072c:	e9 ab 01 00 00       	jmpq   4008dc <set+0x248>
		return;

	}


	strcpy(tokentoPass,tokenEquals->tokenArr[1]);
  400731:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400735:	48 8b 50 10          	mov    0x10(%rax),%rdx
  400739:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  400740:	48 89 d6             	mov    %rdx,%rsi
  400743:	48 89 c7             	mov    %rax,%rdi
  400746:	e8 cb 22 00 00       	callq  402a16 <strcpy>
	//printf("Token to pass after tokenizing on colon is .%s.\n",tokentoPass);
	tokenColon = tokenize(tokentoPass,":");
  40074b:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  400752:	48 8d 35 77 2c 00 00 	lea    0x2c77(%rip),%rsi        # 4033d0 <chdir+0x6f>
  400759:	48 89 c7             	mov    %rax,%rdi
  40075c:	e8 9a 13 00 00       	callq  401afb <tokenize>
  400761:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	/*
	 * Save the value of PATH in oldSysPath.We will need this
	 * when we need to expand ${PATH}
	 */
	char oldSysPath[500];
	token = tokenize(*envLoc,"=");
  400765:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400769:	48 8b 00             	mov    (%rax),%rax
  40076c:	48 8d 35 5f 2c 00 00 	lea    0x2c5f(%rip),%rsi        # 4033d2 <chdir+0x71>
  400773:	48 89 c7             	mov    %rax,%rdi
  400776:	e8 80 13 00 00       	callq  401afb <tokenize>
  40077b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	strcpy(oldSysPath,token->tokenArr[1]);
  40077f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  400783:	48 8b 50 10          	mov    0x10(%rax),%rdx
  400787:	48 8d 85 e8 fb ff ff 	lea    -0x418(%rbp),%rax
  40078e:	48 89 d6             	mov    %rdx,%rsi
  400791:	48 89 c7             	mov    %rax,%rdi
  400794:	e8 7d 22 00 00       	callq  402a16 <strcpy>

	/*
	 * First element of the tokenColon always needs to be addes ASIS
	 * Check if the component to add is ${PATH}.If yes send oldSysPath
	 */
	if((strcmp(tokenColon->tokenArr[0],"${PATH}")==0)||(strcmp(tokenColon->tokenArr[0],"$PATH")==0)){
  400799:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40079d:	48 8b 40 08          	mov    0x8(%rax),%rax
  4007a1:	48 8d 35 32 2c 00 00 	lea    0x2c32(%rip),%rsi        # 4033da <chdir+0x79>
  4007a8:	48 89 c7             	mov    %rax,%rdi
  4007ab:	e8 c5 22 00 00       	callq  402a75 <strcmp>
  4007b0:	85 c0                	test   %eax,%eax
  4007b2:	74 1b                	je     4007cf <set+0x13b>
  4007b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4007b8:	48 8b 40 08          	mov    0x8(%rax),%rax
  4007bc:	48 8d 35 1f 2c 00 00 	lea    0x2c1f(%rip),%rsi        # 4033e2 <chdir+0x81>
  4007c3:	48 89 c7             	mov    %rax,%rdi
  4007c6:	e8 aa 22 00 00       	callq  402a75 <strcmp>
  4007cb:	85 c0                	test   %eax,%eax
  4007cd:	75 24                	jne    4007f3 <set+0x15f>
		path = setPath(*envLoc,oldSysPath,EASIS);
  4007cf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4007d3:	48 8b 00             	mov    (%rax),%rax
  4007d6:	48 8d 8d e8 fb ff ff 	lea    -0x418(%rbp),%rcx
  4007dd:	ba 01 00 00 00       	mov    $0x1,%edx
  4007e2:	48 89 ce             	mov    %rcx,%rsi
  4007e5:	48 89 c7             	mov    %rax,%rdi
  4007e8:	e8 81 fd ff ff       	callq  40056e <setPath>
  4007ed:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  4007f1:	eb 23                	jmp    400816 <set+0x182>
		//printf("PATH IS %s\n",path);
	}
	else{
		path = setPath(*envLoc,tokenColon->tokenArr[0],EASIS);
  4007f3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4007f7:	48 8b 48 08          	mov    0x8(%rax),%rcx
  4007fb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4007ff:	48 8b 00             	mov    (%rax),%rax
  400802:	ba 01 00 00 00       	mov    $0x1,%edx
  400807:	48 89 ce             	mov    %rcx,%rsi
  40080a:	48 89 c7             	mov    %rax,%rdi
  40080d:	e8 5c fd ff ff       	callq  40056e <setPath>
  400812:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}

	//Assign the newly modified path to envLoc.This causes the envp array to get updated
	*envLoc = path;
  400816:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40081a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  40081e:	48 89 10             	mov    %rdx,(%rax)

	//printf("The new environment is: %s\n", getenv("PATH"));


	//Append the later elements in a loop
	for(i=1;i<tokenColon->numOfTokens;i++){
  400821:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
  400828:	e9 a0 00 00 00       	jmpq   4008cd <set+0x239>

		/*
		 * Check if the component to add is ${PATH}.If yes send oldSysPath
		 *
		 */
		if((strcmp(tokenColon->tokenArr[i],"${PATH}")==0)||(strcmp(tokenColon->tokenArr[i],"$PATH")==0)){
  40082d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400831:	8b 55 f4             	mov    -0xc(%rbp),%edx
  400834:	48 63 d2             	movslq %edx,%rdx
  400837:	48 8b 44 d0 08       	mov    0x8(%rax,%rdx,8),%rax
  40083c:	48 8d 35 97 2b 00 00 	lea    0x2b97(%rip),%rsi        # 4033da <chdir+0x79>
  400843:	48 89 c7             	mov    %rax,%rdi
  400846:	e8 2a 22 00 00       	callq  402a75 <strcmp>
  40084b:	85 c0                	test   %eax,%eax
  40084d:	74 22                	je     400871 <set+0x1dd>
  40084f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400853:	8b 55 f4             	mov    -0xc(%rbp),%edx
  400856:	48 63 d2             	movslq %edx,%rdx
  400859:	48 8b 44 d0 08       	mov    0x8(%rax,%rdx,8),%rax
  40085e:	48 8d 35 7d 2b 00 00 	lea    0x2b7d(%rip),%rsi        # 4033e2 <chdir+0x81>
  400865:	48 89 c7             	mov    %rax,%rdi
  400868:	e8 08 22 00 00       	callq  402a75 <strcmp>
  40086d:	85 c0                	test   %eax,%eax
  40086f:	75 24                	jne    400895 <set+0x201>
			path = setPath(*envLoc,oldSysPath,EAPPEND);
  400871:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400875:	48 8b 00             	mov    (%rax),%rax
  400878:	48 8d 8d e8 fb ff ff 	lea    -0x418(%rbp),%rcx
  40087f:	ba 02 00 00 00       	mov    $0x2,%edx
  400884:	48 89 ce             	mov    %rcx,%rsi
  400887:	48 89 c7             	mov    %rax,%rdi
  40088a:	e8 df fc ff ff       	callq  40056e <setPath>
  40088f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  400893:	eb 2a                	jmp    4008bf <set+0x22b>
			//printf("PATH IS %s\n",path);
		}
		else{
			path = setPath(*envLoc,tokenColon->tokenArr[i],EAPPEND);
  400895:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400899:	8b 55 f4             	mov    -0xc(%rbp),%edx
  40089c:	48 63 d2             	movslq %edx,%rdx
  40089f:	48 8b 4c d0 08       	mov    0x8(%rax,%rdx,8),%rcx
  4008a4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4008a8:	48 8b 00             	mov    (%rax),%rax
  4008ab:	ba 02 00 00 00       	mov    $0x2,%edx
  4008b0:	48 89 ce             	mov    %rcx,%rsi
  4008b3:	48 89 c7             	mov    %rax,%rdi
  4008b6:	e8 b3 fc ff ff       	callq  40056e <setPath>
  4008bb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		}

		//Assign the newly modified path to envLoc.This causes the envp array to get updated
		*envLoc = path;
  4008bf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4008c3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  4008c7:	48 89 10             	mov    %rdx,(%rax)

	//printf("The new environment is: %s\n", getenv("PATH"));


	//Append the later elements in a loop
	for(i=1;i<tokenColon->numOfTokens;i++){
  4008ca:	ff 45 f4             	incl   -0xc(%rbp)
  4008cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4008d1:	8b 00                	mov    (%rax),%eax
  4008d3:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  4008d6:	0f 8f 51 ff ff ff    	jg     40082d <set+0x199>


	}//End of for loop

	//printf("The new environment is: %s\n", getenv("PATH"));
}
  4008dc:	c9                   	leaveq 
  4008dd:	c3                   	retq   

00000000004008de <executeBuiltins>:
#include <parser.h>
#include <errno.h>
#include <string.h>
#include <shell.h>

void executeBuiltins(parseInfo* command,char*envp[]){
  4008de:	55                   	push   %rbp
  4008df:	48 89 e5             	mov    %rsp,%rbp
  4008e2:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  4008e6:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
  4008ea:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
		printf("Token %d : %s\n",i,command->CommArray[0]->VarList[i]);
	}*/



	if(strcmp(command->CommArray[0]->commandName,"set")==0){
  4008ee:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4008f2:	48 8b 00             	mov    (%rax),%rax
  4008f5:	48 8b 00             	mov    (%rax),%rax
  4008f8:	48 8d 35 e9 2a 00 00 	lea    0x2ae9(%rip),%rsi        # 4033e8 <chdir+0x87>
  4008ff:	48 89 c7             	mov    %rax,%rdi
  400902:	e8 6e 21 00 00       	callq  402a75 <strcmp>
  400907:	85 c0                	test   %eax,%eax
  400909:	0f 85 f5 00 00 00    	jne    400a04 <executeBuiltins+0x126>

		if(strstr(command->CommArray[0]->VarList[1],"PATH")!=NULL){
  40090f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400913:	48 8b 00             	mov    (%rax),%rax
  400916:	48 8b 40 10          	mov    0x10(%rax),%rax
  40091a:	48 8d 35 cb 2a 00 00 	lea    0x2acb(%rip),%rsi        # 4033ec <chdir+0x8b>
  400921:	48 89 c7             	mov    %rax,%rdi
  400924:	e8 d3 21 00 00       	callq  402afc <strstr>
  400929:	48 85 c0             	test   %rax,%rax
  40092c:	74 76                	je     4009a4 <executeBuiltins+0xc6>
			//execute change PATH
			//printf("Going to change path");


			if(command->CommArray[0]->VarNum >2){
  40092e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400932:	48 8b 00             	mov    (%rax),%rax
  400935:	8b 40 58             	mov    0x58(%rax),%eax
  400938:	83 f8 02             	cmp    $0x2,%eax
  40093b:	7e 16                	jle    400953 <executeBuiltins+0x75>

				printf("Too many arguments to set PATH.Please enter set PATH=ABC:XYX:... (no spaces in between)\n");
  40093d:	48 8d 3d b4 2a 00 00 	lea    0x2ab4(%rip),%rdi        # 4033f8 <chdir+0x97>
  400944:	b8 00 00 00 00       	mov    $0x0,%eax
  400949:	e8 bd 19 00 00       	callq  40230b <printf>
				return;
  40094e:	e9 56 01 00 00       	jmpq   400aa9 <executeBuiltins+0x1cb>
			}


			set(command->CommArray[0]->VarList[1],envp);
  400953:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400957:	48 8b 00             	mov    (%rax),%rax
  40095a:	48 8b 40 10          	mov    0x10(%rax),%rax
  40095e:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  400962:	48 89 d6             	mov    %rdx,%rsi
  400965:	48 89 c7             	mov    %rax,%rdi
  400968:	e8 27 fd ff ff       	callq  400694 <set>
			envVar=findEnvVar("PATH",envp);
  40096d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  400971:	48 89 c6             	mov    %rax,%rsi
  400974:	48 8d 3d 71 2a 00 00 	lea    0x2a71(%rip),%rdi        # 4033ec <chdir+0x8b>
  40097b:	e8 04 07 00 00       	callq  401084 <findEnvVar>
  400980:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			printf("Current Path is :\n %s\n",*envVar);
  400984:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  400988:	48 8b 00             	mov    (%rax),%rax
  40098b:	48 89 c6             	mov    %rax,%rsi
  40098e:	48 8d 3d bc 2a 00 00 	lea    0x2abc(%rip),%rdi        # 403451 <chdir+0xf0>
  400995:	b8 00 00 00 00       	mov    $0x0,%eax
  40099a:	e8 6c 19 00 00       	callq  40230b <printf>
  40099f:	e9 04 01 00 00       	jmpq   400aa8 <executeBuiltins+0x1ca>


		}
		else if(strstr(command->CommArray[0]->VarList[1],"PS1")!=NULL){
  4009a4:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4009a8:	48 8b 00             	mov    (%rax),%rax
  4009ab:	48 8b 40 10          	mov    0x10(%rax),%rax
  4009af:	48 8d 35 b2 2a 00 00 	lea    0x2ab2(%rip),%rsi        # 403468 <chdir+0x107>
  4009b6:	48 89 c7             	mov    %rax,%rdi
  4009b9:	e8 3e 21 00 00       	callq  402afc <strstr>
  4009be:	48 85 c0             	test   %rax,%rax
  4009c1:	0f 84 e1 00 00 00    	je     400aa8 <executeBuiltins+0x1ca>
			//simple change the shell variable PS1
			//Add function to remove spaces from PS1=hgchbvh

			//printf("Going to change PS1");

			if(command->CommArray[0]->VarNum >2){
  4009c7:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4009cb:	48 8b 00             	mov    (%rax),%rax
  4009ce:	8b 40 58             	mov    0x58(%rax),%eax
  4009d1:	83 f8 02             	cmp    $0x2,%eax
  4009d4:	7e 16                	jle    4009ec <executeBuiltins+0x10e>

				printf("Too many arguments to set PS1.Please enter set PS1=ABCD (no spaces in between)\n");
  4009d6:	48 8d 3d 93 2a 00 00 	lea    0x2a93(%rip),%rdi        # 403470 <chdir+0x10f>
  4009dd:	b8 00 00 00 00       	mov    $0x0,%eax
  4009e2:	e8 24 19 00 00       	callq  40230b <printf>
				return;
  4009e7:	e9 bd 00 00 00       	jmpq   400aa9 <executeBuiltins+0x1cb>
			}

			changePS1(command->CommArray[0]->VarList[1]);
  4009ec:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4009f0:	48 8b 00             	mov    (%rax),%rax
  4009f3:	48 8b 40 10          	mov    0x10(%rax),%rax
  4009f7:	48 89 c7             	mov    %rax,%rdi
  4009fa:	e8 03 0b 00 00       	callq  401502 <changePS1>
		printf("Current Working Directory is: %s\n",cmdWithoutSpaces);

	}


	return;
  4009ff:	e9 a5 00 00 00       	jmpq   400aa9 <executeBuiltins+0x1cb>

		}
	}


	else if(strcmp(command->CommArray[0]->commandName,"exit")==0){
  400a04:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400a08:	48 8b 00             	mov    (%rax),%rax
  400a0b:	48 8b 00             	mov    (%rax),%rax
  400a0e:	48 8d 35 ab 2a 00 00 	lea    0x2aab(%rip),%rsi        # 4034c0 <chdir+0x15f>
  400a15:	48 89 c7             	mov    %rax,%rdi
  400a18:	e8 58 20 00 00       	callq  402a75 <strcmp>
  400a1d:	85 c0                	test   %eax,%eax
  400a1f:	75 0c                	jne    400a2d <executeBuiltins+0x14f>

		exit(0);
  400a21:	bf 00 00 00 00       	mov    $0x0,%edi
  400a26:	e8 9a 1f 00 00       	callq  4029c5 <exit>
  400a2b:	eb 7b                	jmp    400aa8 <executeBuiltins+0x1ca>
	}

	else if(strcmp(command->CommArray[0]->commandName,"cd")==0) {
  400a2d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400a31:	48 8b 00             	mov    (%rax),%rax
  400a34:	48 8b 00             	mov    (%rax),%rax
  400a37:	48 8d 35 87 2a 00 00 	lea    0x2a87(%rip),%rsi        # 4034c5 <chdir+0x164>
  400a3e:	48 89 c7             	mov    %rax,%rdi
  400a41:	e8 2f 20 00 00       	callq  402a75 <strcmp>
  400a46:	85 c0                	test   %eax,%eax
  400a48:	75 5e                	jne    400aa8 <executeBuiltins+0x1ca>
		if(command->CommArray[0]->VarNum >2){
  400a4a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400a4e:	48 8b 00             	mov    (%rax),%rax
  400a51:	8b 40 58             	mov    0x58(%rax),%eax
  400a54:	83 f8 02             	cmp    $0x2,%eax
  400a57:	7e 13                	jle    400a6c <executeBuiltins+0x18e>

			printf("Too many arguments to cd.Please enter cd <directory name>\n");
  400a59:	48 8d 3d 68 2a 00 00 	lea    0x2a68(%rip),%rdi        # 4034c8 <chdir+0x167>
  400a60:	b8 00 00 00 00       	mov    $0x0,%eax
  400a65:	e8 a1 18 00 00       	callq  40230b <printf>
			return;
  400a6a:	eb 3d                	jmp    400aa9 <executeBuiltins+0x1cb>
		}


		//execute change directory
		changedir(command->CommArray[0]->VarList[1]);
  400a6c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400a70:	48 8b 00             	mov    (%rax),%rax
  400a73:	48 8b 40 10          	mov    0x10(%rax),%rax
  400a77:	48 89 c7             	mov    %rax,%rdi
  400a7a:	e8 c1 f6 ff ff       	callq  400140 <changedir>
		getcwd(cmdWithoutSpaces,100);
  400a7f:	48 8d 45 94          	lea    -0x6c(%rbp),%rax
  400a83:	be 64 00 00 00       	mov    $0x64,%esi
  400a88:	48 89 c7             	mov    %rax,%rdi
  400a8b:	e8 54 14 00 00       	callq  401ee4 <getcwd>
		printf("Current Working Directory is: %s\n",cmdWithoutSpaces);
  400a90:	48 8d 45 94          	lea    -0x6c(%rbp),%rax
  400a94:	48 89 c6             	mov    %rax,%rsi
  400a97:	48 8d 3d 6a 2a 00 00 	lea    0x2a6a(%rip),%rdi        # 403508 <chdir+0x1a7>
  400a9e:	b8 00 00 00 00       	mov    $0x0,%eax
  400aa3:	e8 63 18 00 00       	callq  40230b <printf>

	}


	return;
  400aa8:	90                   	nop


}
  400aa9:	c9                   	leaveq 
  400aaa:	c3                   	retq   

0000000000400aab <execute_cmd>:
#include <shell.h>



void execute_cmd(parseInfo * info,char*envp[])
{
  400aab:	55                   	push   %rbp
  400aac:	48 89 e5             	mov    %rsp,%rbp
  400aaf:	53                   	push   %rbx
  400ab0:	48 81 ec 28 08 00 00 	sub    $0x828,%rsp
  400ab7:	48 89 bd d8 f7 ff ff 	mov    %rdi,-0x828(%rbp)
  400abe:	48 89 b5 d0 f7 ff ff 	mov    %rsi,-0x830(%rbp)
	int i,j,*pipes=NULL,status;
  400ac5:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  400acc:	00 
	char cmd[20][100];

	int  *proc_ids;
	//printf("pipes=%d \n",info->pipeNum);

	for(i=0; i<=info->pipeNum; i++)
  400acd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  400ad4:	eb 36                	jmp    400b0c <execute_cmd+0x61>
	{
		//printf("info: %s\n", info->CommArray[i]->commandName);
		strcpy(cmd[i],info->CommArray[i]->commandName);
  400ad6:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400add:	8b 55 ec             	mov    -0x14(%rbp),%edx
  400ae0:	48 63 d2             	movslq %edx,%rdx
  400ae3:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  400ae7:	48 8b 00             	mov    (%rax),%rax
  400aea:	48 8d 8d fc f7 ff ff 	lea    -0x804(%rbp),%rcx
  400af1:	8b 55 ec             	mov    -0x14(%rbp),%edx
  400af4:	48 63 d2             	movslq %edx,%rdx
  400af7:	48 6b d2 64          	imul   $0x64,%rdx,%rdx
  400afb:	48 01 ca             	add    %rcx,%rdx
  400afe:	48 89 c6             	mov    %rax,%rsi
  400b01:	48 89 d7             	mov    %rdx,%rdi
  400b04:	e8 0d 1f 00 00       	callq  402a16 <strcpy>
	char cmd[20][100];

	int  *proc_ids;
	//printf("pipes=%d \n",info->pipeNum);

	for(i=0; i<=info->pipeNum; i++)
  400b09:	ff 45 ec             	incl   -0x14(%rbp)
  400b0c:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400b13:	8b 40 50             	mov    0x50(%rax),%eax
  400b16:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  400b19:	7d bb                	jge    400ad6 <execute_cmd+0x2b>
		//printf("varList=%s\n",info->CommArray[i]->VarList[j]);
	}



	proc_ids = (int *)malloc(info->pipeNum+1);
  400b1b:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400b22:	8b 40 50             	mov    0x50(%rax),%eax
  400b25:	ff c0                	inc    %eax
  400b27:	48 98                	cltq   
  400b29:	48 89 c7             	mov    %rax,%rdi
  400b2c:	e8 30 26 00 00       	callq  403161 <malloc>
  400b31:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	if(info->pipeNum==0)
  400b35:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400b3c:	8b 40 50             	mov    0x50(%rax),%eax
  400b3f:	85 c0                	test   %eax,%eax
  400b41:	0f 85 ca 00 00 00    	jne    400c11 <execute_cmd+0x166>
	{
		printf("forking");
  400b47:	48 8d 3d dc 29 00 00 	lea    0x29dc(%rip),%rdi        # 40352a <chdir+0x1c9>
  400b4e:	b8 00 00 00 00       	mov    $0x0,%eax
  400b53:	e8 b3 17 00 00       	callq  40230b <printf>


		proc_ids[0]=fork();
  400b58:	e8 fd 1d 00 00       	callq  40295a <fork>
  400b5d:	89 c2                	mov    %eax,%edx
  400b5f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400b63:	89 10                	mov    %edx,(%rax)

		if (proc_ids[0] < 0)
  400b65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400b69:	8b 00                	mov    (%rax),%eax
  400b6b:	85 c0                	test   %eax,%eax
  400b6d:	79 1a                	jns    400b89 <execute_cmd+0xde>
		{
			strerror( errno);
  400b6f:	48 8b 05 da 39 20 00 	mov    0x2039da(%rip),%rax        # 604550 <chdir+0x2011ef>
  400b76:	8b 00                	mov    (%rax),%eax
  400b78:	89 c7                	mov    %eax,%edi
  400b7a:	e8 96 20 00 00       	callq  402c15 <strerror>
			exit(1);
  400b7f:	bf 01 00 00 00       	mov    $0x1,%edi
  400b84:	e8 3c 1e 00 00       	callq  4029c5 <exit>
		}
		if(proc_ids[0]==0)
  400b89:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400b8d:	8b 00                	mov    (%rax),%eax
  400b8f:	85 c0                	test   %eax,%eax
  400b91:	0f 85 08 03 00 00    	jne    400e9f <execute_cmd+0x3f4>
		{
			//printf("executing %s\n",cmd[0]);

			printf("Executing Command %s\n",cmd[0]);
  400b97:	48 8d 85 fc f7 ff ff 	lea    -0x804(%rbp),%rax
  400b9e:	48 89 c6             	mov    %rax,%rsi
  400ba1:	48 8d 3d 8a 29 00 00 	lea    0x298a(%rip),%rdi        # 403532 <chdir+0x1d1>
  400ba8:	b8 00 00 00 00       	mov    $0x0,%eax
  400bad:	e8 59 17 00 00       	callq  40230b <printf>

			char* envpChildProcess[]={NULL};
  400bb2:	48 c7 85 f0 f7 ff ff 	movq   $0x0,-0x810(%rbp)
  400bb9:	00 00 00 00 
			int ret = execve(cmd[0],info->CommArray[0]->VarList,envpChildProcess);
  400bbd:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400bc4:	48 8b 00             	mov    (%rax),%rax
  400bc7:	48 8d 48 08          	lea    0x8(%rax),%rcx
  400bcb:	48 8d 95 f0 f7 ff ff 	lea    -0x810(%rbp),%rdx
  400bd2:	48 8d 85 fc f7 ff ff 	lea    -0x804(%rbp),%rax
  400bd9:	48 89 ce             	mov    %rcx,%rsi
  400bdc:	48 89 c7             	mov    %rax,%rdi
  400bdf:	e8 15 1d 00 00       	callq  4028f9 <execve>
  400be4:	89 45 d4             	mov    %eax,-0x2c(%rbp)
			if(ret == -1)
  400be7:	83 7d d4 ff          	cmpl   $0xffffffff,-0x2c(%rbp)
  400beb:	75 1f                	jne    400c0c <execute_cmd+0x161>
			{
				strerror(errno);
  400bed:	48 8b 05 5c 39 20 00 	mov    0x20395c(%rip),%rax        # 604550 <chdir+0x2011ef>
  400bf4:	8b 00                	mov    (%rax),%eax
  400bf6:	89 c7                	mov    %eax,%edi
  400bf8:	e8 18 20 00 00       	callq  402c15 <strerror>
				exit(1);
  400bfd:	bf 01 00 00 00       	mov    $0x1,%edi
  400c02:	e8 be 1d 00 00       	callq  4029c5 <exit>
  400c07:	e9 93 02 00 00       	jmpq   400e9f <execute_cmd+0x3f4>
  400c0c:	e9 8e 02 00 00       	jmpq   400e9f <execute_cmd+0x3f4>
		//printf("\ndone\n");
	}
	else
	{

		pipes=(int*)malloc(2*info->pipeNum*sizeof(int));
  400c11:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400c18:	8b 40 50             	mov    0x50(%rax),%eax
  400c1b:	48 98                	cltq   
  400c1d:	48 c1 e0 03          	shl    $0x3,%rax
  400c21:	48 89 c7             	mov    %rax,%rdi
  400c24:	e8 38 25 00 00       	callq  403161 <malloc>
  400c29:	48 89 45 e0          	mov    %rax,-0x20(%rbp)


		for(i=0; i<info->pipeNum; i++)
  400c2d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  400c34:	eb 34                	jmp    400c6a <execute_cmd+0x1bf>
		{
			if(pipe(pipes+i*2) == -1)
  400c36:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400c39:	48 98                	cltq   
  400c3b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  400c42:	00 
  400c43:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400c47:	48 01 d0             	add    %rdx,%rax
  400c4a:	48 89 c7             	mov    %rax,%rdi
  400c4d:	e8 3e 1c 00 00       	callq  402890 <pipe>
  400c52:	83 f8 ff             	cmp    $0xffffffff,%eax
  400c55:	75 10                	jne    400c67 <execute_cmd+0x1bc>
				strerror(errno);
  400c57:	48 8b 05 f2 38 20 00 	mov    0x2038f2(%rip),%rax        # 604550 <chdir+0x2011ef>
  400c5e:	8b 00                	mov    (%rax),%eax
  400c60:	89 c7                	mov    %eax,%edi
  400c62:	e8 ae 1f 00 00       	callq  402c15 <strerror>
	{

		pipes=(int*)malloc(2*info->pipeNum*sizeof(int));


		for(i=0; i<info->pipeNum; i++)
  400c67:	ff 45 ec             	incl   -0x14(%rbp)
  400c6a:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400c71:	8b 40 50             	mov    0x50(%rax),%eax
  400c74:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  400c77:	7f bd                	jg     400c36 <execute_cmd+0x18b>
		{
			if(pipe(pipes+i*2) == -1)
				strerror(errno);
		}
		//printf("Multiple Commands");
		for(i=0; i<=info->pipeNum;i++)
  400c79:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  400c80:	e9 b2 01 00 00       	jmpq   400e37 <execute_cmd+0x38c>
		{
			proc_ids[i]=fork();
  400c85:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400c88:	48 98                	cltq   
  400c8a:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400c91:	00 
  400c92:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400c96:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  400c9a:	e8 bb 1c 00 00       	callq  40295a <fork>
  400c9f:	89 03                	mov    %eax,(%rbx)
			if (proc_ids[i] < 0)
  400ca1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400ca4:	48 98                	cltq   
  400ca6:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400cad:	00 
  400cae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400cb2:	48 01 d0             	add    %rdx,%rax
  400cb5:	8b 00                	mov    (%rax),%eax
  400cb7:	85 c0                	test   %eax,%eax
  400cb9:	79 1a                	jns    400cd5 <execute_cmd+0x22a>
			{
				strerror(errno);
  400cbb:	48 8b 05 8e 38 20 00 	mov    0x20388e(%rip),%rax        # 604550 <chdir+0x2011ef>
  400cc2:	8b 00                	mov    (%rax),%eax
  400cc4:	89 c7                	mov    %eax,%edi
  400cc6:	e8 4a 1f 00 00       	callq  402c15 <strerror>
				exit(1);
  400ccb:	bf 01 00 00 00       	mov    $0x1,%edi
  400cd0:	e8 f0 1c 00 00       	callq  4029c5 <exit>
			}
			//printf("pid=%d",proc_ids[i]);
			if(proc_ids[i]==0)
  400cd5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400cd8:	48 98                	cltq   
  400cda:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400ce1:	00 
  400ce2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400ce6:	48 01 d0             	add    %rdx,%rax
  400ce9:	8b 00                	mov    (%rax),%eax
  400ceb:	85 c0                	test   %eax,%eax
  400ced:	0f 85 41 01 00 00    	jne    400e34 <execute_cmd+0x389>
			{
				//printf("in child%d",i);

				if(i!=0)
  400cf3:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  400cf7:	74 37                	je     400d30 <execute_cmd+0x285>
				{
					if(dup2(pipes[i*2-2],0)==-1)
  400cf9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400cfc:	48 98                	cltq   
  400cfe:	48 c1 e0 03          	shl    $0x3,%rax
  400d02:	48 8d 50 f8          	lea    -0x8(%rax),%rdx
  400d06:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400d0a:	48 01 d0             	add    %rdx,%rax
  400d0d:	8b 00                	mov    (%rax),%eax
  400d0f:	be 00 00 00 00       	mov    $0x0,%esi
  400d14:	89 c7                	mov    %eax,%edi
  400d16:	e8 f5 10 00 00       	callq  401e10 <dup2>
  400d1b:	83 f8 ff             	cmp    $0xffffffff,%eax
  400d1e:	75 10                	jne    400d30 <execute_cmd+0x285>
						strerror(errno);
  400d20:	48 8b 05 29 38 20 00 	mov    0x203829(%rip),%rax        # 604550 <chdir+0x2011ef>
  400d27:	8b 00                	mov    (%rax),%eax
  400d29:	89 c7                	mov    %eax,%edi
  400d2b:	e8 e5 1e 00 00       	callq  402c15 <strerror>
				}
				if(i!=info->pipeNum)
  400d30:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400d37:	8b 40 50             	mov    0x50(%rax),%eax
  400d3a:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  400d3d:	74 37                	je     400d76 <execute_cmd+0x2cb>
				{

					if(dup2(pipes[i*2+1],1)==-1)
  400d3f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400d42:	48 98                	cltq   
  400d44:	48 c1 e0 03          	shl    $0x3,%rax
  400d48:	48 8d 50 04          	lea    0x4(%rax),%rdx
  400d4c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400d50:	48 01 d0             	add    %rdx,%rax
  400d53:	8b 00                	mov    (%rax),%eax
  400d55:	be 01 00 00 00       	mov    $0x1,%esi
  400d5a:	89 c7                	mov    %eax,%edi
  400d5c:	e8 af 10 00 00       	callq  401e10 <dup2>
  400d61:	83 f8 ff             	cmp    $0xffffffff,%eax
  400d64:	75 10                	jne    400d76 <execute_cmd+0x2cb>
						strerror(errno);
  400d66:	48 8b 05 e3 37 20 00 	mov    0x2037e3(%rip),%rax        # 604550 <chdir+0x2011ef>
  400d6d:	8b 00                	mov    (%rax),%eax
  400d6f:	89 c7                	mov    %eax,%edi
  400d71:	e8 9f 1e 00 00       	callq  402c15 <strerror>
				}

				for(j=0;j<info->pipeNum;j++)
  400d76:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
  400d7d:	eb 3d                	jmp    400dbc <execute_cmd+0x311>
				{
					close(pipes[j*2]);
  400d7f:	8b 45 e8             	mov    -0x18(%rbp),%eax
  400d82:	48 98                	cltq   
  400d84:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  400d8b:	00 
  400d8c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400d90:	48 01 d0             	add    %rdx,%rax
  400d93:	8b 00                	mov    (%rax),%eax
  400d95:	89 c7                	mov    %eax,%edi
  400d97:	e8 c7 11 00 00       	callq  401f63 <close>
					close(pipes[j*2+1]);
  400d9c:	8b 45 e8             	mov    -0x18(%rbp),%eax
  400d9f:	48 98                	cltq   
  400da1:	48 c1 e0 03          	shl    $0x3,%rax
  400da5:	48 8d 50 04          	lea    0x4(%rax),%rdx
  400da9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400dad:	48 01 d0             	add    %rdx,%rax
  400db0:	8b 00                	mov    (%rax),%eax
  400db2:	89 c7                	mov    %eax,%edi
  400db4:	e8 aa 11 00 00       	callq  401f63 <close>

					if(dup2(pipes[i*2+1],1)==-1)
						strerror(errno);
				}

				for(j=0;j<info->pipeNum;j++)
  400db9:	ff 45 e8             	incl   -0x18(%rbp)
  400dbc:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400dc3:	8b 40 50             	mov    0x50(%rax),%eax
  400dc6:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  400dc9:	7f b4                	jg     400d7f <execute_cmd+0x2d4>
				//printf("debug:%s ", cmd[i]);


				//printf("Executing Command %s\n",cmd[i]);

				char* envpChildProcess[]={NULL};
  400dcb:	48 c7 85 e8 f7 ff ff 	movq   $0x0,-0x818(%rbp)
  400dd2:	00 00 00 00 
				int ret=execve(cmd[i],info->CommArray[i]->VarList,envpChildProcess);
  400dd6:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400ddd:	8b 55 ec             	mov    -0x14(%rbp),%edx
  400de0:	48 63 d2             	movslq %edx,%rdx
  400de3:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  400de7:	48 8d 70 08          	lea    0x8(%rax),%rsi
  400deb:	48 8d 95 fc f7 ff ff 	lea    -0x804(%rbp),%rdx
  400df2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400df5:	48 98                	cltq   
  400df7:	48 6b c0 64          	imul   $0x64,%rax,%rax
  400dfb:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  400dff:	48 8d 85 e8 f7 ff ff 	lea    -0x818(%rbp),%rax
  400e06:	48 89 c2             	mov    %rax,%rdx
  400e09:	48 89 cf             	mov    %rcx,%rdi
  400e0c:	e8 e8 1a 00 00       	callq  4028f9 <execve>
  400e11:	89 45 d0             	mov    %eax,-0x30(%rbp)
				if(ret == -1)
  400e14:	83 7d d0 ff          	cmpl   $0xffffffff,-0x30(%rbp)
  400e18:	75 1a                	jne    400e34 <execute_cmd+0x389>
				{
					strerror(errno);
  400e1a:	48 8b 05 2f 37 20 00 	mov    0x20372f(%rip),%rax        # 604550 <chdir+0x2011ef>
  400e21:	8b 00                	mov    (%rax),%eax
  400e23:	89 c7                	mov    %eax,%edi
  400e25:	e8 eb 1d 00 00       	callq  402c15 <strerror>
					exit(1);
  400e2a:	bf 01 00 00 00       	mov    $0x1,%edi
  400e2f:	e8 91 1b 00 00       	callq  4029c5 <exit>
		{
			if(pipe(pipes+i*2) == -1)
				strerror(errno);
		}
		//printf("Multiple Commands");
		for(i=0; i<=info->pipeNum;i++)
  400e34:	ff 45 ec             	incl   -0x14(%rbp)
  400e37:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400e3e:	8b 40 50             	mov    0x50(%rax),%eax
  400e41:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  400e44:	0f 8d 3b fe ff ff    	jge    400c85 <execute_cmd+0x1da>
				}
			}
		}
		//printf("\nin multiple's parent\n");

		for(i=0;i<info->pipeNum;i++)
  400e4a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  400e51:	eb 3d                	jmp    400e90 <execute_cmd+0x3e5>
		{
			close(pipes[i*2]);
  400e53:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400e56:	48 98                	cltq   
  400e58:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  400e5f:	00 
  400e60:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400e64:	48 01 d0             	add    %rdx,%rax
  400e67:	8b 00                	mov    (%rax),%eax
  400e69:	89 c7                	mov    %eax,%edi
  400e6b:	e8 f3 10 00 00       	callq  401f63 <close>
			close(pipes[i*2+1]);
  400e70:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400e73:	48 98                	cltq   
  400e75:	48 c1 e0 03          	shl    $0x3,%rax
  400e79:	48 8d 50 04          	lea    0x4(%rax),%rdx
  400e7d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400e81:	48 01 d0             	add    %rdx,%rax
  400e84:	8b 00                	mov    (%rax),%eax
  400e86:	89 c7                	mov    %eax,%edi
  400e88:	e8 d6 10 00 00       	callq  401f63 <close>
				}
			}
		}
		//printf("\nin multiple's parent\n");

		for(i=0;i<info->pipeNum;i++)
  400e8d:	ff 45 ec             	incl   -0x14(%rbp)
  400e90:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400e97:	8b 40 50             	mov    0x50(%rax),%eax
  400e9a:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  400e9d:	7f b4                	jg     400e53 <execute_cmd+0x3a8>
			close(pipes[i*2+1]);
			//printf("closed");
		}
	}
	//printf("\nin singles's parent\n");
	for (i = 0; i <= info->pipeNum; i++)
  400e9f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  400ea6:	eb 2c                	jmp    400ed4 <execute_cmd+0x429>
		waitpid(proc_ids[i], &status, 0);
  400ea8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400eab:	48 98                	cltq   
  400ead:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400eb4:	00 
  400eb5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400eb9:	48 01 d0             	add    %rdx,%rax
  400ebc:	8b 00                	mov    (%rax),%eax
  400ebe:	48 8d 4d cc          	lea    -0x34(%rbp),%rcx
  400ec2:	ba 00 00 00 00       	mov    $0x0,%edx
  400ec7:	48 89 ce             	mov    %rcx,%rsi
  400eca:	89 c7                	mov    %eax,%edi
  400ecc:	e8 68 11 00 00       	callq  402039 <waitpid>
			close(pipes[i*2+1]);
			//printf("closed");
		}
	}
	//printf("\nin singles's parent\n");
	for (i = 0; i <= info->pipeNum; i++)
  400ed1:	ff 45 ec             	incl   -0x14(%rbp)
  400ed4:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400edb:	8b 40 50             	mov    0x50(%rax),%eax
  400ede:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  400ee1:	7d c5                	jge    400ea8 <execute_cmd+0x3fd>
		waitpid(proc_ids[i], &status, 0);
	//printf("child returned:%d\n",waitpid(proc_ids[i], &status, 0));

}
  400ee3:	48 81 c4 28 08 00 00 	add    $0x828,%rsp
  400eea:	5b                   	pop    %rbx
  400eeb:	5d                   	pop    %rbp
  400eec:	c3                   	retq   

0000000000400eed <find_file_in_dir>:




char* find_file_in_dir (char *path, char *file)
{
  400eed:	55                   	push   %rbp
  400eee:	48 89 e5             	mov    %rsp,%rbp
  400ef1:	48 83 ec 30          	sub    $0x30,%rsp
  400ef5:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  400ef9:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	struct dirent *entry=NULL;
  400efd:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  400f04:	00 
	char* ret = NULL;
  400f05:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  400f0c:	00 
	//ret=NULL;
	void *dir;
	dir = opendir (path);
  400f0d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400f11:	48 89 c7             	mov    %rax,%rdi
  400f14:	e8 50 18 00 00       	callq  402769 <opendir>
  400f19:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if(dir == NULL)
  400f1d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  400f22:	75 0a                	jne    400f2e <find_file_in_dir+0x41>
		return (char *)NULL;
  400f24:	b8 00 00 00 00       	mov    $0x0,%eax
  400f29:	e9 ae 00 00 00       	jmpq   400fdc <find_file_in_dir+0xef>

	errno = 0;
  400f2e:	48 8b 05 1b 36 20 00 	mov    0x20361b(%rip),%rax        # 604550 <chdir+0x2011ef>
  400f35:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	//printf("In find_file_in_dir....searching %s\n",path);
	while ((entry = readdir (dir)) != NULL) {
  400f3b:	eb 3e                	jmp    400f7b <find_file_in_dir+0x8e>
		//printf("entry->dname=%s file=%s",entry->d_name, file);
		if (!strcmp(entry->d_name, file)) {
  400f3d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  400f41:	48 8d 50 12          	lea    0x12(%rax),%rdx
  400f45:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  400f49:	48 89 c6             	mov    %rax,%rsi
  400f4c:	48 89 d7             	mov    %rdx,%rdi
  400f4f:	e8 21 1b 00 00       	callq  402a75 <strcmp>
  400f54:	85 c0                	test   %eax,%eax
  400f56:	75 23                	jne    400f7b <find_file_in_dir+0x8e>
			ret=malloc(sizeof(strlen(path)+1));
  400f58:	bf 04 00 00 00       	mov    $0x4,%edi
  400f5d:	e8 ff 21 00 00       	callq  403161 <malloc>
  400f62:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			strcpy(ret,path);
  400f66:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  400f6a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  400f6e:	48 89 d6             	mov    %rdx,%rsi
  400f71:	48 89 c7             	mov    %rax,%rdi
  400f74:	e8 9d 1a 00 00       	callq  402a16 <strcpy>
			break;
  400f79:	eb 17                	jmp    400f92 <find_file_in_dir+0xa5>
	if(dir == NULL)
		return (char *)NULL;

	errno = 0;
	//printf("In find_file_in_dir....searching %s\n",path);
	while ((entry = readdir (dir)) != NULL) {
  400f7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400f7f:	48 89 c7             	mov    %rax,%rdi
  400f82:	e8 b7 0d 00 00       	callq  401d3e <readdir>
  400f87:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  400f8b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  400f90:	75 ab                	jne    400f3d <find_file_in_dir+0x50>
			ret=malloc(sizeof(strlen(path)+1));
			strcpy(ret,path);
			break;
		}
	}
	if (errno && !entry){
  400f92:	48 8b 05 b7 35 20 00 	mov    0x2035b7(%rip),%rax        # 604550 <chdir+0x2011ef>
  400f99:	8b 00                	mov    (%rax),%eax
  400f9b:	85 c0                	test   %eax,%eax
  400f9d:	74 17                	je     400fb6 <find_file_in_dir+0xc9>
  400f9f:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  400fa4:	75 10                	jne    400fb6 <find_file_in_dir+0xc9>
		strerror(errno);
  400fa6:	48 8b 05 a3 35 20 00 	mov    0x2035a3(%rip),%rax        # 604550 <chdir+0x2011ef>
  400fad:	8b 00                	mov    (%rax),%eax
  400faf:	89 c7                	mov    %eax,%edi
  400fb1:	e8 5f 1c 00 00       	callq  402c15 <strerror>
	}

	if(closedir (dir) == -1){
  400fb6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400fba:	48 89 c7             	mov    %rax,%rdi
  400fbd:	e8 ef 10 00 00       	callq  4020b1 <closedir>
  400fc2:	83 f8 ff             	cmp    $0xffffffff,%eax
  400fc5:	75 11                	jne    400fd8 <find_file_in_dir+0xeb>

		printf("Fatal error. Could not close a directory\n");
  400fc7:	48 8d 3d 7a 25 00 00 	lea    0x257a(%rip),%rdi        # 403548 <chdir+0x1e7>
  400fce:	b8 00 00 00 00       	mov    $0x0,%eax
  400fd3:	e8 33 13 00 00       	callq  40230b <printf>

	}


	//printf("In find_file_in_dir....returning %s\n",ret);
	return ret;
  400fd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  400fdc:	c9                   	leaveq 
  400fdd:	c3                   	retq   

0000000000400fde <findBinaryFullPath>:


char* findBinaryFullPath(char* srchPath,char* binaryName){
  400fde:	55                   	push   %rbp
  400fdf:	48 89 e5             	mov    %rsp,%rbp
  400fe2:	48 83 ec 60          	sub    $0x60,%rsp
  400fe6:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  400fea:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	 * Else if none of the above are there then find the full path
	 *
	 */

	int i;
	char* x=NULL;
  400fee:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  400ff5:	00 
	//printf("In find full binary path\n");


	//printf("After strstr call. Search Path is :%s \n",srchPath);

	Token* dirToSearch = tokenize(srchPath,":");
  400ff6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  400ffa:	48 8d 35 71 25 00 00 	lea    0x2571(%rip),%rsi        # 403572 <chdir+0x211>
  401001:	48 89 c7             	mov    %rax,%rdi
  401004:	e8 f2 0a 00 00       	callq  401afb <tokenize>
  401009:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	//printf("After tokenize on : Number of tokens %d\n",dirToSearch->numOfTokens);

	for(i=0;i<dirToSearch->numOfTokens;i++){
  40100d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  401014:	eb 5d                	jmp    401073 <findBinaryFullPath+0x95>

		//printf("Calling find_file_in_dir token number %d of %d",i,dirToSearch->numOfTokens);
		//printf("\n\npath component 1 %s\n\n",dirToSearch->tokenArr[i]);
		strcpy(temp,dirToSearch->tokenArr[i]);
  401016:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40101a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  40101d:	48 63 d2             	movslq %edx,%rdx
  401020:	48 8b 54 d0 08       	mov    0x8(%rax,%rdx,8),%rdx
  401025:	48 8d 45 b6          	lea    -0x4a(%rbp),%rax
  401029:	48 89 d6             	mov    %rdx,%rsi
  40102c:	48 89 c7             	mov    %rax,%rdi
  40102f:	e8 e2 19 00 00       	callq  402a16 <strcpy>
		printf("\n\nBefore calling find_file_in_dir %s binary=%s\n",temp, binaryName	);
  401034:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  401038:	48 8d 45 b6          	lea    -0x4a(%rbp),%rax
  40103c:	48 89 c6             	mov    %rax,%rsi
  40103f:	48 8d 3d 32 25 00 00 	lea    0x2532(%rip),%rdi        # 403578 <chdir+0x217>
  401046:	b8 00 00 00 00       	mov    $0x0,%eax
  40104b:	e8 bb 12 00 00       	callq  40230b <printf>

		x=find_file_in_dir(temp,binaryName);
  401050:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  401054:	48 8d 45 b6          	lea    -0x4a(%rbp),%rax
  401058:	48 89 d6             	mov    %rdx,%rsi
  40105b:	48 89 c7             	mov    %rax,%rdi
  40105e:	e8 8a fe ff ff       	callq  400eed <find_file_in_dir>
  401063:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		if(x!=NULL){
  401067:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  40106c:	74 02                	je     401070 <findBinaryFullPath+0x92>

			break;
  40106e:	eb 0e                	jmp    40107e <findBinaryFullPath+0xa0>

	Token* dirToSearch = tokenize(srchPath,":");

	//printf("After tokenize on : Number of tokens %d\n",dirToSearch->numOfTokens);

	for(i=0;i<dirToSearch->numOfTokens;i++){
  401070:	ff 45 fc             	incl   -0x4(%rbp)
  401073:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401077:	8b 00                	mov    (%rax),%eax
  401079:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  40107c:	7f 98                	jg     401016 <findBinaryFullPath+0x38>

		}
	}


	return x;
  40107e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax


}
  401082:	c9                   	leaveq 
  401083:	c3                   	retq   

0000000000401084 <findEnvVar>:
#include <parser.h>
#include <errno.h>
#include <string.h>
#include <shell.h>

char** findEnvVar(char* envVar, char* envp[]){
  401084:	55                   	push   %rbp
  401085:	48 89 e5             	mov    %rsp,%rbp
  401088:	48 83 ec 20          	sub    $0x20,%rsp
  40108c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401090:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	 * envVar in the evnp[]. It returns a pointer, which is a pointer to the array
	 * envp[] that contains a the pointer to the envVar string.
	 * If not found returns null.
	 */

	int count=0;
  401094:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	Token* tokens;

	//printf("Inside findEnv var\n");
    
	while(envp[count]!= NULL){
  40109b:	eb 6a                	jmp    401107 <findEnvVar+0x83>

		tokens = tokenize(envp[count],"=");
  40109d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4010a0:	48 98                	cltq   
  4010a2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  4010a9:	00 
  4010aa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4010ae:	48 01 d0             	add    %rdx,%rax
  4010b1:	48 8b 00             	mov    (%rax),%rax
  4010b4:	48 8d 35 ed 24 00 00 	lea    0x24ed(%rip),%rsi        # 4035a8 <chdir+0x247>
  4010bb:	48 89 c7             	mov    %rax,%rdi
  4010be:	e8 38 0a 00 00       	callq  401afb <tokenize>
  4010c3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		//printf("%s\n",envp[count]);

		if(strcmp(tokens->tokenArr[0],envVar)==0){
  4010c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4010cb:	48 8b 40 08          	mov    0x8(%rax),%rax
  4010cf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  4010d3:	48 89 d6             	mov    %rdx,%rsi
  4010d6:	48 89 c7             	mov    %rax,%rdi
  4010d9:	e8 97 19 00 00       	callq  402a75 <strcmp>
  4010de:	85 c0                	test   %eax,%eax
  4010e0:	75 16                	jne    4010f8 <findEnvVar+0x74>
			return(envp+count);
  4010e2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4010e5:	48 98                	cltq   
  4010e7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  4010ee:	00 
  4010ef:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4010f3:	48 01 d0             	add    %rdx,%rax
  4010f6:	eb 34                	jmp    40112c <findEnvVar+0xa8>
		}
		free(tokens);
  4010f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4010fc:	48 89 c7             	mov    %rax,%rdi
  4010ff:	e8 ca 21 00 00       	callq  4032ce <free>
		count++;
  401104:	ff 45 fc             	incl   -0x4(%rbp)
	int count=0;
	Token* tokens;

	//printf("Inside findEnv var\n");
    
	while(envp[count]!= NULL){
  401107:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40110a:	48 98                	cltq   
  40110c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  401113:	00 
  401114:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  401118:	48 01 d0             	add    %rdx,%rax
  40111b:	48 8b 00             	mov    (%rax),%rax
  40111e:	48 85 c0             	test   %rax,%rax
  401121:	0f 85 76 ff ff ff    	jne    40109d <findEnvVar+0x19>
			return(envp+count);
		}
		free(tokens);
		count++;
	}
	return (char**)NULL;
  401127:	b8 00 00 00 00       	mov    $0x0,%eax
}
  40112c:	c9                   	leaveq 
  40112d:	c3                   	retq   

000000000040112e <main1>:
#include <stdio.h>

int main1(int argc, char* argv[], char* envp[]) {
  40112e:	55                   	push   %rbp
  40112f:	48 89 e5             	mov    %rsp,%rbp
  401132:	48 83 ec 20          	sub    $0x20,%rsp
  401136:	89 7d fc             	mov    %edi,-0x4(%rbp)
  401139:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  40113d:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	printf("Hello World!\n");
  401141:	48 8d 3d 62 24 00 00 	lea    0x2462(%rip),%rdi        # 4035aa <chdir+0x249>
  401148:	b8 00 00 00 00       	mov    $0x0,%eax
  40114d:	e8 b9 11 00 00       	callq  40230b <printf>
	return 0;
  401152:	b8 00 00 00 00       	mov    $0x0,%eax
}
  401157:	c9                   	leaveq 
  401158:	c3                   	retq   

0000000000401159 <print_info>:
#include <shell.h>




void print_info (parseInfo *info) {
  401159:	55                   	push   %rbp
  40115a:	48 89 e5             	mov    %rsp,%rbp
  40115d:	48 83 ec 20          	sub    $0x20,%rsp
  401161:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	printf("print_info: printing info about parseInfo struct\n");
  401165:	48 8d 3d 4c 24 00 00 	lea    0x244c(%rip),%rdi        # 4035b8 <chdir+0x257>
  40116c:	b8 00 00 00 00       	mov    $0x0,%eax
  401171:	e8 95 11 00 00       	callq  40230b <printf>
	//printf("Number of pipe separated commands %d\n",info->pipeNum);


	int i,j;

	for(i=0;i<=info->pipeNum;i++){
  401176:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  40117d:	eb 25                	jmp    4011a4 <print_info+0x4b>
		//printf("Command Name : %s\n",info->CommArray[i]->commandName);

		//printf("Command Arguments :\n");
		//printf("Number of arguments %d\n",info->CommArray[i]->VarNum);

		for(j=0;j<info->CommArray[i]->VarNum;j++){
  40117f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  401186:	eb 03                	jmp    40118b <print_info+0x32>
  401188:	ff 45 f8             	incl   -0x8(%rbp)
  40118b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40118f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  401192:	48 63 d2             	movslq %edx,%rdx
  401195:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  401199:	8b 40 58             	mov    0x58(%rax),%eax
  40119c:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  40119f:	7f e7                	jg     401188 <print_info+0x2f>
	//printf("Number of pipe separated commands %d\n",info->pipeNum);


	int i,j;

	for(i=0;i<=info->pipeNum;i++){
  4011a1:	ff 45 fc             	incl   -0x4(%rbp)
  4011a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4011a8:	8b 40 50             	mov    0x50(%rax),%eax
  4011ab:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  4011ae:	7d cf                	jge    40117f <print_info+0x26>
			//printf("Argument %d : %s \n", j,info->CommArray[i]->VarList[j]);
		}

	}

	return;
  4011b0:	90                   	nop
}
  4011b1:	c9                   	leaveq 
  4011b2:	c3                   	retq   

00000000004011b3 <free_info>:

void free_info (parseInfo *info) {
  4011b3:	55                   	push   %rbp
  4011b4:	48 89 e5             	mov    %rsp,%rbp
  4011b7:	48 83 ec 10          	sub    $0x10,%rsp
  4011bb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	//printf("free_info: freeing memory associated to parseInfo struct\n");
	free(info);
  4011bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4011c3:	48 89 c7             	mov    %rax,%rdi
  4011c6:	e8 03 21 00 00       	callq  4032ce <free>
}
  4011cb:	c9                   	leaveq 
  4011cc:	c3                   	retq   

00000000004011cd <parseModified>:

parseInfo* parseModified(char *cmd,char* envp[]){
  4011cd:	55                   	push   %rbp
  4011ce:	48 89 e5             	mov    %rsp,%rbp
  4011d1:	48 81 ec 40 02 00 00 	sub    $0x240,%rsp
  4011d8:	48 89 bd c8 fd ff ff 	mov    %rdi,-0x238(%rbp)
  4011df:	48 89 b5 c0 fd ff ff 	mov    %rsi,-0x240(%rbp)

	parseInfo *Result;
	Token* tokenPipe;
	Token* tokenSpace;
	//Token* path;
	singleCommand* sc = NULL;
  4011e6:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  4011ed:	00 
//	char** envVar=NULL;
	char *fullPath=NULL;
  4011ee:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  4011f5:	00 
	int i=0,j=0;
  4011f6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  4011fd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	char srchPath[500];
	//printf("In PARSE MODIFIED");
	Result = (parseInfo*)malloc(sizeof(parseInfo));
  401204:	bf 58 00 00 00       	mov    $0x58,%edi
  401209:	e8 53 1f 00 00       	callq  403161 <malloc>
  40120e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

//	envVar=findEnvVar("PATH",envp);
    //envVar[0]="PATH=/bin";
	printf("In parser... full PATH= %s\n\n",cmd);
  401212:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  401219:	48 89 c6             	mov    %rax,%rsi
  40121c:	48 8d 3d c7 23 00 00 	lea    0x23c7(%rip),%rdi        # 4035ea <chdir+0x289>
  401223:	b8 00 00 00 00       	mov    $0x0,%eax
  401228:	e8 de 10 00 00       	callq  40230b <printf>
//		printf("PATH is ---> %s",path->tokenArr[1]);

    

	//strcpy(srchPath,path->tokenArr[1]);
	strcpy(srchPath,"/bin");
  40122d:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  401234:	48 8d 35 cc 23 00 00 	lea    0x23cc(%rip),%rsi        # 403607 <chdir+0x2a6>
  40123b:	48 89 c7             	mov    %rax,%rdi
  40123e:	e8 d3 17 00 00       	callq  402a16 <strcpy>

	printf("Seatch PAth is %s",srchPath);
  401243:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  40124a:	48 89 c6             	mov    %rax,%rsi
  40124d:	48 8d 3d b8 23 00 00 	lea    0x23b8(%rip),%rdi        # 40360c <chdir+0x2ab>
  401254:	b8 00 00 00 00       	mov    $0x0,%eax
  401259:	e8 ad 10 00 00       	callq  40230b <printf>

	tokenPipe = tokenize(cmd,"|");
  40125e:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  401265:	48 8d 35 b2 23 00 00 	lea    0x23b2(%rip),%rsi        # 40361e <chdir+0x2bd>
  40126c:	48 89 c7             	mov    %rax,%rdi
  40126f:	e8 87 08 00 00       	callq  401afb <tokenize>
  401274:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	printf("In PARSE MODIFIED%d\n",tokenPipe->numOfTokens);
  401278:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40127c:	8b 00                	mov    (%rax),%eax
  40127e:	89 c6                	mov    %eax,%esi
  401280:	48 8d 3d 99 23 00 00 	lea    0x2399(%rip),%rdi        # 403620 <chdir+0x2bf>
  401287:	b8 00 00 00 00       	mov    $0x0,%eax
  40128c:	e8 7a 10 00 00       	callq  40230b <printf>
	for(i=0;i<tokenPipe->numOfTokens;i++){
  401291:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  401298:	e9 14 02 00 00       	jmpq   4014b1 <parseModified+0x2e4>

		//for each pipe separated token find space separated tokens
		tokenSpace=tokenize(tokenPipe->tokenArr[i]," ");
  40129d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4012a1:	8b 55 fc             	mov    -0x4(%rbp),%edx
  4012a4:	48 63 d2             	movslq %edx,%rdx
  4012a7:	48 8b 44 d0 08       	mov    0x8(%rax,%rdx,8),%rax
  4012ac:	48 8d 35 82 23 00 00 	lea    0x2382(%rip),%rsi        # 403635 <chdir+0x2d4>
  4012b3:	48 89 c7             	mov    %rax,%rdi
  4012b6:	e8 40 08 00 00       	callq  401afb <tokenize>
  4012bb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

		//initialize the singleCommand Structure
		sc = (singleCommand*)malloc(sizeof(singleCommand));
  4012bf:	bf 60 00 00 00       	mov    $0x60,%edi
  4012c4:	e8 98 1e 00 00       	callq  403161 <malloc>
  4012c9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		sc->commandName=(char*)malloc(100);
  4012cd:	bf 64 00 00 00       	mov    $0x64,%edi
  4012d2:	e8 8a 1e 00 00       	callq  403161 <malloc>
  4012d7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  4012db:	48 89 02             	mov    %rax,(%rdx)
		sc->commandName[0]='\0';
  4012de:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4012e2:	48 8b 00             	mov    (%rax),%rax
  4012e5:	c6 00 00             	movb   $0x0,(%rax)
		printf("Before find full binary path\n\n\n");
  4012e8:	48 8d 3d 49 23 00 00 	lea    0x2349(%rip),%rdi        # 403638 <chdir+0x2d7>
  4012ef:	b8 00 00 00 00       	mov    $0x0,%eax
  4012f4:	e8 12 10 00 00       	callq  40230b <printf>
		sc->commandName=tokenSpace->tokenArr[0];
  4012f9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4012fd:	48 8b 50 08          	mov    0x8(%rax),%rdx
  401301:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401305:	48 89 10             	mov    %rdx,(%rax)
		if(strcmp(tokenSpace->tokenArr[0],"set") && strcmp(tokenSpace->tokenArr[0],"cd") && strcmp(tokenSpace->tokenArr[0],"exit") )
  401308:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40130c:	48 8b 40 08          	mov    0x8(%rax),%rax
  401310:	48 8d 35 41 23 00 00 	lea    0x2341(%rip),%rsi        # 403658 <chdir+0x2f7>
  401317:	48 89 c7             	mov    %rax,%rdi
  40131a:	e8 56 17 00 00       	callq  402a75 <strcmp>
  40131f:	85 c0                	test   %eax,%eax
  401321:	0f 84 05 01 00 00    	je     40142c <parseModified+0x25f>
  401327:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40132b:	48 8b 40 08          	mov    0x8(%rax),%rax
  40132f:	48 8d 35 26 23 00 00 	lea    0x2326(%rip),%rsi        # 40365c <chdir+0x2fb>
  401336:	48 89 c7             	mov    %rax,%rdi
  401339:	e8 37 17 00 00       	callq  402a75 <strcmp>
  40133e:	85 c0                	test   %eax,%eax
  401340:	0f 84 e6 00 00 00    	je     40142c <parseModified+0x25f>
  401346:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40134a:	48 8b 40 08          	mov    0x8(%rax),%rax
  40134e:	48 8d 35 0a 23 00 00 	lea    0x230a(%rip),%rsi        # 40365f <chdir+0x2fe>
  401355:	48 89 c7             	mov    %rax,%rdi
  401358:	e8 18 17 00 00       	callq  402a75 <strcmp>
  40135d:	85 c0                	test   %eax,%eax
  40135f:	0f 84 c7 00 00 00    	je     40142c <parseModified+0x25f>
		{
			printf("Loop %d cmd: %s\n\n",i,tokenSpace->tokenArr[0] );
  401365:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401369:	48 8b 50 08          	mov    0x8(%rax),%rdx
  40136d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401370:	89 c6                	mov    %eax,%esi
  401372:	48 8d 3d eb 22 00 00 	lea    0x22eb(%rip),%rdi        # 403664 <chdir+0x303>
  401379:	b8 00 00 00 00       	mov    $0x0,%eax
  40137e:	e8 88 0f 00 00       	callq  40230b <printf>

			if(strstr(tokenSpace->tokenArr[0],"/")==NULL){
  401383:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401387:	48 8b 40 08          	mov    0x8(%rax),%rax
  40138b:	48 8d 35 e4 22 00 00 	lea    0x22e4(%rip),%rsi        # 403676 <chdir+0x315>
  401392:	48 89 c7             	mov    %rax,%rdi
  401395:	e8 62 17 00 00       	callq  402afc <strstr>
  40139a:	48 85 c0             	test   %rax,%rax
  40139d:	0f 85 89 00 00 00    	jne    40142c <parseModified+0x25f>

				fullPath=findBinaryFullPath(srchPath,tokenSpace->tokenArr[0]);
  4013a3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4013a7:	48 8b 50 08          	mov    0x8(%rax),%rdx
  4013ab:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  4013b2:	48 89 d6             	mov    %rdx,%rsi
  4013b5:	48 89 c7             	mov    %rax,%rdi
  4013b8:	e8 21 fc ff ff       	callq  400fde <findBinaryFullPath>
  4013bd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				if(fullPath==NULL)
  4013c1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  4013c6:	75 1b                	jne    4013e3 <parseModified+0x216>
				{
					printf("Error:Command Not found.\n");
  4013c8:	48 8d 3d a9 22 00 00 	lea    0x22a9(%rip),%rdi        # 403678 <chdir+0x317>
  4013cf:	b8 00 00 00 00       	mov    $0x0,%eax
  4013d4:	e8 32 0f 00 00       	callq  40230b <printf>
					return NULL;
  4013d9:	b8 00 00 00 00       	mov    $0x0,%eax
  4013de:	e9 f1 00 00 00       	jmpq   4014d4 <parseModified+0x307>
				}
				sc->commandName = fullPath;
  4013e3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4013e7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  4013eb:	48 89 10             	mov    %rdx,(%rax)
				sc->commandName = strcat(sc->commandName,"/");
  4013ee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4013f2:	48 8b 00             	mov    (%rax),%rax
  4013f5:	48 8d 35 7a 22 00 00 	lea    0x227a(%rip),%rsi        # 403676 <chdir+0x315>
  4013fc:	48 89 c7             	mov    %rax,%rdi
  4013ff:	e8 d6 17 00 00       	callq  402bda <strcat>
  401404:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  401408:	48 89 02             	mov    %rax,(%rdx)
				sc->commandName = strcat(sc->commandName,tokenSpace->tokenArr[0]);
  40140b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40140f:	48 8b 50 08          	mov    0x8(%rax),%rdx
  401413:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401417:	48 8b 00             	mov    (%rax),%rax
  40141a:	48 89 d6             	mov    %rdx,%rsi
  40141d:	48 89 c7             	mov    %rax,%rdi
  401420:	e8 b5 17 00 00       	callq  402bda <strcat>
  401425:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  401429:	48 89 02             	mov    %rax,(%rdx)
		}

		//printf("In parser..fullpath for %s is %s\n",tokenSpace->tokenArr[0],fullPath);


		printf("COMMAND NAME=%s\n",sc->commandName);
  40142c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401430:	48 8b 00             	mov    (%rax),%rax
  401433:	48 89 c6             	mov    %rax,%rsi
  401436:	48 8d 3d 55 22 00 00 	lea    0x2255(%rip),%rdi        # 403692 <chdir+0x331>
  40143d:	b8 00 00 00 00       	mov    $0x0,%eax
  401442:	e8 c4 0e 00 00       	callq  40230b <printf>
		//sc->VarList[0]=fullPath;
		sc->VarNum = tokenSpace->numOfTokens;
  401447:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40144b:	8b 10                	mov    (%rax),%edx
  40144d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401451:	89 50 58             	mov    %edx,0x58(%rax)
		for(j=0;j<tokenSpace->numOfTokens;j++){
  401454:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  40145b:	eb 21                	jmp    40147e <parseModified+0x2b1>
			sc->VarList[j]=tokenSpace->tokenArr[j];
  40145d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401461:	8b 55 f8             	mov    -0x8(%rbp),%edx
  401464:	48 63 d2             	movslq %edx,%rdx
  401467:	48 8b 4c d0 08       	mov    0x8(%rax,%rdx,8),%rcx
  40146c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401470:	8b 55 f8             	mov    -0x8(%rbp),%edx
  401473:	48 63 d2             	movslq %edx,%rdx
  401476:	48 89 4c d0 08       	mov    %rcx,0x8(%rax,%rdx,8)


		printf("COMMAND NAME=%s\n",sc->commandName);
		//sc->VarList[0]=fullPath;
		sc->VarNum = tokenSpace->numOfTokens;
		for(j=0;j<tokenSpace->numOfTokens;j++){
  40147b:	ff 45 f8             	incl   -0x8(%rbp)
  40147e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401482:	8b 00                	mov    (%rax),%eax
  401484:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  401487:	7f d4                	jg     40145d <parseModified+0x290>
			sc->VarList[j]=tokenSpace->tokenArr[j];
		}
		sc->VarList[j]=NULL;
  401489:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40148d:	8b 55 f8             	mov    -0x8(%rbp),%edx
  401490:	48 63 d2             	movslq %edx,%rdx
  401493:	48 c7 44 d0 08 00 00 	movq   $0x0,0x8(%rax,%rdx,8)
  40149a:	00 00 

		Result->CommArray[i]=sc;
  40149c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4014a0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  4014a3:	48 63 d2             	movslq %edx,%rdx
  4014a6:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  4014aa:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
	printf("Seatch PAth is %s",srchPath);

	tokenPipe = tokenize(cmd,"|");

	printf("In PARSE MODIFIED%d\n",tokenPipe->numOfTokens);
	for(i=0;i<tokenPipe->numOfTokens;i++){
  4014ae:	ff 45 fc             	incl   -0x4(%rbp)
  4014b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4014b5:	8b 00                	mov    (%rax),%eax
  4014b7:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  4014ba:	0f 8f dd fd ff ff    	jg     40129d <parseModified+0xd0>

		Result->CommArray[i]=sc;

	}

	Result->pipeNum=tokenPipe->numOfTokens-1; //set the number of pipe separated commands
  4014c0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4014c4:	8b 00                	mov    (%rax),%eax
  4014c6:	8d 50 ff             	lea    -0x1(%rax),%edx
  4014c9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4014cd:	89 50 50             	mov    %edx,0x50(%rax)

	return Result;
  4014d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  4014d4:	c9                   	leaveq 
  4014d5:	c3                   	retq   

00000000004014d6 <read_line>:

int read_line(int fd, char* buf)
{
  4014d6:	55                   	push   %rbp
  4014d7:	48 89 e5             	mov    %rsp,%rbp
  4014da:	48 83 ec 10          	sub    $0x10,%rsp
  4014de:	89 7d fc             	mov    %edi,-0x4(%rbp)
  4014e1:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
		//printf("read: %c ",*byte);
		if (ret == -1)
			return -1;
	}
	*(byte-1)='\0';*/
    read(0,buf,MAXLINE);
  4014e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4014e9:	ba 00 01 00 00       	mov    $0x100,%edx
  4014ee:	48 89 c6             	mov    %rax,%rsi
  4014f1:	bf 00 00 00 00       	mov    $0x0,%edi
  4014f6:	e8 fa 12 00 00       	callq  4027f5 <read>
	return 1;
  4014fb:	b8 01 00 00 00       	mov    $0x1,%eax
}
  401500:	c9                   	leaveq 
  401501:	c3                   	retq   

0000000000401502 <changePS1>:
#include <parser.h>
#include <errno.h>
#include <string.h>
#include <shell.h>

void changePS1(char*str){
  401502:	55                   	push   %rbp
  401503:	48 89 e5             	mov    %rsp,%rbp
  401506:	48 83 ec 20          	sub    $0x20,%rsp
  40150a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	 * The PS1 is a shell variable
	 *
	 */

	Token* tokenEqulas;
	tokenEqulas = tokenize(str,"=");
  40150e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401512:	48 8d 35 8f 21 00 00 	lea    0x218f(%rip),%rsi        # 4036a8 <chdir+0x347>
  401519:	48 89 c7             	mov    %rax,%rdi
  40151c:	e8 da 05 00 00       	callq  401afb <tokenize>
  401521:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	//printf("no:%d\n\n",tokenEqulas->numOfTokens);

	if(tokenEqulas->numOfTokens < 2)
  401525:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401529:	8b 00                	mov    (%rax),%eax
  40152b:	83 f8 01             	cmp    $0x1,%eax
  40152e:	7f 13                	jg     401543 <changePS1+0x41>
	{
		printf("Error:Invalid PS1\n");
  401530:	48 8d 3d 73 21 00 00 	lea    0x2173(%rip),%rdi        # 4036aa <chdir+0x349>
  401537:	b8 00 00 00 00       	mov    $0x0,%eax
  40153c:	e8 ca 0d 00 00       	callq  40230b <printf>
  401541:	eb 5d                	jmp    4015a0 <changePS1+0x9e>
	}
	else if(strlen(tokenEqulas->tokenArr[1])>100){
  401543:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401547:	48 8b 40 10          	mov    0x10(%rax),%rax
  40154b:	48 89 c7             	mov    %rax,%rdi
  40154e:	e8 8e 14 00 00       	callq  4029e1 <strlen>
  401553:	83 f8 64             	cmp    $0x64,%eax
  401556:	7e 13                	jle    40156b <changePS1+0x69>
		printf("Too long a prompt name.Pleasee try again\n");
  401558:	48 8d 3d 61 21 00 00 	lea    0x2161(%rip),%rdi        # 4036c0 <chdir+0x35f>
  40155f:	b8 00 00 00 00       	mov    $0x0,%eax
  401564:	e8 a2 0d 00 00       	callq  40230b <printf>
  401569:	eb 35                	jmp    4015a0 <changePS1+0x9e>
	}


	else{

		strcpy(PS1,tokenEqulas->tokenArr[1]);
  40156b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40156f:	48 8b 40 10          	mov    0x10(%rax),%rax
  401573:	48 89 c6             	mov    %rax,%rsi
  401576:	48 8d 05 03 30 20 00 	lea    0x203003(%rip),%rax        # 604580 <PS1>
  40157d:	48 89 c7             	mov    %rax,%rdi
  401580:	e8 91 14 00 00       	callq  402a16 <strcpy>
		printf("PS1 after change %s\n",PS1);
  401585:	48 8d 05 f4 2f 20 00 	lea    0x202ff4(%rip),%rax        # 604580 <PS1>
  40158c:	48 89 c6             	mov    %rax,%rsi
  40158f:	48 8d 3d 54 21 00 00 	lea    0x2154(%rip),%rdi        # 4036ea <chdir+0x389>
  401596:	b8 00 00 00 00       	mov    $0x0,%eax
  40159b:	e8 6b 0d 00 00       	callq  40230b <printf>
	}

}
  4015a0:	c9                   	leaveq 
  4015a1:	c3                   	retq   

00000000004015a2 <removeSpaces>:
#include<stdio.h>
#include<string.h>
#include<stdlib.h>


char* removeSpaces(char*str){
  4015a2:	55                   	push   %rbp
  4015a3:	48 89 e5             	mov    %rsp,%rbp
  4015a6:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  4015ad:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
	/*
	 * This function removes spaces from str without modifying it
	 * The string returned must be malloced
	 */

	int i=0,j=0;
  4015b4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  4015bb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	char *noSpaceStr=NULL;
  4015c2:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  4015c9:	00 
	char temp[100];


	for(i=0;i<strlen(str);i++){
  4015ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  4015d1:	eb 3c                	jmp    40160f <removeSpaces+0x6d>

		if(str[i]!=' '){
  4015d3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4015d6:	48 63 d0             	movslq %eax,%rdx
  4015d9:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  4015e0:	48 01 d0             	add    %rdx,%rax
  4015e3:	0f b6 00             	movzbl (%rax),%eax
  4015e6:	3c 20                	cmp    $0x20,%al
  4015e8:	74 22                	je     40160c <removeSpaces+0x6a>
			temp[j++]=str[i];
  4015ea:	8b 45 f8             	mov    -0x8(%rbp),%eax
  4015ed:	8d 50 01             	lea    0x1(%rax),%edx
  4015f0:	89 55 f8             	mov    %edx,-0x8(%rbp)
  4015f3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  4015f6:	48 63 ca             	movslq %edx,%rcx
  4015f9:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  401600:	48 01 ca             	add    %rcx,%rdx
  401603:	0f b6 12             	movzbl (%rdx),%edx
  401606:	48 98                	cltq   
  401608:	88 54 05 8c          	mov    %dl,-0x74(%rbp,%rax,1)
	int i=0,j=0;
	char *noSpaceStr=NULL;
	char temp[100];


	for(i=0;i<strlen(str);i++){
  40160c:	ff 45 fc             	incl   -0x4(%rbp)
  40160f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  401616:	48 89 c7             	mov    %rax,%rdi
  401619:	e8 c3 13 00 00       	callq  4029e1 <strlen>
  40161e:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  401621:	7f b0                	jg     4015d3 <removeSpaces+0x31>
		if(str[i]!=' '){
			temp[j++]=str[i];
		}

	}
	temp[j]='\0';
  401623:	8b 45 f8             	mov    -0x8(%rbp),%eax
  401626:	48 98                	cltq   
  401628:	c6 44 05 8c 00       	movb   $0x0,-0x74(%rbp,%rax,1)

	noSpaceStr = malloc(sizeof(char)*(strlen(temp)));
  40162d:	48 8d 45 8c          	lea    -0x74(%rbp),%rax
  401631:	48 89 c7             	mov    %rax,%rdi
  401634:	e8 a8 13 00 00       	callq  4029e1 <strlen>
  401639:	48 98                	cltq   
  40163b:	48 89 c7             	mov    %rax,%rdi
  40163e:	e8 1e 1b 00 00       	callq  403161 <malloc>
  401643:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	strcpy(noSpaceStr,temp);
  401647:	48 8d 55 8c          	lea    -0x74(%rbp),%rdx
  40164b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40164f:	48 89 d6             	mov    %rdx,%rsi
  401652:	48 89 c7             	mov    %rax,%rdi
  401655:	e8 bc 13 00 00       	callq  402a16 <strcpy>

	return noSpaceStr;
  40165a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax

}
  40165e:	c9                   	leaveq 
  40165f:	c3                   	retq   

0000000000401660 <parallel_fork>:
#include <stdlib.h>
#include <test.h>
#include <errno.h>
#include <string.h>

void parallel_fork(){
  401660:	55                   	push   %rbp
  401661:	48 89 e5             	mov    %rsp,%rbp


    //int *pipe = (int*)malloc(4*sizeof(int));


}
  401664:	5d                   	pop    %rbp
  401665:	c3                   	retq   

0000000000401666 <main11>:
int main11(int argc, char* argv[], char* envp[])
{
  401666:	55                   	push   %rbp
  401667:	48 89 e5             	mov    %rsp,%rbp
  40166a:	48 81 ec 20 04 00 00 	sub    $0x420,%rsp
  401671:	89 bd fc fb ff ff    	mov    %edi,-0x404(%rbp)
  401677:	48 89 b5 f0 fb ff ff 	mov    %rsi,-0x410(%rbp)
  40167e:	48 89 95 e8 fb ff ff 	mov    %rdx,-0x418(%rbp)
//    parallel_fork();
    int pid[tot] ;

    int i;
    int p;
    int status=(uint64_t)&p;
  401685:	48 8d 85 10 fc ff ff 	lea    -0x3f0(%rbp),%rax
  40168c:	89 85 0c fc ff ff    	mov    %eax,-0x3f4(%rbp)

    for(i=0;i<tot;i++){
  401692:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  401699:	eb 3c                	jmp    4016d7 <main11+0x71>


        pid[i] = fork();
  40169b:	e8 ba 12 00 00       	callq  40295a <fork>
  4016a0:	89 c2                	mov    %eax,%edx
  4016a2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4016a5:	48 98                	cltq   
  4016a7:	89 94 85 14 fc ff ff 	mov    %edx,-0x3ec(%rbp,%rax,4)

       if(pid[i] == 0){
  4016ae:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4016b1:	48 98                	cltq   
  4016b3:	8b 84 85 14 fc ff ff 	mov    -0x3ec(%rbp,%rax,4),%eax
  4016ba:	85 c0                	test   %eax,%eax
  4016bc:	75 16                	jne    4016d4 <main11+0x6e>

            execve("/bin/malluaunty",NULL,NULL);
  4016be:	ba 00 00 00 00       	mov    $0x0,%edx
  4016c3:	be 00 00 00 00       	mov    $0x0,%esi
  4016c8:	48 8d 3d 30 20 00 00 	lea    0x2030(%rip),%rdi        # 4036ff <chdir+0x39e>
  4016cf:	e8 25 12 00 00       	callq  4028f9 <execve>

    int i;
    int p;
    int status=(uint64_t)&p;

    for(i=0;i<tot;i++){
  4016d4:	ff 45 fc             	incl   -0x4(%rbp)
  4016d7:	81 7d fc f9 00 00 00 	cmpl   $0xf9,-0x4(%rbp)
  4016de:	7e bb                	jle    40169b <main11+0x35>
            execve("/bin/malluaunty",NULL,NULL);

        }

      }
    status=status;
  4016e0:	8b 85 0c fc ff ff    	mov    -0x3f4(%rbp),%eax
  4016e6:	89 85 0c fc ff ff    	mov    %eax,-0x3f4(%rbp)
     //for(i=0;i<tot;i++);;
     {
         printf("chpid[%d]= %d",0,pid[0]);
  4016ec:	8b 85 14 fc ff ff    	mov    -0x3ec(%rbp),%eax
  4016f2:	89 c2                	mov    %eax,%edx
  4016f4:	be 00 00 00 00       	mov    $0x0,%esi
  4016f9:	48 8d 3d 0f 20 00 00 	lea    0x200f(%rip),%rdi        # 40370f <chdir+0x3ae>
  401700:	b8 00 00 00 00       	mov    $0x0,%eax
  401705:	e8 01 0c 00 00       	callq  40230b <printf>
         waitpid(2,&status,0);
  40170a:	48 8d 85 0c fc ff ff 	lea    -0x3f4(%rbp),%rax
  401711:	ba 00 00 00 00       	mov    $0x0,%edx
  401716:	48 89 c6             	mov    %rax,%rsi
  401719:	bf 02 00 00 00       	mov    $0x2,%edi
  40171e:	e8 16 09 00 00       	callq  402039 <waitpid>
   }
printf("\n***PARENT EXITNG***\n");
  401723:	48 8d 3d f3 1f 00 00 	lea    0x1ff3(%rip),%rdi        # 40371d <chdir+0x3bc>
  40172a:	b8 00 00 00 00       	mov    $0x0,%eax
  40172f:	e8 d7 0b 00 00       	callq  40230b <printf>

return 0;
  401734:	b8 00 00 00 00       	mov    $0x0,%eax
}
  401739:	c9                   	leaveq 
  40173a:	c3                   	retq   

000000000040173b <main>:


char PS1[200]="SBUSH";

int main (int argc, char *argv[], char* envp[])
{
  40173b:	55                   	push   %rbp
  40173c:	48 89 e5             	mov    %rsp,%rbp
  40173f:	48 81 ec 50 01 00 00 	sub    $0x150,%rsp
  401746:	89 bd cc fe ff ff    	mov    %edi,-0x134(%rbp)
  40174c:	48 89 b5 c0 fe ff ff 	mov    %rsi,-0x140(%rbp)
  401753:	48 89 95 b8 fe ff ff 	mov    %rdx,-0x148(%rbp)


	char cmdLine[MAXLINE];


	int fd=0,ret;
  40175a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	//char x[10] ="akshay";
	parseInfo *info; //info stores all the information returned by parser.
	//printf("Akshay Kale %s, \n",x);
	//exit(0);

	if(argv[1]!=NULL)
  401761:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
  401768:	48 83 c0 08          	add    $0x8,%rax
  40176c:	48 8b 00             	mov    (%rax),%rax
  40176f:	48 85 c0             	test   %rax,%rax
  401772:	74 1e                	je     401792 <main+0x57>
	{
		//printf("executing script");
		fd=open(argv[1],0);
  401774:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
  40177b:	48 83 c0 08          	add    $0x8,%rax
  40177f:	48 8b 00             	mov    (%rax),%rax
  401782:	be 00 00 00 00       	mov    $0x0,%esi
  401787:	48 89 c7             	mov    %rax,%rdi
  40178a:	e8 eb 06 00 00       	callq  401e7a <open>
  40178f:	89 45 fc             	mov    %eax,-0x4(%rbp)

	while(1)
	{
		//cmdLine = "Santosh 1 2 3 | ls -l";

		if(argv[1] == NULL)
  401792:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
  401799:	48 83 c0 08          	add    $0x8,%rax
  40179d:	48 8b 00             	mov    (%rax),%rax
  4017a0:	48 85 c0             	test   %rax,%rax
  4017a3:	75 1d                	jne    4017c2 <main+0x87>
		{
			printf("%s> ",PS1);
  4017a5:	48 8d 05 d4 2d 20 00 	lea    0x202dd4(%rip),%rax        # 604580 <PS1>
  4017ac:	48 89 c6             	mov    %rax,%rsi
  4017af:	48 8d 3d 7d 1f 00 00 	lea    0x1f7d(%rip),%rdi        # 403733 <chdir+0x3d2>
  4017b6:	b8 00 00 00 00       	mov    $0x0,%eax
  4017bb:	e8 4b 0b 00 00       	callq  40230b <printf>
  4017c0:	eb 46                	jmp    401808 <main+0xcd>
			//read_line(0,cmdLine);
		}
		else
		{
			//printf("here");
			ret=read_line(fd, cmdLine);
  4017c2:	48 8d 95 f0 fe ff ff 	lea    -0x110(%rbp),%rdx
  4017c9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4017cc:	48 89 d6             	mov    %rdx,%rsi
  4017cf:	89 c7                	mov    %eax,%edi
  4017d1:	e8 00 fd ff ff       	callq  4014d6 <read_line>
  4017d6:	89 45 f8             	mov    %eax,-0x8(%rbp)
			while (cmdLine[0] == '#')
  4017d9:	eb 17                	jmp    4017f2 <main+0xb7>
				ret=read_line(fd,cmdLine);
  4017db:	48 8d 95 f0 fe ff ff 	lea    -0x110(%rbp),%rdx
  4017e2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4017e5:	48 89 d6             	mov    %rdx,%rsi
  4017e8:	89 c7                	mov    %eax,%edi
  4017ea:	e8 e7 fc ff ff       	callq  4014d6 <read_line>
  4017ef:	89 45 f8             	mov    %eax,-0x8(%rbp)
		}
		else
		{
			//printf("here");
			ret=read_line(fd, cmdLine);
			while (cmdLine[0] == '#')
  4017f2:	0f b6 85 f0 fe ff ff 	movzbl -0x110(%rbp),%eax
  4017f9:	3c 23                	cmp    $0x23,%al
  4017fb:	74 de                	je     4017db <main+0xa0>
				ret=read_line(fd,cmdLine);
			if(ret == -1)
  4017fd:	83 7d f8 ff          	cmpl   $0xffffffff,-0x8(%rbp)
  401801:	75 05                	jne    401808 <main+0xcd>
				break;
  401803:	e9 72 01 00 00       	jmpq   40197a <main+0x23f>
		}
    strcpy(cmdLine,"malluaunty");
  401808:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  40180f:	48 8d 35 22 1f 00 00 	lea    0x1f22(%rip),%rsi        # 403738 <chdir+0x3d7>
  401816:	48 89 c7             	mov    %rax,%rdi
  401819:	e8 f8 11 00 00       	callq  402a16 <strcpy>
        printf("entered: %s",cmdLine);
  40181e:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  401825:	48 89 c6             	mov    %rax,%rsi
  401828:	48 8d 3d 14 1f 00 00 	lea    0x1f14(%rip),%rdi        # 403743 <chdir+0x3e2>
  40182f:	b8 00 00 00 00       	mov    $0x0,%eax
  401834:	e8 d2 0a 00 00       	callq  40230b <printf>
		if (cmdLine == NULL) {
			printf("Unable to read last command\n");
			continue;
		}

		if(!(*cmdLine)){
  401839:	0f b6 85 f0 fe ff ff 	movzbl -0x110(%rbp),%eax
  401840:	84 c0                	test   %al,%al
  401842:	75 05                	jne    401849 <main+0x10e>
			//printf("No command entered\n");
			continue;
  401844:	e9 2c 01 00 00       	jmpq   401975 <main+0x23a>
		}

		printf("Calling parser%s",cmdLine);
  401849:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  401850:	48 89 c6             	mov    %rax,%rsi
  401853:	48 8d 3d f5 1e 00 00 	lea    0x1ef5(%rip),%rdi        # 40374f <chdir+0x3ee>
  40185a:	b8 00 00 00 00       	mov    $0x0,%eax
  40185f:	e8 a7 0a 00 00       	callq  40230b <printf>
		info = parseModified(cmdLine,envp);
  401864:	48 8b 95 b8 fe ff ff 	mov    -0x148(%rbp),%rdx
  40186b:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  401872:	48 89 d6             	mov    %rdx,%rsi
  401875:	48 89 c7             	mov    %rax,%rdi
  401878:	e8 50 f9 ff ff       	callq  4011cd <parseModified>
  40187d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		if (info == NULL){
  401881:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  401886:	75 14                	jne    40189c <main+0x161>
			free(cmdLine);
  401888:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  40188f:	48 89 c7             	mov    %rax,%rdi
  401892:	e8 37 1a 00 00       	callq  4032ce <free>
			continue;
  401897:	e9 d9 00 00 00       	jmpq   401975 <main+0x23a>
		}

		//prints the info struct
		print_info(info);
  40189c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4018a0:	48 89 c7             	mov    %rax,%rdi
  4018a3:	e8 b1 f8 ff ff       	callq  401159 <print_info>

		strcpy(temp,info->CommArray[0]->commandName);
  4018a8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4018ac:	48 8b 00             	mov    (%rax),%rax
  4018af:	48 8b 10             	mov    (%rax),%rdx
  4018b2:	48 8d 85 dc fe ff ff 	lea    -0x124(%rbp),%rax
  4018b9:	48 89 d6             	mov    %rdx,%rsi
  4018bc:	48 89 c7             	mov    %rax,%rdi
  4018bf:	e8 52 11 00 00       	callq  402a16 <strcpy>

		if(strcmp(temp,"set")==0||strcmp(temp,"cd")==0 || strcmp(temp,"exit")==0){
  4018c4:	48 8d 85 dc fe ff ff 	lea    -0x124(%rbp),%rax
  4018cb:	48 8d 35 8e 1e 00 00 	lea    0x1e8e(%rip),%rsi        # 403760 <chdir+0x3ff>
  4018d2:	48 89 c7             	mov    %rax,%rdi
  4018d5:	e8 9b 11 00 00       	callq  402a75 <strcmp>
  4018da:	85 c0                	test   %eax,%eax
  4018dc:	74 34                	je     401912 <main+0x1d7>
  4018de:	48 8d 85 dc fe ff ff 	lea    -0x124(%rbp),%rax
  4018e5:	48 8d 35 78 1e 00 00 	lea    0x1e78(%rip),%rsi        # 403764 <chdir+0x403>
  4018ec:	48 89 c7             	mov    %rax,%rdi
  4018ef:	e8 81 11 00 00       	callq  402a75 <strcmp>
  4018f4:	85 c0                	test   %eax,%eax
  4018f6:	74 1a                	je     401912 <main+0x1d7>
  4018f8:	48 8d 85 dc fe ff ff 	lea    -0x124(%rbp),%rax
  4018ff:	48 8d 35 61 1e 00 00 	lea    0x1e61(%rip),%rsi        # 403767 <chdir+0x406>
  401906:	48 89 c7             	mov    %rax,%rdi
  401909:	e8 67 11 00 00       	callq  402a75 <strcmp>
  40190e:	85 c0                	test   %eax,%eax
  401910:	75 29                	jne    40193b <main+0x200>

			printf("Executing Builtin command\n");
  401912:	48 8d 3d 53 1e 00 00 	lea    0x1e53(%rip),%rdi        # 40376c <chdir+0x40b>
  401919:	b8 00 00 00 00       	mov    $0x0,%eax
  40191e:	e8 e8 09 00 00       	callq  40230b <printf>
			executeBuiltins(info,envp);
  401923:	48 8b 95 b8 fe ff ff 	mov    -0x148(%rbp),%rdx
  40192a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40192e:	48 89 d6             	mov    %rdx,%rsi
  401931:	48 89 c7             	mov    %rax,%rdi
  401934:	e8 a5 ef ff ff       	callq  4008de <executeBuiltins>
  401939:	eb 27                	jmp    401962 <main+0x227>
		}

		else{
            printf("Calling Execute");
  40193b:	48 8d 3d 45 1e 00 00 	lea    0x1e45(%rip),%rdi        # 403787 <chdir+0x426>
  401942:	b8 00 00 00 00       	mov    $0x0,%eax
  401947:	e8 bf 09 00 00       	callq  40230b <printf>
			execute_cmd(info,envp);
  40194c:	48 8b 95 b8 fe ff ff 	mov    -0x148(%rbp),%rdx
  401953:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401957:	48 89 d6             	mov    %rdx,%rsi
  40195a:	48 89 c7             	mov    %rax,%rdi
  40195d:	e8 49 f1 ff ff       	callq  400aab <execute_cmd>
		}



		static int loop=0;
		loop++;
  401962:	8b 05 f8 2c 20 00    	mov    0x202cf8(%rip),%eax        # 604660 <loop.1275>
  401968:	ff c0                	inc    %eax
  40196a:	89 05 f0 2c 20 00    	mov    %eax,0x202cf0(%rip)        # 604660 <loop.1275>
		//printf("Out of execute%d\n",loop++);
		//exit(0);
	}/* while(1) */
  401970:	e9 1d fe ff ff       	jmpq   401792 <main+0x57>
  401975:	e9 18 fe ff ff       	jmpq   401792 <main+0x57>
	//printf("BYE BYE");
	return 0;
  40197a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  40197f:	c9                   	leaveq 
  401980:	c3                   	retq   

0000000000401981 <onlyWhiteSpace>:
#include <string.h>
#include <shell.h>



int onlyWhiteSpace(char *str){
  401981:	55                   	push   %rbp
  401982:	48 89 e5             	mov    %rsp,%rbp
  401985:	48 83 ec 18          	sub    $0x18,%rsp
  401989:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	//checks if a token is solely composed of white space.
	//if yes returns 1 else returns 0.So that token is not added to the array.

	int i=0;
  40198d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

	while(str[i]!='\0'){
  401994:	eb 32                	jmp    4019c8 <onlyWhiteSpace+0x47>

		if(!((str[i]=='\t') || (str[i]==' '))){
  401996:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401999:	48 63 d0             	movslq %eax,%rdx
  40199c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4019a0:	48 01 d0             	add    %rdx,%rax
  4019a3:	0f b6 00             	movzbl (%rax),%eax
  4019a6:	3c 09                	cmp    $0x9,%al
  4019a8:	74 1b                	je     4019c5 <onlyWhiteSpace+0x44>
  4019aa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4019ad:	48 63 d0             	movslq %eax,%rdx
  4019b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4019b4:	48 01 d0             	add    %rdx,%rax
  4019b7:	0f b6 00             	movzbl (%rax),%eax
  4019ba:	3c 20                	cmp    $0x20,%al
  4019bc:	74 07                	je     4019c5 <onlyWhiteSpace+0x44>

			return 0;
  4019be:	b8 00 00 00 00       	mov    $0x0,%eax
  4019c3:	eb 1c                	jmp    4019e1 <onlyWhiteSpace+0x60>
		}
		i++;
  4019c5:	ff 45 fc             	incl   -0x4(%rbp)
	//checks if a token is solely composed of white space.
	//if yes returns 1 else returns 0.So that token is not added to the array.

	int i=0;

	while(str[i]!='\0'){
  4019c8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4019cb:	48 63 d0             	movslq %eax,%rdx
  4019ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4019d2:	48 01 d0             	add    %rdx,%rax
  4019d5:	0f b6 00             	movzbl (%rax),%eax
  4019d8:	84 c0                	test   %al,%al
  4019da:	75 ba                	jne    401996 <onlyWhiteSpace+0x15>
			return 0;
		}
		i++;
	}

	return 1;
  4019dc:	b8 01 00 00 00       	mov    $0x1,%eax

}
  4019e1:	c9                   	leaveq 
  4019e2:	c3                   	retq   

00000000004019e3 <substring>:


char * substring(char* str, int front, int back){
  4019e3:	55                   	push   %rbp
  4019e4:	48 89 e5             	mov    %rsp,%rbp
  4019e7:	48 81 ec 20 02 00 00 	sub    $0x220,%rsp
  4019ee:	48 89 bd e8 fd ff ff 	mov    %rdi,-0x218(%rbp)
  4019f5:	89 b5 e4 fd ff ff    	mov    %esi,-0x21c(%rbp)
  4019fb:	89 95 e0 fd ff ff    	mov    %edx,-0x220(%rbp)

	//temporary buffer to hold the token;
	char n[500];
	char *p;
	int i=0;
  401a01:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

	//Must handle condition of consequtive delims, delim at the end.Not done till now.

	if(back==front){
  401a08:	8b 85 e0 fd ff ff    	mov    -0x220(%rbp),%eax
  401a0e:	3b 85 e4 fd ff ff    	cmp    -0x21c(%rbp),%eax
  401a14:	75 0a                	jne    401a20 <substring+0x3d>

		return (char*)NULL;
  401a16:	b8 00 00 00 00       	mov    $0x0,%eax
  401a1b:	e9 d9 00 00 00       	jmpq   401af9 <substring+0x116>

	}

	while(back < front){
  401a20:	eb 31                	jmp    401a53 <substring+0x70>
		n[i++]=str[back++];
  401a22:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401a25:	8d 50 01             	lea    0x1(%rax),%edx
  401a28:	89 55 fc             	mov    %edx,-0x4(%rbp)
  401a2b:	8b 95 e0 fd ff ff    	mov    -0x220(%rbp),%edx
  401a31:	8d 4a 01             	lea    0x1(%rdx),%ecx
  401a34:	89 8d e0 fd ff ff    	mov    %ecx,-0x220(%rbp)
  401a3a:	48 63 ca             	movslq %edx,%rcx
  401a3d:	48 8b 95 e8 fd ff ff 	mov    -0x218(%rbp),%rdx
  401a44:	48 01 ca             	add    %rcx,%rdx
  401a47:	0f b6 12             	movzbl (%rdx),%edx
  401a4a:	48 98                	cltq   
  401a4c:	88 94 05 fc fd ff ff 	mov    %dl,-0x204(%rbp,%rax,1)

		return (char*)NULL;

	}

	while(back < front){
  401a53:	8b 85 e0 fd ff ff    	mov    -0x220(%rbp),%eax
  401a59:	3b 85 e4 fd ff ff    	cmp    -0x21c(%rbp),%eax
  401a5f:	7c c1                	jl     401a22 <substring+0x3f>
		n[i++]=str[back++];
	}
	n[i] = '\0';
  401a61:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401a64:	48 98                	cltq   
  401a66:	c6 84 05 fc fd ff ff 	movb   $0x0,-0x204(%rbp,%rax,1)
  401a6d:	00 
	printf("nIn substring... %s\n",n);
  401a6e:	48 8d 85 fc fd ff ff 	lea    -0x204(%rbp),%rax
  401a75:	48 89 c6             	mov    %rax,%rsi
  401a78:	48 8d 3d 18 1d 00 00 	lea    0x1d18(%rip),%rdi        # 403797 <chdir+0x436>
  401a7f:	b8 00 00 00 00       	mov    $0x0,%eax
  401a84:	e8 82 08 00 00       	callq  40230b <printf>

	if(onlyWhiteSpace(n)==0){
  401a89:	48 8d 85 fc fd ff ff 	lea    -0x204(%rbp),%rax
  401a90:	48 89 c7             	mov    %rax,%rdi
  401a93:	e8 e9 fe ff ff       	callq  401981 <onlyWhiteSpace>
  401a98:	85 c0                	test   %eax,%eax
  401a9a:	75 40                	jne    401adc <substring+0xf9>
		p = (char*)malloc(sizeof(char)*(i+1));
  401a9c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401a9f:	ff c0                	inc    %eax
  401aa1:	48 98                	cltq   
  401aa3:	48 89 c7             	mov    %rax,%rdi
  401aa6:	e8 b6 16 00 00       	callq  403161 <malloc>
  401aab:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		strcpy(p,n);
  401aaf:	48 8d 95 fc fd ff ff 	lea    -0x204(%rbp),%rdx
  401ab6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401aba:	48 89 d6             	mov    %rdx,%rsi
  401abd:	48 89 c7             	mov    %rax,%rdi
  401ac0:	e8 51 0f 00 00       	callq  402a16 <strcpy>
		printf("After white space p=  ");
  401ac5:	48 8d 3d e0 1c 00 00 	lea    0x1ce0(%rip),%rdi        # 4037ac <chdir+0x44b>
  401acc:	b8 00 00 00 00       	mov    $0x0,%eax
  401ad1:	e8 35 08 00 00       	callq  40230b <printf>
        return p;
  401ad6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401ada:	eb 1d                	jmp    401af9 <substring+0x116>
	}
	else
		p = (char*)NULL;
  401adc:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  401ae3:	00 

    printf("Returning %s from substring");
  401ae4:	48 8d 3d d8 1c 00 00 	lea    0x1cd8(%rip),%rdi        # 4037c3 <chdir+0x462>
  401aeb:	b8 00 00 00 00       	mov    $0x0,%eax
  401af0:	e8 16 08 00 00       	callq  40230b <printf>
	return p;
  401af5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax

}
  401af9:	c9                   	leaveq 
  401afa:	c3                   	retq   

0000000000401afb <tokenize>:


Token* tokenize(char *str,char* delim){
  401afb:	55                   	push   %rbp
  401afc:	48 89 e5             	mov    %rsp,%rbp
  401aff:	48 83 ec 30          	sub    $0x30,%rsp
  401b03:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  401b07:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)

	Token* token=(Token*)malloc(sizeof(Token));
  401b0b:	bf 98 01 00 00       	mov    $0x198,%edi
  401b10:	e8 4c 16 00 00       	callq  403161 <malloc>
  401b15:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//printf("In Tokenize Printing str %s\n",str);
	int tokenCount=0;
  401b19:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	int front=0,back=0;
  401b20:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  401b27:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	int i=0;
  401b2e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
	char *p;

	printf("IN TOKENIZER %s %s",str,delim);
  401b35:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  401b39:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401b3d:	48 89 c6             	mov    %rax,%rsi
  401b40:	48 8d 3d 98 1c 00 00 	lea    0x1c98(%rip),%rdi        # 4037df <chdir+0x47e>
  401b47:	b8 00 00 00 00       	mov    $0x0,%eax
  401b4c:	e8 ba 07 00 00       	callq  40230b <printf>

	while(str[front]!='\0'){
  401b51:	e9 c0 00 00 00       	jmpq   401c16 <tokenize+0x11b>

		if(str[front]== *delim){
  401b56:	8b 45 f8             	mov    -0x8(%rbp),%eax
  401b59:	48 63 d0             	movslq %eax,%rdx
  401b5c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401b60:	48 01 d0             	add    %rdx,%rax
  401b63:	0f b6 10             	movzbl (%rax),%edx
  401b66:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401b6a:	0f b6 00             	movzbl (%rax),%eax
  401b6d:	38 c2                	cmp    %al,%dl
  401b6f:	0f 85 9e 00 00 00    	jne    401c13 <tokenize+0x118>
			//delimiter found. Extract substring.
			p=substring(str,front,back);
  401b75:	8b 55 f4             	mov    -0xc(%rbp),%edx
  401b78:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  401b7b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401b7f:	89 ce                	mov    %ecx,%esi
  401b81:	48 89 c7             	mov    %rax,%rdi
  401b84:	e8 5a fe ff ff       	callq  4019e3 <substring>
  401b89:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
            printf("Back in token %s %d ",p,p);
  401b8d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  401b91:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  401b95:	48 89 c6             	mov    %rax,%rsi
  401b98:	48 8d 3d 53 1c 00 00 	lea    0x1c53(%rip),%rdi        # 4037f2 <chdir+0x491>
  401b9f:	b8 00 00 00 00       	mov    $0x0,%eax
  401ba4:	e8 62 07 00 00       	callq  40230b <printf>
            
            if(p==NULL)
  401ba9:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  401bae:	75 11                	jne    401bc1 <tokenize+0xc6>
                printf("p is null");
  401bb0:	48 8d 3d 50 1c 00 00 	lea    0x1c50(%rip),%rdi        # 403807 <chdir+0x4a6>
  401bb7:	b8 00 00 00 00       	mov    $0x0,%eax
  401bbc:	e8 4a 07 00 00       	callq  40230b <printf>

			if(p != NULL){
  401bc1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  401bc6:	74 3e                	je     401c06 <tokenize+0x10b>
				token->tokenArr[tokenCount++]=p;
  401bc8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401bcb:	8d 50 01             	lea    0x1(%rax),%edx
  401bce:	89 55 fc             	mov    %edx,-0x4(%rbp)
  401bd1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  401bd5:	48 98                	cltq   
  401bd7:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  401bdb:	48 89 4c c2 08       	mov    %rcx,0x8(%rdx,%rax,8)
				printf("\nIn tokenizer..appending %s\n",token->tokenArr[tokenCount-1]);
  401be0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401be3:	8d 50 ff             	lea    -0x1(%rax),%edx
  401be6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401bea:	48 63 d2             	movslq %edx,%rdx
  401bed:	48 8b 44 d0 08       	mov    0x8(%rax,%rdx,8),%rax
  401bf2:	48 89 c6             	mov    %rax,%rsi
  401bf5:	48 8d 3d 15 1c 00 00 	lea    0x1c15(%rip),%rdi        # 403811 <chdir+0x4b0>
  401bfc:	b8 00 00 00 00       	mov    $0x0,%eax
  401c01:	e8 05 07 00 00       	callq  40230b <printf>
			}

			back = front +1;
  401c06:	8b 45 f8             	mov    -0x8(%rbp),%eax
  401c09:	ff c0                	inc    %eax
  401c0b:	89 45 f4             	mov    %eax,-0xc(%rbp)
			front++;
  401c0e:	ff 45 f8             	incl   -0x8(%rbp)
  401c11:	eb 03                	jmp    401c16 <tokenize+0x11b>
			//continue;
		}

		else{
			front++;
  401c13:	ff 45 f8             	incl   -0x8(%rbp)
	int i=0;
	char *p;

	printf("IN TOKENIZER %s %s",str,delim);

	while(str[front]!='\0'){
  401c16:	8b 45 f8             	mov    -0x8(%rbp),%eax
  401c19:	48 63 d0             	movslq %eax,%rdx
  401c1c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401c20:	48 01 d0             	add    %rdx,%rax
  401c23:	0f b6 00             	movzbl (%rax),%eax
  401c26:	84 c0                	test   %al,%al
  401c28:	0f 85 28 ff ff ff    	jne    401b56 <tokenize+0x5b>
		else{
			front++;
		}
	}//end while

	p = substring(str,front,back);
  401c2e:	8b 55 f4             	mov    -0xc(%rbp),%edx
  401c31:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  401c34:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401c38:	89 ce                	mov    %ecx,%esi
  401c3a:	48 89 c7             	mov    %rax,%rdi
  401c3d:	e8 a1 fd ff ff       	callq  4019e3 <substring>
  401c42:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if(p != NULL){
  401c46:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  401c4b:	74 18                	je     401c65 <tokenize+0x16a>
		token->tokenArr[tokenCount++]=p;
  401c4d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401c50:	8d 50 01             	lea    0x1(%rax),%edx
  401c53:	89 55 fc             	mov    %edx,-0x4(%rbp)
  401c56:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  401c5a:	48 98                	cltq   
  401c5c:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  401c60:	48 89 4c c2 08       	mov    %rcx,0x8(%rdx,%rax,8)
	}
	token->numOfTokens=tokenCount;
  401c65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401c69:	8b 55 fc             	mov    -0x4(%rbp),%edx
  401c6c:	89 10                	mov    %edx,(%rax)


	printf("Before Returning Token\n\n");
  401c6e:	48 8d 3d b9 1b 00 00 	lea    0x1bb9(%rip),%rdi        # 40382e <chdir+0x4cd>
  401c75:	b8 00 00 00 00       	mov    $0x0,%eax
  401c7a:	e8 8c 06 00 00       	callq  40230b <printf>

	for(i=0;i<token->numOfTokens;i++){
  401c7f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  401c86:	eb 2e                	jmp    401cb6 <tokenize+0x1bb>

		printf("Token %d : %s %d\n",i,token->tokenArr[i],token->numOfTokens);
  401c88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401c8c:	8b 08                	mov    (%rax),%ecx
  401c8e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401c92:	8b 55 f0             	mov    -0x10(%rbp),%edx
  401c95:	48 63 d2             	movslq %edx,%rdx
  401c98:	48 8b 54 d0 08       	mov    0x8(%rax,%rdx,8),%rdx
  401c9d:	8b 45 f0             	mov    -0x10(%rbp),%eax
  401ca0:	89 c6                	mov    %eax,%esi
  401ca2:	48 8d 3d 9e 1b 00 00 	lea    0x1b9e(%rip),%rdi        # 403847 <chdir+0x4e6>
  401ca9:	b8 00 00 00 00       	mov    $0x0,%eax
  401cae:	e8 58 06 00 00       	callq  40230b <printf>
	token->numOfTokens=tokenCount;


	printf("Before Returning Token\n\n");

	for(i=0;i<token->numOfTokens;i++){
  401cb3:	ff 45 f0             	incl   -0x10(%rbp)
  401cb6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401cba:	8b 00                	mov    (%rax),%eax
  401cbc:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  401cbf:	7f c7                	jg     401c88 <tokenize+0x18d>

		printf("Token %d : %s %d\n",i,token->tokenArr[i],token->numOfTokens);
	}


	return token;
  401cc1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax

}
  401cc5:	c9                   	leaveq 
  401cc6:	c3                   	retq   

0000000000401cc7 <main2>:
#include<stdlib.h>
#include<stdio.h>
int main2 (int argc, char *argv[], char* envp[])
{
  401cc7:	55                   	push   %rbp
  401cc8:	48 89 e5             	mov    %rsp,%rbp
  401ccb:	48 83 ec 30          	sub    $0x30,%rsp
  401ccf:	89 7d ec             	mov    %edi,-0x14(%rbp)
  401cd2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  401cd6:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
char* s=(char*)malloc(10);
  401cda:	bf 0a 00 00 00       	mov    $0xa,%edi
  401cdf:	e8 7d 14 00 00       	callq  403161 <malloc>
  401ce4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

printf("s=%d",s);
  401ce8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401cec:	48 89 c6             	mov    %rax,%rsi
  401cef:	48 8d 3d 63 1b 00 00 	lea    0x1b63(%rip),%rdi        # 403859 <chdir+0x4f8>
  401cf6:	b8 00 00 00 00       	mov    $0x0,%eax
  401cfb:	e8 0b 06 00 00       	callq  40230b <printf>
return 0;
  401d00:	b8 00 00 00 00       	mov    $0x0,%eax
}
  401d05:	c9                   	leaveq 
  401d06:	c3                   	retq   

0000000000401d07 <test>:
#include <stdlib.h>
#include <string.h>


	
uint64_t test(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3){
  401d07:	55                   	push   %rbp
  401d08:	48 89 e5             	mov    %rsp,%rbp
  401d0b:	48 83 ec 30          	sub    $0x30,%rsp
  401d0f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401d13:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  401d17:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  401d1b:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)

	//printf("Inside test\n");


	uint64_t ret;
	__asm__("movq %1,%%rax;"
  401d1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401d23:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401d27:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  401d2b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  401d2f:	cd 80                	int    $0x80
  401d31:	48 89 c0             	mov    %rax,%rax
  401d34:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %3,%%rsi;"
			"movq %4, %%rdx;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2),"m"(a3));
	return ret;
  401d38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax


}
  401d3c:	c9                   	leaveq 
  401d3d:	c3                   	retq   

0000000000401d3e <readdir>:




struct dirent* readdir(void *dir){
  401d3e:	55                   	push   %rbp
  401d3f:	48 89 e5             	mov    %rsp,%rbp
  401d42:	48 81 ec 20 04 00 00 	sub    $0x420,%rsp
  401d49:	48 89 bd e8 fb ff ff 	mov    %rdi,-0x418(%rbp)

	char buff[1024];

	if((uint64_t)dir == -1){
  401d50:	48 8b 85 e8 fb ff ff 	mov    -0x418(%rbp),%rax
  401d57:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  401d5b:	75 18                	jne    401d75 <readdir+0x37>

		printf("Bad directory stream\n");
  401d5d:	48 8d 3d fc 1a 00 00 	lea    0x1afc(%rip),%rdi        # 403860 <chdir+0x4ff>
  401d64:	b8 00 00 00 00       	mov    $0x0,%eax
  401d69:	e8 9d 05 00 00       	callq  40230b <printf>
		return NULL;
  401d6e:	b8 00 00 00 00       	mov    $0x0,%eax
  401d73:	eb 6a                	jmp    401ddf <readdir+0xa1>
	}


	int ret = test(78,(uint64_t)dir,(uint64_t)buff,(uint64_t)1024);
  401d75:	48 8d 95 f0 fb ff ff 	lea    -0x410(%rbp),%rdx
  401d7c:	48 8b 85 e8 fb ff ff 	mov    -0x418(%rbp),%rax
  401d83:	b9 00 04 00 00       	mov    $0x400,%ecx
  401d88:	48 89 c6             	mov    %rax,%rsi
  401d8b:	bf 4e 00 00 00       	mov    $0x4e,%edi
  401d90:	e8 72 ff ff ff       	callq  401d07 <test>
  401d95:	89 45 fc             	mov    %eax,-0x4(%rbp)

	//printf("Ret value %d\n", ret );

	if(ret == -1){
  401d98:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  401d9c:	75 18                	jne    401db6 <readdir+0x78>

		//Error
		printf("Error while reading directory\n");
  401d9e:	48 8d 3d d3 1a 00 00 	lea    0x1ad3(%rip),%rdi        # 403878 <chdir+0x517>
  401da5:	b8 00 00 00 00       	mov    $0x0,%eax
  401daa:	e8 5c 05 00 00       	callq  40230b <printf>
		return NULL;
  401daf:	b8 00 00 00 00       	mov    $0x0,%eax
  401db4:	eb 29                	jmp    401ddf <readdir+0xa1>

	}

	else if (ret == 0){
  401db6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  401dba:	75 07                	jne    401dc3 <readdir+0x85>

		//End of directory stream
		return NULL;
  401dbc:	b8 00 00 00 00       	mov    $0x0,%eax
  401dc1:	eb 1c                	jmp    401ddf <readdir+0xa1>

	}

	else if(ret !=0){
  401dc3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  401dc7:	74 11                	je     401dda <readdir+0x9c>

		//There is a valid child
		//printf("Ret of readdir is not 0\n");
		struct dirent* x = (struct dirent*)buff;
  401dc9:	48 8d 85 f0 fb ff ff 	lea    -0x410(%rbp),%rax
  401dd0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		//printf("Name of entry dir%s\n",x->d_name );
		return x;
  401dd4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401dd8:	eb 05                	jmp    401ddf <readdir+0xa1>
	}


	return NULL;
  401dda:	b8 00 00 00 00       	mov    $0x0,%eax

}
  401ddf:	c9                   	leaveq 
  401de0:	c3                   	retq   

0000000000401de1 <syscall_2>:
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
}

static __inline uint64_t syscall_2(uint64_t n, uint64_t a1, uint64_t a2) {
  401de1:	55                   	push   %rbp
  401de2:	48 89 e5             	mov    %rsp,%rbp
  401de5:	48 83 ec 28          	sub    $0x28,%rsp
  401de9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401ded:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  401df1:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	uint64_t ret;
	__asm__("movq %1,%%rax;"
  401df5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401df9:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401dfd:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  401e01:	cd 80                	int    $0x80
  401e03:	48 89 c0             	mov    %rax,%rax
  401e06:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %2,%%rdi;"
			"movq %3,%%rsi;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
  401e0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401e0e:	c9                   	leaveq 
  401e0f:	c3                   	retq   

0000000000401e10 <dup2>:
#include<sys/syscall.h>
#include<syscall.h>
#include<stdlib.h>

int dup2(int oldfd, int newfd)
{
  401e10:	55                   	push   %rbp
  401e11:	48 89 e5             	mov    %rsp,%rbp
  401e14:	48 83 ec 18          	sub    $0x18,%rsp
  401e18:	89 7d ec             	mov    %edi,-0x14(%rbp)
  401e1b:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int retvalue;
	retvalue = syscall_2(SYS_dup2, oldfd, newfd);
  401e1e:	8b 45 e8             	mov    -0x18(%rbp),%eax
  401e21:	48 63 d0             	movslq %eax,%rdx
  401e24:	8b 45 ec             	mov    -0x14(%rbp),%eax
  401e27:	48 98                	cltq   
  401e29:	48 89 c6             	mov    %rax,%rsi
  401e2c:	bf 21 00 00 00       	mov    $0x21,%edi
  401e31:	e8 ab ff ff ff       	callq  401de1 <syscall_2>
  401e36:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(retvalue >=0){
  401e39:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  401e3d:	78 05                	js     401e44 <dup2+0x34>
		return retvalue;
  401e3f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401e42:	eb 05                	jmp    401e49 <dup2+0x39>
	}
	return -1;
  401e44:	b8 ff ff ff ff       	mov    $0xffffffff,%eax


}
  401e49:	c9                   	leaveq 
  401e4a:	c3                   	retq   

0000000000401e4b <syscall_2>:
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
}

static __inline uint64_t syscall_2(uint64_t n, uint64_t a1, uint64_t a2) {
  401e4b:	55                   	push   %rbp
  401e4c:	48 89 e5             	mov    %rsp,%rbp
  401e4f:	48 83 ec 28          	sub    $0x28,%rsp
  401e53:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401e57:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  401e5b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	uint64_t ret;
	__asm__("movq %1,%%rax;"
  401e5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401e63:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401e67:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  401e6b:	cd 80                	int    $0x80
  401e6d:	48 89 c0             	mov    %rax,%rax
  401e70:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %2,%%rdi;"
			"movq %3,%%rsi;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
  401e74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401e78:	c9                   	leaveq 
  401e79:	c3                   	retq   

0000000000401e7a <open>:
#include <errno.h>

//int errno = 0;

int open(const char *pathname, int flags)
{
  401e7a:	55                   	push   %rbp
  401e7b:	48 89 e5             	mov    %rsp,%rbp
  401e7e:	48 83 ec 20          	sub    $0x20,%rsp
  401e82:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401e86:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int retvalue;
	retvalue = syscall_2(SYS_open, (uint64_t)pathname, (uint64_t)flags);
  401e89:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  401e8c:	48 63 d0             	movslq %eax,%rdx
  401e8f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401e93:	48 89 c6             	mov    %rax,%rsi
  401e96:	bf 02 00 00 00       	mov    $0x2,%edi
  401e9b:	e8 ab ff ff ff       	callq  401e4b <syscall_2>
  401ea0:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(retvalue >=0){
  401ea3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  401ea7:	78 05                	js     401eae <open+0x34>
		return retvalue;
  401ea9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401eac:	eb 05                	jmp    401eb3 <open+0x39>
	}

	return -1;
  401eae:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
  401eb3:	c9                   	leaveq 
  401eb4:	c3                   	retq   

0000000000401eb5 <syscall_2>:
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
}

static __inline uint64_t syscall_2(uint64_t n, uint64_t a1, uint64_t a2) {
  401eb5:	55                   	push   %rbp
  401eb6:	48 89 e5             	mov    %rsp,%rbp
  401eb9:	48 83 ec 28          	sub    $0x28,%rsp
  401ebd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401ec1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  401ec5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	uint64_t ret;
	__asm__("movq %1,%%rax;"
  401ec9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401ecd:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401ed1:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  401ed5:	cd 80                	int    $0x80
  401ed7:	48 89 c0             	mov    %rax,%rax
  401eda:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %2,%%rdi;"
			"movq %3,%%rsi;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
  401ede:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401ee2:	c9                   	leaveq 
  401ee3:	c3                   	retq   

0000000000401ee4 <getcwd>:
#include <stdlib.h>
#include <errno.h>

//int errno=0; //Only define here. declaration seeps through to the files via stdlib.h

char* getcwd(char *buf, size_t size){
  401ee4:	55                   	push   %rbp
  401ee5:	48 89 e5             	mov    %rsp,%rbp
  401ee8:	48 83 ec 20          	sub    $0x20,%rsp
  401eec:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401ef0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int retvalue;
	retvalue=syscall_2(SYS_getcwd,(uint64_t)buf,(uint64_t)size);
  401ef4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401ef8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  401efc:	48 89 c6             	mov    %rax,%rsi
  401eff:	bf 4f 00 00 00       	mov    $0x4f,%edi
  401f04:	e8 ac ff ff ff       	callq  401eb5 <syscall_2>
  401f09:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(retvalue >=0){
  401f0c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  401f10:	78 06                	js     401f18 <getcwd+0x34>
		return buf;
  401f12:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401f16:	eb 05                	jmp    401f1d <getcwd+0x39>
	}
	return NULL;
  401f18:	b8 00 00 00 00       	mov    $0x0,%eax

}
  401f1d:	c9                   	leaveq 
  401f1e:	c3                   	retq   

0000000000401f1f <syscall_1>:
			:"=r"(ret):"m"(n));

	return ret;
}

static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
  401f1f:	55                   	push   %rbp
  401f20:	48 89 e5             	mov    %rsp,%rbp
  401f23:	48 83 ec 20          	sub    $0x20,%rsp
  401f27:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401f2b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int64_t ret;

	__asm__("movq $78,%r15");
  401f2f:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
	//__asm__("movq %0,%%rax;"
	//		::"m"(n));

	//while(1);

	if(n==60){
  401f36:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401f3a:	48 83 f8 3c          	cmp    $0x3c,%rax
  401f3e:	75 0c                	jne    401f4c <syscall_1+0x2d>
		__asm__("movq %0,%%rax;"
  401f40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401f44:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401f48:	cd 80                	int    $0x80
  401f4a:	eb 11                	jmp    401f5d <syscall_1+0x3e>

		//while(1);
	}
	else{

		__asm__("movq %1,%%rax;"
  401f4c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401f50:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401f54:	cd 80                	int    $0x80
  401f56:	48 89 c0             	mov    %rax,%rax
  401f59:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				"movq %2,%%rdi;"
				"int $0x80;"
				"movq %%rax,%0;"
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
  401f5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401f61:	c9                   	leaveq 
  401f62:	c3                   	retq   

0000000000401f63 <close>:
#include<sys/syscall.h>
#include<syscall.h>
#include <stdlib.h>

int close(int fd)
{
  401f63:	55                   	push   %rbp
  401f64:	48 89 e5             	mov    %rsp,%rbp
  401f67:	48 83 ec 18          	sub    $0x18,%rsp
  401f6b:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int retvalue;
	retvalue = syscall_1(SYS_close, fd);
  401f6e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  401f71:	48 98                	cltq   
  401f73:	48 89 c6             	mov    %rax,%rsi
  401f76:	bf 03 00 00 00       	mov    $0x3,%edi
  401f7b:	e8 9f ff ff ff       	callq  401f1f <syscall_1>
  401f80:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(retvalue >=0){
  401f83:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  401f87:	78 05                	js     401f8e <close+0x2b>
		return retvalue;
  401f89:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401f8c:	eb 05                	jmp    401f93 <close+0x30>
	}
	return -1;
  401f8e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
  401f93:	c9                   	leaveq 
  401f94:	c3                   	retq   

0000000000401f95 <syscall_0>:
#define _SYSCALL_H

#include <sys/defs.h>
#include <sys/syscall.h>

static __inline uint64_t syscall_0(uint64_t n) {
  401f95:	55                   	push   %rbp
  401f96:	48 89 e5             	mov    %rsp,%rbp
  401f99:	48 83 ec 18          	sub    $0x18,%rsp
  401f9d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	uint64_t ret;
	__asm__("movq %1,%%rax;"
  401fa1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401fa5:	cd 80                	int    $0x80
  401fa7:	48 89 c0             	mov    %rax,%rax
  401faa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n));

	return ret;
  401fae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401fb2:	c9                   	leaveq 
  401fb3:	c3                   	retq   

0000000000401fb4 <syscall_3>:
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
}

static __inline uint64_t syscall_3(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3) {
  401fb4:	55                   	push   %rbp
  401fb5:	48 89 e5             	mov    %rsp,%rbp
  401fb8:	48 83 ec 30          	sub    $0x30,%rsp
  401fbc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401fc0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  401fc4:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  401fc8:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)

	uint64_t ret;
    
	__asm__("movq %1,%%rax;"
  401fcc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401fd0:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401fd4:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  401fd8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  401fdc:	cd 80                	int    $0x80
  401fde:	48 89 c0             	mov    %rax,%rax
  401fe1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %3, %%rsi;"
			"movq %4, %%rdx;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2),"m"(a3));
	return ret;
  401fe5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401fe9:	c9                   	leaveq 
  401fea:	c3                   	retq   

0000000000401feb <getpid>:
#include <sys/defs.h>
#include <stdlib.h>
#include <sys/syscall.h>

pid_t getpid()
{
  401feb:	55                   	push   %rbp
  401fec:	48 89 e5             	mov    %rsp,%rbp
  401fef:	48 83 ec 10          	sub    $0x10,%rsp
	int retvalue;
	retvalue = syscall_0(SYS_getpid);
  401ff3:	bf 27 00 00 00       	mov    $0x27,%edi
  401ff8:	e8 98 ff ff ff       	callq  401f95 <syscall_0>
  401ffd:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(retvalue >=0){
  402000:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  402004:	78 05                	js     40200b <getpid+0x20>
		return retvalue;
  402006:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402009:	eb 05                	jmp    402010 <getpid+0x25>
	}
	return -1;
  40200b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax


}
  402010:	c9                   	leaveq 
  402011:	c3                   	retq   

0000000000402012 <getppid>:

pid_t getppid()
{
  402012:	55                   	push   %rbp
  402013:	48 89 e5             	mov    %rsp,%rbp
  402016:	48 83 ec 10          	sub    $0x10,%rsp
	int retvalue;
	retvalue = syscall_0(SYS_getppid);
  40201a:	bf 6e 00 00 00       	mov    $0x6e,%edi
  40201f:	e8 71 ff ff ff       	callq  401f95 <syscall_0>
  402024:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(retvalue >=0){
  402027:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  40202b:	78 05                	js     402032 <getppid+0x20>
		return retvalue;
  40202d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402030:	eb 05                	jmp    402037 <getppid+0x25>
	}

	return -1;
  402032:	b8 ff ff ff ff       	mov    $0xffffffff,%eax


}
  402037:	c9                   	leaveq 
  402038:	c3                   	retq   

0000000000402039 <waitpid>:

pid_t waitpid(pid_t pid, int *status, int options)
{
  402039:	55                   	push   %rbp
  40203a:	48 89 e5             	mov    %rsp,%rbp
  40203d:	48 83 ec 20          	sub    $0x20,%rsp
  402041:	89 7d ec             	mov    %edi,-0x14(%rbp)
  402044:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  402048:	89 55 e8             	mov    %edx,-0x18(%rbp)
	pid_t retvalue;
	retvalue = syscall_3(SYS_wait4,(uint64_t)pid,(uint64_t)status,(uint64_t)options);
  40204b:	8b 45 e8             	mov    -0x18(%rbp),%eax
  40204e:	48 63 c8             	movslq %eax,%rcx
  402051:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  402055:	8b 45 ec             	mov    -0x14(%rbp),%eax
  402058:	48 89 c6             	mov    %rax,%rsi
  40205b:	bf 3d 00 00 00       	mov    $0x3d,%edi
  402060:	e8 4f ff ff ff       	callq  401fb4 <syscall_3>
  402065:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(retvalue >=0){
		return retvalue;
  402068:	8b 45 fc             	mov    -0x4(%rbp),%eax
	}

	return -1;

}
  40206b:	c9                   	leaveq 
  40206c:	c3                   	retq   

000000000040206d <syscall_1>:
			:"=r"(ret):"m"(n));

	return ret;
}

static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
  40206d:	55                   	push   %rbp
  40206e:	48 89 e5             	mov    %rsp,%rbp
  402071:	48 83 ec 20          	sub    $0x20,%rsp
  402075:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402079:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int64_t ret;

	__asm__("movq $78,%r15");
  40207d:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
	//__asm__("movq %0,%%rax;"
	//		::"m"(n));

	//while(1);

	if(n==60){
  402084:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402088:	48 83 f8 3c          	cmp    $0x3c,%rax
  40208c:	75 0c                	jne    40209a <syscall_1+0x2d>
		__asm__("movq %0,%%rax;"
  40208e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402092:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402096:	cd 80                	int    $0x80
  402098:	eb 11                	jmp    4020ab <syscall_1+0x3e>

		//while(1);
	}
	else{

		__asm__("movq %1,%%rax;"
  40209a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40209e:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  4020a2:	cd 80                	int    $0x80
  4020a4:	48 89 c0             	mov    %rax,%rax
  4020a7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				"movq %2,%%rdi;"
				"int $0x80;"
				"movq %%rax,%0;"
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
  4020ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  4020af:	c9                   	leaveq 
  4020b0:	c3                   	retq   

00000000004020b1 <closedir>:
#include<sys/defs.h>
#include<stdlib.h>
#include<errno.h>


int closedir(void *dir){
  4020b1:	55                   	push   %rbp
  4020b2:	48 89 e5             	mov    %rsp,%rbp
  4020b5:	48 83 ec 20          	sub    $0x20,%rsp
  4020b9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)


	if((uint64_t)dir == -1){
  4020bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4020c1:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  4020c5:	75 18                	jne    4020df <closedir+0x2e>

		printf("Cannot close bad directory stream\n");
  4020c7:	48 8d 3d ca 17 00 00 	lea    0x17ca(%rip),%rdi        # 403898 <chdir+0x537>
  4020ce:	b8 00 00 00 00       	mov    $0x0,%eax
  4020d3:	e8 33 02 00 00       	callq  40230b <printf>
		return -1;
  4020d8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4020dd:	eb 2c                	jmp    40210b <closedir+0x5a>
	}
	int fd = (uint64_t)dir;
  4020df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4020e3:	89 45 fc             	mov    %eax,-0x4(%rbp)

	int retvalue;
	retvalue = syscall_1(SYS_close,(uint64_t)fd);
  4020e6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4020e9:	48 98                	cltq   
  4020eb:	48 89 c6             	mov    %rax,%rsi
  4020ee:	bf 03 00 00 00       	mov    $0x3,%edi
  4020f3:	e8 75 ff ff ff       	callq  40206d <syscall_1>
  4020f8:	89 45 f8             	mov    %eax,-0x8(%rbp)

	//printf("closedir syscall returned %d\n",retvalue );

	if(retvalue<0){
  4020fb:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  4020ff:	79 07                	jns    402108 <closedir+0x57>
		
		return -1;
  402101:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  402106:	eb 03                	jmp    40210b <closedir+0x5a>

	}
	return retvalue;
  402108:	8b 45 f8             	mov    -0x8(%rbp),%eax


}
  40210b:	c9                   	leaveq 
  40210c:	c3                   	retq   

000000000040210d <print_num>:

// update errno.
char screen[1024];
int screen_ctr;
void print_num(int num, int base)
{
  40210d:	55                   	push   %rbp
  40210e:	48 89 e5             	mov    %rsp,%rbp
  402111:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  402118:	89 bd 6c ff ff ff    	mov    %edi,-0x94(%rbp)
  40211e:	89 b5 68 ff ff ff    	mov    %esi,-0x98(%rbp)
	int number[32];
	int i=0;
  402124:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

	if(base == 16)
  40212b:	83 bd 68 ff ff ff 10 	cmpl   $0x10,-0x98(%rbp)
  402132:	75 44                	jne    402178 <print_num+0x6b>
	{
		screen[screen_ctr++] = '0';
  402134:	48 8b 05 1d 24 20 00 	mov    0x20241d(%rip),%rax        # 604558 <chdir+0x2011f7>
  40213b:	8b 00                	mov    (%rax),%eax
  40213d:	8d 48 01             	lea    0x1(%rax),%ecx
  402140:	48 8b 15 11 24 20 00 	mov    0x202411(%rip),%rdx        # 604558 <chdir+0x2011f7>
  402147:	89 0a                	mov    %ecx,(%rdx)
  402149:	48 8b 15 10 24 20 00 	mov    0x202410(%rip),%rdx        # 604560 <chdir+0x2011ff>
  402150:	48 98                	cltq   
  402152:	c6 04 02 30          	movb   $0x30,(%rdx,%rax,1)
		screen[screen_ctr++] = 'x';
  402156:	48 8b 05 fb 23 20 00 	mov    0x2023fb(%rip),%rax        # 604558 <chdir+0x2011f7>
  40215d:	8b 00                	mov    (%rax),%eax
  40215f:	8d 48 01             	lea    0x1(%rax),%ecx
  402162:	48 8b 15 ef 23 20 00 	mov    0x2023ef(%rip),%rdx        # 604558 <chdir+0x2011f7>
  402169:	89 0a                	mov    %ecx,(%rdx)
  40216b:	48 8b 15 ee 23 20 00 	mov    0x2023ee(%rip),%rdx        # 604560 <chdir+0x2011ff>
  402172:	48 98                	cltq   
  402174:	c6 04 02 78          	movb   $0x78,(%rdx,%rax,1)
	}
	do
	{
		int rem=num%base;
  402178:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
  40217e:	99                   	cltd   
  40217f:	f7 bd 68 ff ff ff    	idivl  -0x98(%rbp)
  402185:	89 55 f8             	mov    %edx,-0x8(%rbp)
		if((rem) >= 10)
  402188:	83 7d f8 09          	cmpl   $0x9,-0x8(%rbp)
  40218c:	7e 06                	jle    402194 <print_num+0x87>
		{

			rem = rem-10 + 'a';
  40218e:	83 45 f8 57          	addl   $0x57,-0x8(%rbp)
  402192:	eb 04                	jmp    402198 <print_num+0x8b>
		}
		else{
			rem = rem + '0';
  402194:	83 45 f8 30          	addl   $0x30,-0x8(%rbp)
		}
		number[i]= rem;
  402198:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40219b:	48 98                	cltq   
  40219d:	8b 55 f8             	mov    -0x8(%rbp),%edx
  4021a0:	89 94 85 78 ff ff ff 	mov    %edx,-0x88(%rbp,%rax,4)
		i++;
  4021a7:	ff 45 fc             	incl   -0x4(%rbp)
	}while((num=num/base) !=0);
  4021aa:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
  4021b0:	99                   	cltd   
  4021b1:	f7 bd 68 ff ff ff    	idivl  -0x98(%rbp)
  4021b7:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
  4021bd:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%rbp)
  4021c4:	75 b2                	jne    402178 <print_num+0x6b>


	while(i-- != 0)
  4021c6:	eb 2e                	jmp    4021f6 <print_num+0xe9>
	{

		screen[screen_ctr++] = number[i];
  4021c8:	48 8b 05 89 23 20 00 	mov    0x202389(%rip),%rax        # 604558 <chdir+0x2011f7>
  4021cf:	8b 00                	mov    (%rax),%eax
  4021d1:	8d 48 01             	lea    0x1(%rax),%ecx
  4021d4:	48 8b 15 7d 23 20 00 	mov    0x20237d(%rip),%rdx        # 604558 <chdir+0x2011f7>
  4021db:	89 0a                	mov    %ecx,(%rdx)
  4021dd:	8b 55 fc             	mov    -0x4(%rbp),%edx
  4021e0:	48 63 d2             	movslq %edx,%rdx
  4021e3:	8b 94 95 78 ff ff ff 	mov    -0x88(%rbp,%rdx,4),%edx
  4021ea:	48 8b 0d 6f 23 20 00 	mov    0x20236f(%rip),%rcx        # 604560 <chdir+0x2011ff>
  4021f1:	48 98                	cltq   
  4021f3:	88 14 01             	mov    %dl,(%rcx,%rax,1)
		number[i]= rem;
		i++;
	}while((num=num/base) !=0);


	while(i-- != 0)
  4021f6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4021f9:	8d 50 ff             	lea    -0x1(%rax),%edx
  4021fc:	89 55 fc             	mov    %edx,-0x4(%rbp)
  4021ff:	85 c0                	test   %eax,%eax
  402201:	75 c5                	jne    4021c8 <print_num+0xbb>
	{

		screen[screen_ctr++] = number[i];
	}
}
  402203:	c9                   	leaveq 
  402204:	c3                   	retq   

0000000000402205 <print_ptr>:



void print_ptr(long unsigned int num, long unsigned int base)
{
  402205:	55                   	push   %rbp
  402206:	48 89 e5             	mov    %rsp,%rbp
  402209:	48 81 ec 20 01 00 00 	sub    $0x120,%rsp
  402210:	48 89 bd e8 fe ff ff 	mov    %rdi,-0x118(%rbp)
  402217:	48 89 b5 e0 fe ff ff 	mov    %rsi,-0x120(%rbp)
	long unsigned int number[32];
	int i=0;
  40221e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

		screen[screen_ctr++] = '0';
  402225:	48 8b 05 2c 23 20 00 	mov    0x20232c(%rip),%rax        # 604558 <chdir+0x2011f7>
  40222c:	8b 00                	mov    (%rax),%eax
  40222e:	8d 48 01             	lea    0x1(%rax),%ecx
  402231:	48 8b 15 20 23 20 00 	mov    0x202320(%rip),%rdx        # 604558 <chdir+0x2011f7>
  402238:	89 0a                	mov    %ecx,(%rdx)
  40223a:	48 8b 15 1f 23 20 00 	mov    0x20231f(%rip),%rdx        # 604560 <chdir+0x2011ff>
  402241:	48 98                	cltq   
  402243:	c6 04 02 30          	movb   $0x30,(%rdx,%rax,1)
		screen[screen_ctr++] = 'x';
  402247:	48 8b 05 0a 23 20 00 	mov    0x20230a(%rip),%rax        # 604558 <chdir+0x2011f7>
  40224e:	8b 00                	mov    (%rax),%eax
  402250:	8d 48 01             	lea    0x1(%rax),%ecx
  402253:	48 8b 15 fe 22 20 00 	mov    0x2022fe(%rip),%rdx        # 604558 <chdir+0x2011f7>
  40225a:	89 0a                	mov    %ecx,(%rdx)
  40225c:	48 8b 15 fd 22 20 00 	mov    0x2022fd(%rip),%rdx        # 604560 <chdir+0x2011ff>
  402263:	48 98                	cltq   
  402265:	c6 04 02 78          	movb   $0x78,(%rdx,%rax,1)
	
	do
	{
		long unsigned int rem=num%base;
  402269:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  402270:	ba 00 00 00 00       	mov    $0x0,%edx
  402275:	48 f7 b5 e0 fe ff ff 	divq   -0x120(%rbp)
  40227c:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
		if((rem) >= 10)
  402280:	48 83 7d f0 09       	cmpq   $0x9,-0x10(%rbp)
  402285:	76 07                	jbe    40228e <print_ptr+0x89>
		{
			rem = rem-10 + 'a';
  402287:	48 83 45 f0 57       	addq   $0x57,-0x10(%rbp)
  40228c:	eb 05                	jmp    402293 <print_ptr+0x8e>
		}
		else{
			rem = rem + '0';
  40228e:	48 83 45 f0 30       	addq   $0x30,-0x10(%rbp)
		}
		number[i]= rem;
  402293:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402296:	48 98                	cltq   
  402298:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  40229c:	48 89 94 c5 f0 fe ff 	mov    %rdx,-0x110(%rbp,%rax,8)
  4022a3:	ff 
		i++;
  4022a4:	ff 45 fc             	incl   -0x4(%rbp)
	}while((num=num/base) !=0);
  4022a7:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  4022ae:	ba 00 00 00 00       	mov    $0x0,%edx
  4022b3:	48 f7 b5 e0 fe ff ff 	divq   -0x120(%rbp)
  4022ba:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
  4022c1:	48 83 bd e8 fe ff ff 	cmpq   $0x0,-0x118(%rbp)
  4022c8:	00 
  4022c9:	75 9e                	jne    402269 <print_ptr+0x64>


	while(i-- != 0)
  4022cb:	eb 2f                	jmp    4022fc <print_ptr+0xf7>
	{

		screen[screen_ctr++] = number[i];
  4022cd:	48 8b 05 84 22 20 00 	mov    0x202284(%rip),%rax        # 604558 <chdir+0x2011f7>
  4022d4:	8b 00                	mov    (%rax),%eax
  4022d6:	8d 48 01             	lea    0x1(%rax),%ecx
  4022d9:	48 8b 15 78 22 20 00 	mov    0x202278(%rip),%rdx        # 604558 <chdir+0x2011f7>
  4022e0:	89 0a                	mov    %ecx,(%rdx)
  4022e2:	8b 55 fc             	mov    -0x4(%rbp),%edx
  4022e5:	48 63 d2             	movslq %edx,%rdx
  4022e8:	48 8b 94 d5 f0 fe ff 	mov    -0x110(%rbp,%rdx,8),%rdx
  4022ef:	ff 
  4022f0:	48 8b 0d 69 22 20 00 	mov    0x202269(%rip),%rcx        # 604560 <chdir+0x2011ff>
  4022f7:	48 98                	cltq   
  4022f9:	88 14 01             	mov    %dl,(%rcx,%rax,1)
		number[i]= rem;
		i++;
	}while((num=num/base) !=0);


	while(i-- != 0)
  4022fc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4022ff:	8d 50 ff             	lea    -0x1(%rax),%edx
  402302:	89 55 fc             	mov    %edx,-0x4(%rbp)
  402305:	85 c0                	test   %eax,%eax
  402307:	75 c4                	jne    4022cd <print_ptr+0xc8>
	{

		screen[screen_ctr++] = number[i];
    }
}
  402309:	c9                   	leaveq 
  40230a:	c3                   	retq   

000000000040230b <printf>:





int printf(const char *format, ...) {
  40230b:	55                   	push   %rbp
  40230c:	48 89 e5             	mov    %rsp,%rbp
  40230f:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  402316:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  40231a:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  40231e:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  402322:	4c 89 45 f0          	mov    %r8,-0x10(%rbp)
  402326:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
  40232a:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
	va_list val;
	int printed = 0;
  402331:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%rbp)
	screen_ctr=0;
  402338:	48 8b 05 19 22 20 00 	mov    0x202219(%rip),%rax        # 604558 <chdir+0x2011f7>
  40233f:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	va_start(val, format);
  402345:	c7 45 88 08 00 00 00 	movl   $0x8,-0x78(%rbp)
  40234c:	48 8d 45 10          	lea    0x10(%rbp),%rax
  402350:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  402354:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  402358:	48 89 45 98          	mov    %rax,-0x68(%rbp)

	while(*format)
  40235c:	e9 0d 03 00 00       	jmpq   40266e <printf+0x363>
	{
		if(*format == '%')
  402361:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  402368:	0f b6 00             	movzbl (%rax),%eax
  40236b:	3c 25                	cmp    $0x25,%al
  40236d:	0f 85 c6 02 00 00    	jne    402639 <printf+0x32e>
		{
			switch(*(++format))
  402373:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
  40237a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  402381:	0f b6 00             	movzbl (%rax),%eax
  402384:	0f be c0             	movsbl %al,%eax
  402387:	83 f8 64             	cmp    $0x64,%eax
  40238a:	74 3c                	je     4023c8 <printf+0xbd>
  40238c:	83 f8 64             	cmp    $0x64,%eax
  40238f:	7f 17                	jg     4023a8 <printf+0x9d>
  402391:	83 f8 25             	cmp    $0x25,%eax
  402394:	0f 84 73 02 00 00    	je     40260d <printf+0x302>
  40239a:	83 f8 63             	cmp    $0x63,%eax
  40239d:	0f 84 ae 00 00 00    	je     402451 <printf+0x146>
  4023a3:	e9 c6 02 00 00       	jmpq   40266e <printf+0x363>
  4023a8:	83 f8 73             	cmp    $0x73,%eax
  4023ab:	0f 84 03 01 00 00    	je     4024b4 <printf+0x1a9>
  4023b1:	83 f8 78             	cmp    $0x78,%eax
  4023b4:	0f 84 7b 01 00 00    	je     402535 <printf+0x22a>
  4023ba:	83 f8 70             	cmp    $0x70,%eax
  4023bd:	0f 84 fb 01 00 00    	je     4025be <printf+0x2b3>
  4023c3:	e9 a6 02 00 00       	jmpq   40266e <printf+0x363>
			{
			case 'd':
				printed=printed;
				int num = va_arg(val, int);
  4023c8:	8b 45 88             	mov    -0x78(%rbp),%eax
  4023cb:	83 f8 30             	cmp    $0x30,%eax
  4023ce:	73 17                	jae    4023e7 <printf+0xdc>
  4023d0:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  4023d4:	8b 45 88             	mov    -0x78(%rbp),%eax
  4023d7:	89 c0                	mov    %eax,%eax
  4023d9:	48 01 d0             	add    %rdx,%rax
  4023dc:	8b 55 88             	mov    -0x78(%rbp),%edx
  4023df:	83 c2 08             	add    $0x8,%edx
  4023e2:	89 55 88             	mov    %edx,-0x78(%rbp)
  4023e5:	eb 0f                	jmp    4023f6 <printf+0xeb>
  4023e7:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  4023eb:	48 89 d0             	mov    %rdx,%rax
  4023ee:	48 83 c2 08          	add    $0x8,%rdx
  4023f2:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
  4023f6:	8b 00                	mov    (%rax),%eax
  4023f8:	89 45 bc             	mov    %eax,-0x44(%rbp)
				if(num<0)
  4023fb:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
  4023ff:	79 35                	jns    402436 <printf+0x12b>
				{
					screen[screen_ctr++]='-';
  402401:	48 8b 05 50 21 20 00 	mov    0x202150(%rip),%rax        # 604558 <chdir+0x2011f7>
  402408:	8b 00                	mov    (%rax),%eax
  40240a:	8d 48 01             	lea    0x1(%rax),%ecx
  40240d:	48 8b 15 44 21 20 00 	mov    0x202144(%rip),%rdx        # 604558 <chdir+0x2011f7>
  402414:	89 0a                	mov    %ecx,(%rdx)
  402416:	48 8b 15 43 21 20 00 	mov    0x202143(%rip),%rdx        # 604560 <chdir+0x2011ff>
  40241d:	48 98                	cltq   
  40241f:	c6 04 02 2d          	movb   $0x2d,(%rdx,%rax,1)
					print_num(-num,10);
  402423:	8b 45 bc             	mov    -0x44(%rbp),%eax
  402426:	f7 d8                	neg    %eax
  402428:	be 0a 00 00 00       	mov    $0xa,%esi
  40242d:	89 c7                	mov    %eax,%edi
  40242f:	e8 d9 fc ff ff       	callq  40210d <print_num>
  402434:	eb 0f                	jmp    402445 <printf+0x13a>
				}
				else
					print_num(num,10);
  402436:	8b 45 bc             	mov    -0x44(%rbp),%eax
  402439:	be 0a 00 00 00       	mov    $0xa,%esi
  40243e:	89 c7                	mov    %eax,%edi
  402440:	e8 c8 fc ff ff       	callq  40210d <print_num>
				format++;
  402445:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
				continue;
  40244c:	e9 1d 02 00 00       	jmpq   40266e <printf+0x363>

			case 'c':
				printed=printed;;
				int chr = va_arg(val, int);
  402451:	8b 45 88             	mov    -0x78(%rbp),%eax
  402454:	83 f8 30             	cmp    $0x30,%eax
  402457:	73 17                	jae    402470 <printf+0x165>
  402459:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  40245d:	8b 45 88             	mov    -0x78(%rbp),%eax
  402460:	89 c0                	mov    %eax,%eax
  402462:	48 01 d0             	add    %rdx,%rax
  402465:	8b 55 88             	mov    -0x78(%rbp),%edx
  402468:	83 c2 08             	add    $0x8,%edx
  40246b:	89 55 88             	mov    %edx,-0x78(%rbp)
  40246e:	eb 0f                	jmp    40247f <printf+0x174>
  402470:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  402474:	48 89 d0             	mov    %rdx,%rax
  402477:	48 83 c2 08          	add    $0x8,%rdx
  40247b:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
  40247f:	8b 00                	mov    (%rax),%eax
  402481:	89 45 b8             	mov    %eax,-0x48(%rbp)
				screen[screen_ctr++] = chr;
  402484:	48 8b 05 cd 20 20 00 	mov    0x2020cd(%rip),%rax        # 604558 <chdir+0x2011f7>
  40248b:	8b 00                	mov    (%rax),%eax
  40248d:	8d 48 01             	lea    0x1(%rax),%ecx
  402490:	48 8b 15 c1 20 20 00 	mov    0x2020c1(%rip),%rdx        # 604558 <chdir+0x2011f7>
  402497:	89 0a                	mov    %ecx,(%rdx)
  402499:	8b 55 b8             	mov    -0x48(%rbp),%edx
  40249c:	48 8b 0d bd 20 20 00 	mov    0x2020bd(%rip),%rcx        # 604560 <chdir+0x2011ff>
  4024a3:	48 98                	cltq   
  4024a5:	88 14 01             	mov    %dl,(%rcx,%rax,1)
				format++;
  4024a8:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
				continue;
  4024af:	e9 ba 01 00 00       	jmpq   40266e <printf+0x363>

			case 's':
				printed=printed;
				char* str = va_arg(val, char*);
  4024b4:	8b 45 88             	mov    -0x78(%rbp),%eax
  4024b7:	83 f8 30             	cmp    $0x30,%eax
  4024ba:	73 17                	jae    4024d3 <printf+0x1c8>
  4024bc:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  4024c0:	8b 45 88             	mov    -0x78(%rbp),%eax
  4024c3:	89 c0                	mov    %eax,%eax
  4024c5:	48 01 d0             	add    %rdx,%rax
  4024c8:	8b 55 88             	mov    -0x78(%rbp),%edx
  4024cb:	83 c2 08             	add    $0x8,%edx
  4024ce:	89 55 88             	mov    %edx,-0x78(%rbp)
  4024d1:	eb 0f                	jmp    4024e2 <printf+0x1d7>
  4024d3:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  4024d7:	48 89 d0             	mov    %rdx,%rax
  4024da:	48 83 c2 08          	add    $0x8,%rdx
  4024de:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
  4024e2:	48 8b 00             	mov    (%rax),%rax
  4024e5:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				while(*(str) != '\0')
  4024e9:	eb 33                	jmp    40251e <printf+0x213>
					screen[screen_ctr++] = *str++;
  4024eb:	48 8b 05 66 20 20 00 	mov    0x202066(%rip),%rax        # 604558 <chdir+0x2011f7>
  4024f2:	8b 00                	mov    (%rax),%eax
  4024f4:	89 c2                	mov    %eax,%edx
  4024f6:	8d 4a 01             	lea    0x1(%rdx),%ecx
  4024f9:	48 8b 05 58 20 20 00 	mov    0x202058(%rip),%rax        # 604558 <chdir+0x2011f7>
  402500:	89 08                	mov    %ecx,(%rax)
  402502:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  402506:	48 8d 48 01          	lea    0x1(%rax),%rcx
  40250a:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  40250e:	0f b6 00             	movzbl (%rax),%eax
  402511:	48 8b 0d 48 20 20 00 	mov    0x202048(%rip),%rcx        # 604560 <chdir+0x2011ff>
  402518:	48 63 d2             	movslq %edx,%rdx
  40251b:	88 04 11             	mov    %al,(%rcx,%rdx,1)
				continue;

			case 's':
				printed=printed;
				char* str = va_arg(val, char*);
				while(*(str) != '\0')
  40251e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  402522:	0f b6 00             	movzbl (%rax),%eax
  402525:	84 c0                	test   %al,%al
  402527:	75 c2                	jne    4024eb <printf+0x1e0>
					screen[screen_ctr++] = *str++;
				format++;
  402529:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
				continue;
  402530:	e9 39 01 00 00       	jmpq   40266e <printf+0x363>

			case 'x':
				printed=printed;
				int hex = va_arg(val, int);
  402535:	8b 45 88             	mov    -0x78(%rbp),%eax
  402538:	83 f8 30             	cmp    $0x30,%eax
  40253b:	73 17                	jae    402554 <printf+0x249>
  40253d:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  402541:	8b 45 88             	mov    -0x78(%rbp),%eax
  402544:	89 c0                	mov    %eax,%eax
  402546:	48 01 d0             	add    %rdx,%rax
  402549:	8b 55 88             	mov    -0x78(%rbp),%edx
  40254c:	83 c2 08             	add    $0x8,%edx
  40254f:	89 55 88             	mov    %edx,-0x78(%rbp)
  402552:	eb 0f                	jmp    402563 <printf+0x258>
  402554:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  402558:	48 89 d0             	mov    %rdx,%rax
  40255b:	48 83 c2 08          	add    $0x8,%rdx
  40255f:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
  402563:	8b 00                	mov    (%rax),%eax
  402565:	89 45 b4             	mov    %eax,-0x4c(%rbp)
				if(hex<0)
  402568:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
  40256c:	79 35                	jns    4025a3 <printf+0x298>
				{
					screen[screen_ctr++]='-';
  40256e:	48 8b 05 e3 1f 20 00 	mov    0x201fe3(%rip),%rax        # 604558 <chdir+0x2011f7>
  402575:	8b 00                	mov    (%rax),%eax
  402577:	8d 48 01             	lea    0x1(%rax),%ecx
  40257a:	48 8b 15 d7 1f 20 00 	mov    0x201fd7(%rip),%rdx        # 604558 <chdir+0x2011f7>
  402581:	89 0a                	mov    %ecx,(%rdx)
  402583:	48 8b 15 d6 1f 20 00 	mov    0x201fd6(%rip),%rdx        # 604560 <chdir+0x2011ff>
  40258a:	48 98                	cltq   
  40258c:	c6 04 02 2d          	movb   $0x2d,(%rdx,%rax,1)
					print_num(-hex,16);
  402590:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  402593:	f7 d8                	neg    %eax
  402595:	be 10 00 00 00       	mov    $0x10,%esi
  40259a:	89 c7                	mov    %eax,%edi
  40259c:	e8 6c fb ff ff       	callq  40210d <print_num>
  4025a1:	eb 0f                	jmp    4025b2 <printf+0x2a7>
				}
				else
					print_num(hex,16);
  4025a3:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  4025a6:	be 10 00 00 00       	mov    $0x10,%esi
  4025ab:	89 c7                	mov    %eax,%edi
  4025ad:	e8 5b fb ff ff       	callq  40210d <print_num>

				format++;
  4025b2:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
				continue;
  4025b9:	e9 b0 00 00 00       	jmpq   40266e <printf+0x363>

			case 'p':
				printed=printed;
				long unsigned int ptr =(unsigned long int) va_arg(val, long int );
  4025be:	8b 45 88             	mov    -0x78(%rbp),%eax
  4025c1:	83 f8 30             	cmp    $0x30,%eax
  4025c4:	73 17                	jae    4025dd <printf+0x2d2>
  4025c6:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  4025ca:	8b 45 88             	mov    -0x78(%rbp),%eax
  4025cd:	89 c0                	mov    %eax,%eax
  4025cf:	48 01 d0             	add    %rdx,%rax
  4025d2:	8b 55 88             	mov    -0x78(%rbp),%edx
  4025d5:	83 c2 08             	add    $0x8,%edx
  4025d8:	89 55 88             	mov    %edx,-0x78(%rbp)
  4025db:	eb 0f                	jmp    4025ec <printf+0x2e1>
  4025dd:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  4025e1:	48 89 d0             	mov    %rdx,%rax
  4025e4:	48 83 c2 08          	add    $0x8,%rdx
  4025e8:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
  4025ec:	48 8b 00             	mov    (%rax),%rax
  4025ef:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
				print_ptr(ptr,16);
  4025f3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  4025f7:	be 10 00 00 00       	mov    $0x10,%esi
  4025fc:	48 89 c7             	mov    %rax,%rdi
  4025ff:	e8 01 fc ff ff       	callq  402205 <print_ptr>

				format++;
  402604:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
				continue;
  40260b:	eb 61                	jmp    40266e <printf+0x363>


			case '%':
				printed=printed;
				char c='%';
  40260d:	c6 45 a7 25          	movb   $0x25,-0x59(%rbp)

				screen[screen_ctr++] = c;
  402611:	48 8b 05 40 1f 20 00 	mov    0x201f40(%rip),%rax        # 604558 <chdir+0x2011f7>
  402618:	8b 00                	mov    (%rax),%eax
  40261a:	8d 48 01             	lea    0x1(%rax),%ecx
  40261d:	48 8b 15 34 1f 20 00 	mov    0x201f34(%rip),%rdx        # 604558 <chdir+0x2011f7>
  402624:	89 0a                	mov    %ecx,(%rdx)
  402626:	48 8b 0d 33 1f 20 00 	mov    0x201f33(%rip),%rcx        # 604560 <chdir+0x2011ff>
  40262d:	48 63 d0             	movslq %eax,%rdx
  402630:	0f b6 45 a7          	movzbl -0x59(%rbp),%eax
  402634:	88 04 11             	mov    %al,(%rcx,%rdx,1)
  402637:	eb 35                	jmp    40266e <printf+0x363>
			}
		}
		else
		{

			screen[screen_ctr++] = *format;
  402639:	48 8b 05 18 1f 20 00 	mov    0x201f18(%rip),%rax        # 604558 <chdir+0x2011f7>
  402640:	8b 00                	mov    (%rax),%eax
  402642:	8d 48 01             	lea    0x1(%rax),%ecx
  402645:	48 8b 15 0c 1f 20 00 	mov    0x201f0c(%rip),%rdx        # 604558 <chdir+0x2011f7>
  40264c:	89 0a                	mov    %ecx,(%rdx)
  40264e:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  402655:	0f b6 12             	movzbl (%rdx),%edx
  402658:	48 8b 0d 01 1f 20 00 	mov    0x201f01(%rip),%rcx        # 604560 <chdir+0x2011ff>
  40265f:	48 98                	cltq   
  402661:	88 14 01             	mov    %dl,(%rcx,%rax,1)
			++printed;
  402664:	ff 45 cc             	incl   -0x34(%rbp)
			++format;
  402667:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
	va_list val;
	int printed = 0;
	screen_ctr=0;
	va_start(val, format);

	while(*format)
  40266e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  402675:	0f b6 00             	movzbl (%rax),%eax
  402678:	84 c0                	test   %al,%al
  40267a:	0f 85 e1 fc ff ff    	jne    402361 <printf+0x56>
			++printed;
			++format;
		}
	}

	printed = write(1,screen, screen_ctr);
  402680:	48 8b 05 d1 1e 20 00 	mov    0x201ed1(%rip),%rax        # 604558 <chdir+0x2011f7>
  402687:	8b 00                	mov    (%rax),%eax
  402689:	48 98                	cltq   
  40268b:	48 89 c2             	mov    %rax,%rdx
  40268e:	48 8b 05 cb 1e 20 00 	mov    0x201ecb(%rip),%rax        # 604560 <chdir+0x2011ff>
  402695:	48 89 c6             	mov    %rax,%rsi
  402698:	bf 01 00 00 00       	mov    $0x1,%edi
  40269d:	e8 52 00 00 00       	callq  4026f4 <write>
  4026a2:	89 45 cc             	mov    %eax,-0x34(%rbp)
	if(printed < 0)
  4026a5:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  4026a9:	79 07                	jns    4026b2 <printf+0x3a7>
		return -1;
  4026ab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4026b0:	eb 09                	jmp    4026bb <printf+0x3b0>
	return screen_ctr;
  4026b2:	48 8b 05 9f 1e 20 00 	mov    0x201e9f(%rip),%rax        # 604558 <chdir+0x2011f7>
  4026b9:	8b 00                	mov    (%rax),%eax

}
  4026bb:	c9                   	leaveq 
  4026bc:	c3                   	retq   

00000000004026bd <syscall_3>:
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
}

static __inline uint64_t syscall_3(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3) {
  4026bd:	55                   	push   %rbp
  4026be:	48 89 e5             	mov    %rsp,%rbp
  4026c1:	48 83 ec 30          	sub    $0x30,%rsp
  4026c5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  4026c9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  4026cd:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  4026d1:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)

	uint64_t ret;
    
	__asm__("movq %1,%%rax;"
  4026d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4026d9:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  4026dd:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  4026e1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  4026e5:	cd 80                	int    $0x80
  4026e7:	48 89 c0             	mov    %rax,%rax
  4026ea:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %3, %%rsi;"
			"movq %4, %%rdx;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2),"m"(a3));
	return ret;
  4026ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  4026f2:	c9                   	leaveq 
  4026f3:	c3                   	retq   

00000000004026f4 <write>:
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>


ssize_t write(int fd, const void *buf, size_t count){
  4026f4:	55                   	push   %rbp
  4026f5:	48 89 e5             	mov    %rsp,%rbp
  4026f8:	48 83 ec 28          	sub    $0x28,%rsp
  4026fc:	89 7d ec             	mov    %edi,-0x14(%rbp)
  4026ff:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  402703:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	int retvalue=syscall_3(SYS_write,fd,(uint64_t)buf,(uint64_t)count);
  402707:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  40270b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  40270e:	48 98                	cltq   
  402710:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  402714:	48 89 c6             	mov    %rax,%rsi
  402717:	bf 01 00 00 00       	mov    $0x1,%edi
  40271c:	e8 9c ff ff ff       	callq  4026bd <syscall_3>
  402721:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(retvalue >=0){
  402724:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  402728:	78 07                	js     402731 <write+0x3d>
		return retvalue;
  40272a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40272d:	48 98                	cltq   
  40272f:	eb 07                	jmp    402738 <write+0x44>
	}
	return -1;
  402731:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
}
  402738:	c9                   	leaveq 
  402739:	c3                   	retq   

000000000040273a <syscall_2>:
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
}

static __inline uint64_t syscall_2(uint64_t n, uint64_t a1, uint64_t a2) {
  40273a:	55                   	push   %rbp
  40273b:	48 89 e5             	mov    %rsp,%rbp
  40273e:	48 83 ec 28          	sub    $0x28,%rsp
  402742:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402746:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  40274a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	uint64_t ret;
	__asm__("movq %1,%%rax;"
  40274e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402752:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402756:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  40275a:	cd 80                	int    $0x80
  40275c:	48 89 c0             	mov    %rax,%rax
  40275f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %2,%%rdi;"
			"movq %3,%%rsi;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
  402763:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  402767:	c9                   	leaveq 
  402768:	c3                   	retq   

0000000000402769 <opendir>:
#include<syscall.h>
#include<string.h>


void *opendir(const char *name)
{
  402769:	55                   	push   %rbp
  40276a:	48 89 e5             	mov    %rsp,%rbp
  40276d:	48 83 ec 20          	sub    $0x20,%rsp
  402771:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	
	uint64_t fd=0;
  402775:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  40277c:	00 

	//WARNING THIS IS A HACK MUST ALLOCATE SPACE FR FD and return it

	fd = (uint64_t)syscall_2(SYS_open, (uint64_t) name, O_DIRECTORY | O_RDONLY);
  40277d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402781:	ba 00 00 01 00       	mov    $0x10000,%edx
  402786:	48 89 c6             	mov    %rax,%rsi
  402789:	bf 02 00 00 00       	mov    $0x2,%edi
  40278e:	e8 a7 ff ff ff       	callq  40273a <syscall_2>
  402793:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	


	if(fd == -1){
  402797:	48 83 7d f8 ff       	cmpq   $0xffffffffffffffff,-0x8(%rbp)
  40279c:	75 1a                	jne    4027b8 <opendir+0x4f>
		printf("No such file or directory\n");
  40279e:	48 8d 3d 16 11 00 00 	lea    0x1116(%rip),%rdi        # 4038bb <chdir+0x55a>
  4027a5:	b8 00 00 00 00       	mov    $0x0,%eax
  4027aa:	e8 5c fb ff ff       	callq  40230b <printf>
		return (void*)-1;
  4027af:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  4027b6:	eb 04                	jmp    4027bc <opendir+0x53>
	}

	return (void*)fd;
  4027b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  4027bc:	c9                   	leaveq 
  4027bd:	c3                   	retq   

00000000004027be <syscall_3>:

static __inline uint64_t syscall_3(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3) {
  4027be:	55                   	push   %rbp
  4027bf:	48 89 e5             	mov    %rsp,%rbp
  4027c2:	48 83 ec 30          	sub    $0x30,%rsp
  4027c6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  4027ca:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  4027ce:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  4027d2:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)

	uint64_t ret;
    
	__asm__("movq %1,%%rax;"
  4027d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4027da:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  4027de:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  4027e2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  4027e6:	cd 80                	int    $0x80
  4027e8:	48 89 c0             	mov    %rax,%rax
  4027eb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %3, %%rsi;"
			"movq %4, %%rdx;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2),"m"(a3));
	return ret;
  4027ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  4027f3:	c9                   	leaveq 
  4027f4:	c3                   	retq   

00000000004027f5 <read>:
#include <sys/syscall.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>

ssize_t read(int fd, void *buf, size_t count){
  4027f5:	55                   	push   %rbp
  4027f6:	48 89 e5             	mov    %rsp,%rbp
  4027f9:	48 83 ec 30          	sub    $0x30,%rsp
  4027fd:	89 7d ec             	mov    %edi,-0x14(%rbp)
  402800:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  402804:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	int retvalue;
	retvalue =syscall_3(SYS_read,fd,(uint64_t)buf,(uint64_t)count);
  402808:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  40280c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  40280f:	48 98                	cltq   
  402811:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  402815:	48 89 c6             	mov    %rax,%rsi
  402818:	bf 00 00 00 00       	mov    $0x0,%edi
  40281d:	e8 9c ff ff ff       	callq  4027be <syscall_3>
  402822:	89 45 fc             	mov    %eax,-0x4(%rbp)
	
	if(retvalue < 0 ){
  402825:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  402829:	79 1a                	jns    402845 <read+0x50>
		printf("Error in reading File\n");
  40282b:	48 8d 3d a4 10 00 00 	lea    0x10a4(%rip),%rdi        # 4038d6 <chdir+0x575>
  402832:	b8 00 00 00 00       	mov    $0x0,%eax
  402837:	e8 cf fa ff ff       	callq  40230b <printf>
		return -1;
  40283c:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  402843:	eb 05                	jmp    40284a <read+0x55>
	}
	
	return retvalue;
  402845:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402848:	48 98                	cltq   

}
  40284a:	c9                   	leaveq 
  40284b:	c3                   	retq   

000000000040284c <syscall_1>:
			:"=r"(ret):"m"(n));

	return ret;
}

static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
  40284c:	55                   	push   %rbp
  40284d:	48 89 e5             	mov    %rsp,%rbp
  402850:	48 83 ec 20          	sub    $0x20,%rsp
  402854:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402858:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int64_t ret;

	__asm__("movq $78,%r15");
  40285c:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
	//__asm__("movq %0,%%rax;"
	//		::"m"(n));

	//while(1);

	if(n==60){
  402863:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402867:	48 83 f8 3c          	cmp    $0x3c,%rax
  40286b:	75 0c                	jne    402879 <syscall_1+0x2d>
		__asm__("movq %0,%%rax;"
  40286d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402871:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402875:	cd 80                	int    $0x80
  402877:	eb 11                	jmp    40288a <syscall_1+0x3e>

		//while(1);
	}
	else{

		__asm__("movq %1,%%rax;"
  402879:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40287d:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402881:	cd 80                	int    $0x80
  402883:	48 89 c0             	mov    %rax,%rax
  402886:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				"movq %2,%%rdi;"
				"int $0x80;"
				"movq %%rax,%0;"
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
  40288a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  40288e:	c9                   	leaveq 
  40288f:	c3                   	retq   

0000000000402890 <pipe>:
#include<sys/defs.h>
#include<sys/syscall.h>
#include<syscall.h>
#include<stdlib.h>
int pipe(int fd[2])
{
  402890:	55                   	push   %rbp
  402891:	48 89 e5             	mov    %rsp,%rbp
  402894:	48 83 ec 18          	sub    $0x18,%rsp
  402898:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int retvalue;
	retvalue = syscall_1(SYS_pipe, (uint64_t)fd);
  40289c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4028a0:	48 89 c6             	mov    %rax,%rsi
  4028a3:	bf 16 00 00 00       	mov    $0x16,%edi
  4028a8:	e8 9f ff ff ff       	callq  40284c <syscall_1>
  4028ad:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(retvalue >=0){
  4028b0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  4028b4:	78 05                	js     4028bb <pipe+0x2b>
		return retvalue;
  4028b6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4028b9:	eb 05                	jmp    4028c0 <pipe+0x30>
	}

	return -1;
  4028bb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  4028c0:	c9                   	leaveq 
  4028c1:	c3                   	retq   

00000000004028c2 <syscall_3>:
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
}

static __inline uint64_t syscall_3(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3) {
  4028c2:	55                   	push   %rbp
  4028c3:	48 89 e5             	mov    %rsp,%rbp
  4028c6:	48 83 ec 30          	sub    $0x30,%rsp
  4028ca:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  4028ce:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  4028d2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  4028d6:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)

	uint64_t ret;
    
	__asm__("movq %1,%%rax;"
  4028da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4028de:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  4028e2:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  4028e6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  4028ea:	cd 80                	int    $0x80
  4028ec:	48 89 c0             	mov    %rax,%rax
  4028ef:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %3, %%rsi;"
			"movq %4, %%rdx;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2),"m"(a3));
	return ret;
  4028f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  4028f7:	c9                   	leaveq 
  4028f8:	c3                   	retq   

00000000004028f9 <execve>:
#include<sys/syscall.h>
#include<syscall.h>
#include<stdlib.h>

int execve(const char *filename, char *const argv[], char *const envp[])
{
  4028f9:	55                   	push   %rbp
  4028fa:	48 89 e5             	mov    %rsp,%rbp
  4028fd:	48 83 ec 28          	sub    $0x28,%rsp
  402901:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402905:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  402909:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
		int retvalue;
		retvalue = syscall_3(SYS_execve, (uint64_t)filename, (uint64_t)argv, (uint64_t)envp);
  40290d:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  402911:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  402915:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402919:	48 89 c6             	mov    %rax,%rsi
  40291c:	bf 3b 00 00 00       	mov    $0x3b,%edi
  402921:	e8 9c ff ff ff       	callq  4028c2 <syscall_3>
  402926:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if(retvalue >=0){
  402929:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  40292d:	78 05                	js     402934 <execve+0x3b>
			return retvalue;
  40292f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402932:	eb 05                	jmp    402939 <execve+0x40>
		}
		return -1;
  402934:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
  402939:	c9                   	leaveq 
  40293a:	c3                   	retq   

000000000040293b <syscall_0>:
#define _SYSCALL_H

#include <sys/defs.h>
#include <sys/syscall.h>

static __inline uint64_t syscall_0(uint64_t n) {
  40293b:	55                   	push   %rbp
  40293c:	48 89 e5             	mov    %rsp,%rbp
  40293f:	48 83 ec 18          	sub    $0x18,%rsp
  402943:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	uint64_t ret;
	__asm__("movq %1,%%rax;"
  402947:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40294b:	cd 80                	int    $0x80
  40294d:	48 89 c0             	mov    %rax,%rax
  402950:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n));

	return ret;
  402954:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  402958:	c9                   	leaveq 
  402959:	c3                   	retq   

000000000040295a <fork>:
#include <stdio.h>
#include <errno.h>


pid_t fork()
{
  40295a:	55                   	push   %rbp
  40295b:	48 89 e5             	mov    %rsp,%rbp
  40295e:	48 83 ec 10          	sub    $0x10,%rsp
	int retvalue;

	retvalue = syscall_0(SYS_fork);
  402962:	bf 39 00 00 00       	mov    $0x39,%edi
  402967:	e8 cf ff ff ff       	callq  40293b <syscall_0>
  40296c:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(retvalue >=0){
  40296f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  402973:	78 05                	js     40297a <fork+0x20>
		return retvalue;
  402975:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402978:	eb 05                	jmp    40297f <fork+0x25>
	}
	return -1;
  40297a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
  40297f:	c9                   	leaveq 
  402980:	c3                   	retq   

0000000000402981 <syscall_1>:

static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
  402981:	55                   	push   %rbp
  402982:	48 89 e5             	mov    %rsp,%rbp
  402985:	48 83 ec 20          	sub    $0x20,%rsp
  402989:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  40298d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int64_t ret;

	__asm__("movq $78,%r15");
  402991:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
	//__asm__("movq %0,%%rax;"
	//		::"m"(n));

	//while(1);

	if(n==60){
  402998:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40299c:	48 83 f8 3c          	cmp    $0x3c,%rax
  4029a0:	75 0c                	jne    4029ae <syscall_1+0x2d>
		__asm__("movq %0,%%rax;"
  4029a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4029a6:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  4029aa:	cd 80                	int    $0x80
  4029ac:	eb 11                	jmp    4029bf <syscall_1+0x3e>

		//while(1);
	}
	else{

		__asm__("movq %1,%%rax;"
  4029ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4029b2:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  4029b6:	cd 80                	int    $0x80
  4029b8:	48 89 c0             	mov    %rax,%rax
  4029bb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				"movq %2,%%rdi;"
				"int $0x80;"
				"movq %%rax,%0;"
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
  4029bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  4029c3:	c9                   	leaveq 
  4029c4:	c3                   	retq   

00000000004029c5 <exit>:
#include <sys/defs.h>
#include <syscall.h>
#include <stdlib.h>
#include <sys/syscall.h>

void exit(int status){
  4029c5:	55                   	push   %rbp
  4029c6:	48 89 e5             	mov    %rsp,%rbp
  4029c9:	48 83 ec 08          	sub    $0x8,%rsp
  4029cd:	89 7d fc             	mov    %edi,-0x4(%rbp)

	syscall_1(SYS_exit,44);
  4029d0:	be 2c 00 00 00       	mov    $0x2c,%esi
  4029d5:	bf 3c 00 00 00       	mov    $0x3c,%edi
  4029da:	e8 a2 ff ff ff       	callq  402981 <syscall_1>


}
  4029df:	c9                   	leaveq 
  4029e0:	c3                   	retq   

00000000004029e1 <strlen>:
#include <errno.h>



int strlen(const char *str)
{
  4029e1:	55                   	push   %rbp
  4029e2:	48 89 e5             	mov    %rsp,%rbp
  4029e5:	48 83 ec 18          	sub    $0x18,%rsp
  4029e9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	const char *ptr=str;
  4029ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4029f1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for(;*ptr != '\0'; ptr++);
  4029f5:	eb 04                	jmp    4029fb <strlen+0x1a>
  4029f7:	48 ff 45 f8          	incq   -0x8(%rbp)
  4029fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4029ff:	0f b6 00             	movzbl (%rax),%eax
  402a02:	84 c0                	test   %al,%al
  402a04:	75 f1                	jne    4029f7 <strlen+0x16>

	return ptr-str;
  402a06:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  402a0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402a0e:	48 29 c2             	sub    %rax,%rdx
  402a11:	48 89 d0             	mov    %rdx,%rax
}
  402a14:	c9                   	leaveq 
  402a15:	c3                   	retq   

0000000000402a16 <strcpy>:

char* strcpy(char* dst, const char* src)
{
  402a16:	55                   	push   %rbp
  402a17:	48 89 e5             	mov    %rsp,%rbp
  402a1a:	48 83 ec 30          	sub    $0x30,%rsp
  402a1e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  402a22:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	////printf("In strcpy\n");
	int i, len=strlen(src);
  402a26:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  402a2a:	48 89 c7             	mov    %rax,%rdi
  402a2d:	e8 af ff ff ff       	callq  4029e1 <strlen>
  402a32:	89 45 ec             	mov    %eax,-0x14(%rbp)
	//printf("In strlen.... length of src %d\n",len);
	char* ptr=dst;
  402a35:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402a39:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	for(i=0; i<=len; i++)
  402a3d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  402a44:	eb 21                	jmp    402a67 <strcpy+0x51>
	{
		*ptr++ = src[i];
  402a46:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402a4a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  402a4e:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  402a52:	8b 55 fc             	mov    -0x4(%rbp),%edx
  402a55:	48 63 ca             	movslq %edx,%rcx
  402a58:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  402a5c:	48 01 ca             	add    %rcx,%rdx
  402a5f:	0f b6 12             	movzbl (%rdx),%edx
  402a62:	88 10                	mov    %dl,(%rax)
	////printf("In strcpy\n");
	int i, len=strlen(src);
	//printf("In strlen.... length of src %d\n",len);
	char* ptr=dst;

	for(i=0; i<=len; i++)
  402a64:	ff 45 fc             	incl   -0x4(%rbp)
  402a67:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402a6a:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  402a6d:	7e d7                	jle    402a46 <strcpy+0x30>
	{
		*ptr++ = src[i];
	}
	return dst;
  402a6f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
}
  402a73:	c9                   	leaveq 
  402a74:	c3                   	retq   

0000000000402a75 <strcmp>:


int strcmp(const char *str1, const char *str2)
{
  402a75:	55                   	push   %rbp
  402a76:	48 89 e5             	mov    %rsp,%rbp
  402a79:	48 83 ec 10          	sub    $0x10,%rsp
  402a7d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  402a81:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)

	while(1)
	{
		////printf("In strcmp\n");

		if(*str1 != *str2)
  402a85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402a89:	0f b6 10             	movzbl (%rax),%edx
  402a8c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402a90:	0f b6 00             	movzbl (%rax),%eax
  402a93:	38 c2                	cmp    %al,%dl
  402a95:	74 1a                	je     402ab1 <strcmp+0x3c>
			return (*str1 - *str2);
  402a97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402a9b:	0f b6 00             	movzbl (%rax),%eax
  402a9e:	0f be d0             	movsbl %al,%edx
  402aa1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402aa5:	0f b6 00             	movzbl (%rax),%eax
  402aa8:	0f be c0             	movsbl %al,%eax
  402aab:	29 c2                	sub    %eax,%edx
  402aad:	89 d0                	mov    %edx,%eax
  402aaf:	eb 49                	jmp    402afa <strcmp+0x85>

		else if((*str1 == *str2) && (*(str1+1) == *(str2 + 1)) && (*(str1 + 1) == '\0'))
  402ab1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402ab5:	0f b6 10             	movzbl (%rax),%edx
  402ab8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402abc:	0f b6 00             	movzbl (%rax),%eax
  402abf:	38 c2                	cmp    %al,%dl
  402ac1:	75 2d                	jne    402af0 <strcmp+0x7b>
  402ac3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402ac7:	48 ff c0             	inc    %rax
  402aca:	0f b6 10             	movzbl (%rax),%edx
  402acd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402ad1:	48 ff c0             	inc    %rax
  402ad4:	0f b6 00             	movzbl (%rax),%eax
  402ad7:	38 c2                	cmp    %al,%dl
  402ad9:	75 15                	jne    402af0 <strcmp+0x7b>
  402adb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402adf:	48 ff c0             	inc    %rax
  402ae2:	0f b6 00             	movzbl (%rax),%eax
  402ae5:	84 c0                	test   %al,%al
  402ae7:	75 07                	jne    402af0 <strcmp+0x7b>
			return 0;
  402ae9:	b8 00 00 00 00       	mov    $0x0,%eax
  402aee:	eb 0a                	jmp    402afa <strcmp+0x85>


		str1++;
  402af0:	48 ff 45 f8          	incq   -0x8(%rbp)
		str2++;
  402af4:	48 ff 45 f0          	incq   -0x10(%rbp)

	}
  402af8:	eb 8b                	jmp    402a85 <strcmp+0x10>

	return 0;
}
  402afa:	c9                   	leaveq 
  402afb:	c3                   	retq   

0000000000402afc <strstr>:

const char *strstr(const char *haystack, const char *needle)
{
  402afc:	55                   	push   %rbp
  402afd:	48 89 e5             	mov    %rsp,%rbp
  402b00:	48 83 ec 20          	sub    $0x20,%rsp
  402b04:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402b08:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	//printf("In strstrt\n %s %s\n\n", haystack,  needle);
	int len = strlen(haystack), i, j;
  402b0c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402b10:	48 89 c7             	mov    %rax,%rdi
  402b13:	e8 c9 fe ff ff       	callq  4029e1 <strlen>
  402b18:	89 45 f4             	mov    %eax,-0xc(%rbp)
	for(i=0; i< len; i++)
  402b1b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  402b22:	e9 a0 00 00 00       	jmpq   402bc7 <strstr+0xcb>
	{
		for(j = i; j< strlen(needle); j++)
  402b27:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402b2a:	89 45 f8             	mov    %eax,-0x8(%rbp)
  402b2d:	eb 31                	jmp    402b60 <strstr+0x64>
		{
			if(*(haystack+i+j) != *(needle+j))
  402b2f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402b32:	48 63 d0             	movslq %eax,%rdx
  402b35:	8b 45 f8             	mov    -0x8(%rbp),%eax
  402b38:	48 98                	cltq   
  402b3a:	48 01 c2             	add    %rax,%rdx
  402b3d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402b41:	48 01 d0             	add    %rdx,%rax
  402b44:	0f b6 10             	movzbl (%rax),%edx
  402b47:	8b 45 f8             	mov    -0x8(%rbp),%eax
  402b4a:	48 63 c8             	movslq %eax,%rcx
  402b4d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402b51:	48 01 c8             	add    %rcx,%rax
  402b54:	0f b6 00             	movzbl (%rax),%eax
  402b57:	38 c2                	cmp    %al,%dl
  402b59:	74 02                	je     402b5d <strstr+0x61>
				break;
  402b5b:	eb 14                	jmp    402b71 <strstr+0x75>

	//printf("In strstrt\n %s %s\n\n", haystack,  needle);
	int len = strlen(haystack), i, j;
	for(i=0; i< len; i++)
	{
		for(j = i; j< strlen(needle); j++)
  402b5d:	ff 45 f8             	incl   -0x8(%rbp)
  402b60:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402b64:	48 89 c7             	mov    %rax,%rdi
  402b67:	e8 75 fe ff ff       	callq  4029e1 <strlen>
  402b6c:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  402b6f:	7f be                	jg     402b2f <strstr+0x33>
		{
			if(*(haystack+i+j) != *(needle+j))
				break;
		}	

		if( (j == strlen(needle) ) && (*(haystack+i+j-1) == *(needle+j-1)))
  402b71:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402b75:	48 89 c7             	mov    %rax,%rdi
  402b78:	e8 64 fe ff ff       	callq  4029e1 <strlen>
  402b7d:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  402b80:	75 42                	jne    402bc4 <strstr+0xc8>
  402b82:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402b85:	48 63 d0             	movslq %eax,%rdx
  402b88:	8b 45 f8             	mov    -0x8(%rbp),%eax
  402b8b:	48 98                	cltq   
  402b8d:	48 01 d0             	add    %rdx,%rax
  402b90:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  402b94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402b98:	48 01 d0             	add    %rdx,%rax
  402b9b:	0f b6 10             	movzbl (%rax),%edx
  402b9e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  402ba1:	48 98                	cltq   
  402ba3:	48 8d 48 ff          	lea    -0x1(%rax),%rcx
  402ba7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402bab:	48 01 c8             	add    %rcx,%rax
  402bae:	0f b6 00             	movzbl (%rax),%eax
  402bb1:	38 c2                	cmp    %al,%dl
  402bb3:	75 0f                	jne    402bc4 <strstr+0xc8>
		{
			return (haystack + i);
  402bb5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402bb8:	48 63 d0             	movslq %eax,%rdx
  402bbb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402bbf:	48 01 d0             	add    %rdx,%rax
  402bc2:	eb 14                	jmp    402bd8 <strstr+0xdc>
const char *strstr(const char *haystack, const char *needle)
{

	//printf("In strstrt\n %s %s\n\n", haystack,  needle);
	int len = strlen(haystack), i, j;
	for(i=0; i< len; i++)
  402bc4:	ff 45 fc             	incl   -0x4(%rbp)
  402bc7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402bca:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  402bcd:	0f 8c 54 ff ff ff    	jl     402b27 <strstr+0x2b>
		{
			return (haystack + i);
		}
	}

	return NULL;
  402bd3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  402bd8:	c9                   	leaveq 
  402bd9:	c3                   	retq   

0000000000402bda <strcat>:

char *strcat(char *dst, const char *src)
{
  402bda:	55                   	push   %rbp
  402bdb:	48 89 e5             	mov    %rsp,%rbp
  402bde:	48 83 ec 10          	sub    $0x10,%rsp
  402be2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  402be6:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	strcpy(&dst[strlen(dst)],src);
  402bea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402bee:	48 89 c7             	mov    %rax,%rdi
  402bf1:	e8 eb fd ff ff       	callq  4029e1 <strlen>
  402bf6:	48 63 d0             	movslq %eax,%rdx
  402bf9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402bfd:	48 01 c2             	add    %rax,%rdx
  402c00:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402c04:	48 89 c6             	mov    %rax,%rsi
  402c07:	48 89 d7             	mov    %rdx,%rdi
  402c0a:	e8 07 fe ff ff       	callq  402a16 <strcpy>
	//printf("after cat: %s\n\n\n",dst);
	return dst;
  402c0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  402c13:	c9                   	leaveq 
  402c14:	c3                   	retq   

0000000000402c15 <strerror>:

uint64_t strerror(int err)
{
  402c15:	55                   	push   %rbp
  402c16:	48 89 e5             	mov    %rsp,%rbp
  402c19:	48 83 ec 10          	sub    $0x10,%rsp
  402c1d:	89 7d fc             	mov    %edi,-0x4(%rbp)

	switch(err)
  402c20:	83 7d fc 24          	cmpl   $0x24,-0x4(%rbp)
  402c24:	0f 87 5a 03 00 00    	ja     402f84 <strerror+0x36f>
  402c2a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402c2d:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  402c34:	00 
  402c35:	48 8d 05 98 0f 00 00 	lea    0xf98(%rip),%rax        # 403bd4 <chdir+0x873>
  402c3c:	8b 04 02             	mov    (%rdx,%rax,1),%eax
  402c3f:	48 63 d0             	movslq %eax,%rdx
  402c42:	48 8d 05 8b 0f 00 00 	lea    0xf8b(%rip),%rax        # 403bd4 <chdir+0x873>
  402c49:	48 01 d0             	add    %rdx,%rax
  402c4c:	ff e0                	jmpq   *%rax
	{

	case EPERM    : {return  printf("Operation not permitted \n");break;}
  402c4e:	48 8d 3d 9b 0c 00 00 	lea    0xc9b(%rip),%rdi        # 4038f0 <chdir+0x58f>
  402c55:	b8 00 00 00 00       	mov    $0x0,%eax
  402c5a:	e8 ac f6 ff ff       	callq  40230b <printf>
  402c5f:	48 98                	cltq   
  402c61:	e9 23 03 00 00       	jmpq   402f89 <strerror+0x374>
	case ENOENT   : {return  printf("No such file or directory \n");break;}
  402c66:	48 8d 3d 9d 0c 00 00 	lea    0xc9d(%rip),%rdi        # 40390a <chdir+0x5a9>
  402c6d:	b8 00 00 00 00       	mov    $0x0,%eax
  402c72:	e8 94 f6 ff ff       	callq  40230b <printf>
  402c77:	48 98                	cltq   
  402c79:	e9 0b 03 00 00       	jmpq   402f89 <strerror+0x374>
	case ESRCH    : {return  printf("No such process \n");;break;}
  402c7e:	48 8d 3d a1 0c 00 00 	lea    0xca1(%rip),%rdi        # 403926 <chdir+0x5c5>
  402c85:	b8 00 00 00 00       	mov    $0x0,%eax
  402c8a:	e8 7c f6 ff ff       	callq  40230b <printf>
  402c8f:	48 98                	cltq   
  402c91:	e9 f3 02 00 00       	jmpq   402f89 <strerror+0x374>
	case EINTR    : {return  printf("Interrupted system call \n");break;}
  402c96:	48 8d 3d 9b 0c 00 00 	lea    0xc9b(%rip),%rdi        # 403938 <chdir+0x5d7>
  402c9d:	b8 00 00 00 00       	mov    $0x0,%eax
  402ca2:	e8 64 f6 ff ff       	callq  40230b <printf>
  402ca7:	48 98                	cltq   
  402ca9:	e9 db 02 00 00       	jmpq   402f89 <strerror+0x374>
	case EIO      : {return  printf("error \n");;break;}
  402cae:	48 8d 3d 9d 0c 00 00 	lea    0xc9d(%rip),%rdi        # 403952 <chdir+0x5f1>
  402cb5:	b8 00 00 00 00       	mov    $0x0,%eax
  402cba:	e8 4c f6 ff ff       	callq  40230b <printf>
  402cbf:	48 98                	cltq   
  402cc1:	e9 c3 02 00 00       	jmpq   402f89 <strerror+0x374>
	case ENXIO    : {return  printf("No such device or address \n");break;}
  402cc6:	48 8d 3d 8d 0c 00 00 	lea    0xc8d(%rip),%rdi        # 40395a <chdir+0x5f9>
  402ccd:	b8 00 00 00 00       	mov    $0x0,%eax
  402cd2:	e8 34 f6 ff ff       	callq  40230b <printf>
  402cd7:	48 98                	cltq   
  402cd9:	e9 ab 02 00 00       	jmpq   402f89 <strerror+0x374>
	case E2BIG    : {return  printf("Argument list too long \n");break;}
  402cde:	48 8d 3d 91 0c 00 00 	lea    0xc91(%rip),%rdi        # 403976 <chdir+0x615>
  402ce5:	b8 00 00 00 00       	mov    $0x0,%eax
  402cea:	e8 1c f6 ff ff       	callq  40230b <printf>
  402cef:	48 98                	cltq   
  402cf1:	e9 93 02 00 00       	jmpq   402f89 <strerror+0x374>
	case ENOEXEC  : {return  printf("Exec format error \n");break;}
  402cf6:	48 8d 3d 92 0c 00 00 	lea    0xc92(%rip),%rdi        # 40398f <chdir+0x62e>
  402cfd:	b8 00 00 00 00       	mov    $0x0,%eax
  402d02:	e8 04 f6 ff ff       	callq  40230b <printf>
  402d07:	48 98                	cltq   
  402d09:	e9 7b 02 00 00       	jmpq   402f89 <strerror+0x374>
	case EBADF    : {return  printf("Bad file number \n");break;}
  402d0e:	48 8d 3d 8e 0c 00 00 	lea    0xc8e(%rip),%rdi        # 4039a3 <chdir+0x642>
  402d15:	b8 00 00 00 00       	mov    $0x0,%eax
  402d1a:	e8 ec f5 ff ff       	callq  40230b <printf>
  402d1f:	48 98                	cltq   
  402d21:	e9 63 02 00 00       	jmpq   402f89 <strerror+0x374>
	case ECHILD   : {return  printf("No child processes \n");break;}
  402d26:	48 8d 3d 88 0c 00 00 	lea    0xc88(%rip),%rdi        # 4039b5 <chdir+0x654>
  402d2d:	b8 00 00 00 00       	mov    $0x0,%eax
  402d32:	e8 d4 f5 ff ff       	callq  40230b <printf>
  402d37:	48 98                	cltq   
  402d39:	e9 4b 02 00 00       	jmpq   402f89 <strerror+0x374>
	case EAGAIN   : {return  printf("Try again \n");;break;}
  402d3e:	48 8d 3d 85 0c 00 00 	lea    0xc85(%rip),%rdi        # 4039ca <chdir+0x669>
  402d45:	b8 00 00 00 00       	mov    $0x0,%eax
  402d4a:	e8 bc f5 ff ff       	callq  40230b <printf>
  402d4f:	48 98                	cltq   
  402d51:	e9 33 02 00 00       	jmpq   402f89 <strerror+0x374>
	case ENOMEM   : {return  printf("Out of memory \n");;break;}
  402d56:	48 8d 3d 79 0c 00 00 	lea    0xc79(%rip),%rdi        # 4039d6 <chdir+0x675>
  402d5d:	b8 00 00 00 00       	mov    $0x0,%eax
  402d62:	e8 a4 f5 ff ff       	callq  40230b <printf>
  402d67:	48 98                	cltq   
  402d69:	e9 1b 02 00 00       	jmpq   402f89 <strerror+0x374>
	case EACCES   : {return  printf("Permission denied \n");break;}
  402d6e:	48 8d 3d 71 0c 00 00 	lea    0xc71(%rip),%rdi        # 4039e6 <chdir+0x685>
  402d75:	b8 00 00 00 00       	mov    $0x0,%eax
  402d7a:	e8 8c f5 ff ff       	callq  40230b <printf>
  402d7f:	48 98                	cltq   
  402d81:	e9 03 02 00 00       	jmpq   402f89 <strerror+0x374>
	case EFAULT   : {return  printf("Bad address \n");;break;}
  402d86:	48 8d 3d 6d 0c 00 00 	lea    0xc6d(%rip),%rdi        # 4039fa <chdir+0x699>
  402d8d:	b8 00 00 00 00       	mov    $0x0,%eax
  402d92:	e8 74 f5 ff ff       	callq  40230b <printf>
  402d97:	48 98                	cltq   
  402d99:	e9 eb 01 00 00       	jmpq   402f89 <strerror+0x374>
	case ENOTBLK  : {return  printf("Block device required \n");break;}
  402d9e:	48 8d 3d 63 0c 00 00 	lea    0xc63(%rip),%rdi        # 403a08 <chdir+0x6a7>
  402da5:	b8 00 00 00 00       	mov    $0x0,%eax
  402daa:	e8 5c f5 ff ff       	callq  40230b <printf>
  402daf:	48 98                	cltq   
  402db1:	e9 d3 01 00 00       	jmpq   402f89 <strerror+0x374>
	case EBUSY    : {return  printf("Device or resource busy \n");break;}
  402db6:	48 8d 3d 63 0c 00 00 	lea    0xc63(%rip),%rdi        # 403a20 <chdir+0x6bf>
  402dbd:	b8 00 00 00 00       	mov    $0x0,%eax
  402dc2:	e8 44 f5 ff ff       	callq  40230b <printf>
  402dc7:	48 98                	cltq   
  402dc9:	e9 bb 01 00 00       	jmpq   402f89 <strerror+0x374>
	case EEXIST   : {return  printf("File exists \n");;break;}
  402dce:	48 8d 3d 65 0c 00 00 	lea    0xc65(%rip),%rdi        # 403a3a <chdir+0x6d9>
  402dd5:	b8 00 00 00 00       	mov    $0x0,%eax
  402dda:	e8 2c f5 ff ff       	callq  40230b <printf>
  402ddf:	48 98                	cltq   
  402de1:	e9 a3 01 00 00       	jmpq   402f89 <strerror+0x374>
	case EXDEV    : {return  printf("Cross-device link \n");break;}
  402de6:	48 8d 3d 5b 0c 00 00 	lea    0xc5b(%rip),%rdi        # 403a48 <chdir+0x6e7>
  402ded:	b8 00 00 00 00       	mov    $0x0,%eax
  402df2:	e8 14 f5 ff ff       	callq  40230b <printf>
  402df7:	48 98                	cltq   
  402df9:	e9 8b 01 00 00       	jmpq   402f89 <strerror+0x374>
	case ENODEV   : {return  printf("No such device \n");break;}
  402dfe:	48 8d 3d 57 0c 00 00 	lea    0xc57(%rip),%rdi        # 403a5c <chdir+0x6fb>
  402e05:	b8 00 00 00 00       	mov    $0x0,%eax
  402e0a:	e8 fc f4 ff ff       	callq  40230b <printf>
  402e0f:	48 98                	cltq   
  402e11:	e9 73 01 00 00       	jmpq   402f89 <strerror+0x374>
	case ENOTDIR  : {return  printf("Not a directory \n");break;}
  402e16:	48 8d 3d 50 0c 00 00 	lea    0xc50(%rip),%rdi        # 403a6d <chdir+0x70c>
  402e1d:	b8 00 00 00 00       	mov    $0x0,%eax
  402e22:	e8 e4 f4 ff ff       	callq  40230b <printf>
  402e27:	48 98                	cltq   
  402e29:	e9 5b 01 00 00       	jmpq   402f89 <strerror+0x374>
	case EISDIR   : {return  printf("Is a directory \n");break;}
  402e2e:	48 8d 3d 4a 0c 00 00 	lea    0xc4a(%rip),%rdi        # 403a7f <chdir+0x71e>
  402e35:	b8 00 00 00 00       	mov    $0x0,%eax
  402e3a:	e8 cc f4 ff ff       	callq  40230b <printf>
  402e3f:	48 98                	cltq   
  402e41:	e9 43 01 00 00       	jmpq   402f89 <strerror+0x374>
	case EINVAL   : {return  printf("Invalid argument \n");break;}
  402e46:	48 8d 3d 43 0c 00 00 	lea    0xc43(%rip),%rdi        # 403a90 <chdir+0x72f>
  402e4d:	b8 00 00 00 00       	mov    $0x0,%eax
  402e52:	e8 b4 f4 ff ff       	callq  40230b <printf>
  402e57:	48 98                	cltq   
  402e59:	e9 2b 01 00 00       	jmpq   402f89 <strerror+0x374>
	case ENFILE   : {return  printf("File table overflow \n");break;}
  402e5e:	48 8d 3d 3e 0c 00 00 	lea    0xc3e(%rip),%rdi        # 403aa3 <chdir+0x742>
  402e65:	b8 00 00 00 00       	mov    $0x0,%eax
  402e6a:	e8 9c f4 ff ff       	callq  40230b <printf>
  402e6f:	48 98                	cltq   
  402e71:	e9 13 01 00 00       	jmpq   402f89 <strerror+0x374>
	case EMFILE   : {return  printf("Too many open files \n");break;}
  402e76:	48 8d 3d 3c 0c 00 00 	lea    0xc3c(%rip),%rdi        # 403ab9 <chdir+0x758>
  402e7d:	b8 00 00 00 00       	mov    $0x0,%eax
  402e82:	e8 84 f4 ff ff       	callq  40230b <printf>
  402e87:	48 98                	cltq   
  402e89:	e9 fb 00 00 00       	jmpq   402f89 <strerror+0x374>
	case ENOTTY   : {return  printf("Not a typewriter \n");break;}
  402e8e:	48 8d 3d 3a 0c 00 00 	lea    0xc3a(%rip),%rdi        # 403acf <chdir+0x76e>
  402e95:	b8 00 00 00 00       	mov    $0x0,%eax
  402e9a:	e8 6c f4 ff ff       	callq  40230b <printf>
  402e9f:	48 98                	cltq   
  402ea1:	e9 e3 00 00 00       	jmpq   402f89 <strerror+0x374>
	case ETXTBSY  : {return  printf("Text file busy \n");break;}
  402ea6:	48 8d 3d 35 0c 00 00 	lea    0xc35(%rip),%rdi        # 403ae2 <chdir+0x781>
  402ead:	b8 00 00 00 00       	mov    $0x0,%eax
  402eb2:	e8 54 f4 ff ff       	callq  40230b <printf>
  402eb7:	48 98                	cltq   
  402eb9:	e9 cb 00 00 00       	jmpq   402f89 <strerror+0x374>
	case EFBIG    : {return  printf("File too large \n");break;}
  402ebe:	48 8d 3d 2e 0c 00 00 	lea    0xc2e(%rip),%rdi        # 403af3 <chdir+0x792>
  402ec5:	b8 00 00 00 00       	mov    $0x0,%eax
  402eca:	e8 3c f4 ff ff       	callq  40230b <printf>
  402ecf:	48 98                	cltq   
  402ed1:	e9 b3 00 00 00       	jmpq   402f89 <strerror+0x374>
	case ENOSPC   : {return  printf("No space left on device \n");break;}
  402ed6:	48 8d 3d 27 0c 00 00 	lea    0xc27(%rip),%rdi        # 403b04 <chdir+0x7a3>
  402edd:	b8 00 00 00 00       	mov    $0x0,%eax
  402ee2:	e8 24 f4 ff ff       	callq  40230b <printf>
  402ee7:	48 98                	cltq   
  402ee9:	e9 9b 00 00 00       	jmpq   402f89 <strerror+0x374>
	case ESPIPE   : {return  printf("Illegal seek \n");break;}
  402eee:	48 8d 3d 29 0c 00 00 	lea    0xc29(%rip),%rdi        # 403b1e <chdir+0x7bd>
  402ef5:	b8 00 00 00 00       	mov    $0x0,%eax
  402efa:	e8 0c f4 ff ff       	callq  40230b <printf>
  402eff:	48 98                	cltq   
  402f01:	e9 83 00 00 00       	jmpq   402f89 <strerror+0x374>
	case EROFS    : {return  printf("Read-only file system \n");break;}
  402f06:	48 8d 3d 20 0c 00 00 	lea    0xc20(%rip),%rdi        # 403b2d <chdir+0x7cc>
  402f0d:	b8 00 00 00 00       	mov    $0x0,%eax
  402f12:	e8 f4 f3 ff ff       	callq  40230b <printf>
  402f17:	48 98                	cltq   
  402f19:	eb 6e                	jmp    402f89 <strerror+0x374>
	case EMLINK   : {return  printf("Too many links \n");break;}
  402f1b:	48 8d 3d 23 0c 00 00 	lea    0xc23(%rip),%rdi        # 403b45 <chdir+0x7e4>
  402f22:	b8 00 00 00 00       	mov    $0x0,%eax
  402f27:	e8 df f3 ff ff       	callq  40230b <printf>
  402f2c:	48 98                	cltq   
  402f2e:	eb 59                	jmp    402f89 <strerror+0x374>
	case EPIPE    : {return  printf("Broken pipe \n");break;}
  402f30:	48 8d 3d 1f 0c 00 00 	lea    0xc1f(%rip),%rdi        # 403b56 <chdir+0x7f5>
  402f37:	b8 00 00 00 00       	mov    $0x0,%eax
  402f3c:	e8 ca f3 ff ff       	callq  40230b <printf>
  402f41:	48 98                	cltq   
  402f43:	eb 44                	jmp    402f89 <strerror+0x374>
	case EDOM     : {return  printf("Math argument out of domain of func \n");break;}
  402f45:	48 8d 3d 1c 0c 00 00 	lea    0xc1c(%rip),%rdi        # 403b68 <chdir+0x807>
  402f4c:	b8 00 00 00 00       	mov    $0x0,%eax
  402f51:	e8 b5 f3 ff ff       	callq  40230b <printf>
  402f56:	48 98                	cltq   
  402f58:	eb 2f                	jmp    402f89 <strerror+0x374>
	case ERANGE   : {return  printf("Math result not representable \n");break;}
  402f5a:	48 8d 3d 2f 0c 00 00 	lea    0xc2f(%rip),%rdi        # 403b90 <chdir+0x82f>
  402f61:	b8 00 00 00 00       	mov    $0x0,%eax
  402f66:	e8 a0 f3 ff ff       	callq  40230b <printf>
  402f6b:	48 98                	cltq   
  402f6d:	eb 1a                	jmp    402f89 <strerror+0x374>
	case ENAMETOOLONG:	{return printf(" The path is too long to search \n");break;}
  402f6f:	48 8d 3d 3a 0c 00 00 	lea    0xc3a(%rip),%rdi        # 403bb0 <chdir+0x84f>
  402f76:	b8 00 00 00 00       	mov    $0x0,%eax
  402f7b:	e8 8b f3 ff ff       	callq  40230b <printf>
  402f80:	48 98                	cltq   
  402f82:	eb 05                	jmp    402f89 <strerror+0x374>
	
	//return printf("error occured.\n");
	}
return 0;
  402f84:	b8 00 00 00 00       	mov    $0x0,%eax
  402f89:	c9                   	leaveq 
  402f8a:	c3                   	retq   

0000000000402f8b <syscall_1>:
			:"=r"(ret):"m"(n));

	return ret;
}

static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
  402f8b:	55                   	push   %rbp
  402f8c:	48 89 e5             	mov    %rsp,%rbp
  402f8f:	48 83 ec 20          	sub    $0x20,%rsp
  402f93:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402f97:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int64_t ret;

	__asm__("movq $78,%r15");
  402f9b:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
	//__asm__("movq %0,%%rax;"
	//		::"m"(n));

	//while(1);

	if(n==60){
  402fa2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402fa6:	48 83 f8 3c          	cmp    $0x3c,%rax
  402faa:	75 0c                	jne    402fb8 <syscall_1+0x2d>
		__asm__("movq %0,%%rax;"
  402fac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402fb0:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402fb4:	cd 80                	int    $0x80
  402fb6:	eb 11                	jmp    402fc9 <syscall_1+0x3e>

		//while(1);
	}
	else{

		__asm__("movq %1,%%rax;"
  402fb8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402fbc:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402fc0:	cd 80                	int    $0x80
  402fc2:	48 89 c0             	mov    %rax,%rax
  402fc5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				"movq %2,%%rdi;"
				"int $0x80;"
				"movq %%rax,%0;"
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
  402fc9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  402fcd:	c9                   	leaveq 
  402fce:	c3                   	retq   

0000000000402fcf <make_head>:

enum {NEW_MCB, NO_MCB, REUSE_MCB};
enum {FREE, IN_USE};

void make_head(char *addr, int size) 
{
  402fcf:	55                   	push   %rbp
  402fd0:	48 89 e5             	mov    %rsp,%rbp
  402fd3:	48 83 ec 1c          	sub    $0x1c,%rsp
  402fd7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402fdb:	89 75 e4             	mov    %esi,-0x1c(%rbp)
    MCB_P head         = (MCB_P)addr;
  402fde:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402fe2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    head->is_available = FREE;
  402fe6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402fea:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
    head->size         = size;
  402ff0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402ff4:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  402ff7:	89 50 04             	mov    %edx,0x4(%rax)
}
  402ffa:	c9                   	leaveq 
  402ffb:	c3                   	retq   

0000000000402ffc <alloc_new>:

void *alloc_new(int aligned_size)
{
  402ffc:	55                   	push   %rbp
  402ffd:	48 89 e5             	mov    %rsp,%rbp
  403000:	48 83 ec 30          	sub    $0x30,%rsp
  403004:	89 7d dc             	mov    %edi,-0x24(%rbp)
    char *add;
    uint64_t no_of_pages = 0, sz;    
  403007:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  40300e:	00 
    MCB_P p_mcb;
    
    sz          = sizeof(MCB_t);
  40300f:	48 c7 45 f0 08 00 00 	movq   $0x8,-0x10(%rbp)
  403016:	00 
    no_of_pages = (aligned_size + sz) /(PAGESIZE + 1) + 1;
  403017:	8b 45 dc             	mov    -0x24(%rbp),%eax
  40301a:	48 63 d0             	movslq %eax,%rdx
  40301d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  403021:	48 01 d0             	add    %rdx,%rax
  403024:	48 ba f1 ff 00 f0 ff 	movabs $0xfff000fff000fff1,%rdx
  40302b:	00 f0 ff 
  40302e:	48 f7 e2             	mul    %rdx
  403031:	48 89 d0             	mov    %rdx,%rax
  403034:	48 c1 e8 0c          	shr    $0xc,%rax
  403038:	48 ff c0             	inc    %rax
  40303b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    add = (char*)syscall_1(SYS_brk, (uint64_t)no_of_pages*4096);    
  40303f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  403043:	48 c1 e0 0c          	shl    $0xc,%rax
  403047:	48 89 c6             	mov    %rax,%rsi
  40304a:	bf 0c 00 00 00       	mov    $0xc,%edi
  40304f:	e8 37 ff ff ff       	callq  402f8b <syscall_1>
  403054:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    if (heap_end == 0) {
  403058:	48 8b 05 11 16 20 00 	mov    0x201611(%rip),%rax        # 604670 <heap_end>
  40305f:	48 85 c0             	test   %rax,%rax
  403062:	75 2a                	jne    40308e <alloc_new+0x92>
        mem_start_p   = add;
  403064:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403068:	48 89 05 f9 15 20 00 	mov    %rax,0x2015f9(%rip)        # 604668 <mem_start_p>
        mcb_count     = 0;
  40306f:	c7 05 07 16 20 00 00 	movl   $0x0,0x201607(%rip)        # 604680 <mcb_count>
  403076:	00 00 00 
        allocated_mem = 0;
  403079:	c7 05 f9 15 20 00 00 	movl   $0x0,0x2015f9(%rip)        # 60467c <allocated_mem>
  403080:	00 00 00 
        heap_end = add; 
  403083:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403087:	48 89 05 e2 15 20 00 	mov    %rax,0x2015e2(%rip)        # 604670 <heap_end>
    }
    
    heap_end = (char*)((uint64_t)add + (uint64_t)(PAGESIZE * no_of_pages));
  40308e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  403092:	48 c1 e0 0c          	shl    $0xc,%rax
  403096:	48 89 c2             	mov    %rax,%rdx
  403099:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40309d:	48 01 d0             	add    %rdx,%rax
  4030a0:	48 89 05 c9 15 20 00 	mov    %rax,0x2015c9(%rip)        # 604670 <heap_end>
    max_mem += PAGESIZE * no_of_pages; 
  4030a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4030ab:	c1 e0 0c             	shl    $0xc,%eax
  4030ae:	89 c2                	mov    %eax,%edx
  4030b0:	8b 05 c2 15 20 00    	mov    0x2015c2(%rip),%eax        # 604678 <max_mem>
  4030b6:	01 d0                	add    %edx,%eax
  4030b8:	89 05 ba 15 20 00    	mov    %eax,0x2015ba(%rip)        # 604678 <max_mem>
    
    p_mcb               = (MCB_P)add; 
  4030be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4030c2:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    p_mcb->is_available = IN_USE;
  4030c6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4030ca:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    p_mcb->size         = aligned_size + sz; 
  4030d0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4030d4:	89 c2                	mov    %eax,%edx
  4030d6:	8b 45 dc             	mov    -0x24(%rbp),%eax
  4030d9:	01 d0                	add    %edx,%eax
  4030db:	89 c2                	mov    %eax,%edx
  4030dd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4030e1:	89 50 04             	mov    %edx,0x4(%rax)
    mcb_count++;    
  4030e4:	8b 05 96 15 20 00    	mov    0x201596(%rip),%eax        # 604680 <mcb_count>
  4030ea:	ff c0                	inc    %eax
  4030ec:	89 05 8e 15 20 00    	mov    %eax,0x20158e(%rip)        # 604680 <mcb_count>

    if (PAGESIZE * no_of_pages > aligned_size + sz) {
  4030f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4030f6:	48 c1 e0 0c          	shl    $0xc,%rax
  4030fa:	48 89 c1             	mov    %rax,%rcx
  4030fd:	8b 45 dc             	mov    -0x24(%rbp),%eax
  403100:	48 63 d0             	movslq %eax,%rdx
  403103:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  403107:	48 01 d0             	add    %rdx,%rax
  40310a:	48 39 c1             	cmp    %rax,%rcx
  40310d:	76 34                	jbe    403143 <alloc_new+0x147>
        make_head(((char *)p_mcb + aligned_size + sz), (PAGESIZE * no_of_pages - aligned_size - sz));
  40310f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  403113:	c1 e0 0c             	shl    $0xc,%eax
  403116:	89 c2                	mov    %eax,%edx
  403118:	8b 45 dc             	mov    -0x24(%rbp),%eax
  40311b:	29 c2                	sub    %eax,%edx
  40311d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  403121:	29 c2                	sub    %eax,%edx
  403123:	89 d0                	mov    %edx,%eax
  403125:	8b 55 dc             	mov    -0x24(%rbp),%edx
  403128:	48 63 ca             	movslq %edx,%rcx
  40312b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  40312f:	48 01 d1             	add    %rdx,%rcx
  403132:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  403136:	48 01 ca             	add    %rcx,%rdx
  403139:	89 c6                	mov    %eax,%esi
  40313b:	48 89 d7             	mov    %rdx,%rdi
  40313e:	e8 8c fe ff ff       	callq  402fcf <make_head>
    }

    allocated_mem += aligned_size; 
  403143:	8b 15 33 15 20 00    	mov    0x201533(%rip),%edx        # 60467c <allocated_mem>
  403149:	8b 45 dc             	mov    -0x24(%rbp),%eax
  40314c:	01 d0                	add    %edx,%eax
  40314e:	89 05 28 15 20 00    	mov    %eax,0x201528(%rip)        # 60467c <allocated_mem>
    
    return ((void *) p_mcb + sz);
  403154:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  403158:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  40315c:	48 01 d0             	add    %rdx,%rax
}
  40315f:	c9                   	leaveq 
  403160:	c3                   	retq   

0000000000403161 <malloc>:

void* malloc(size_t elem_size)
{
  403161:	55                   	push   %rbp
  403162:	48 89 e5             	mov    %rsp,%rbp
  403165:	48 83 ec 30          	sub    $0x30,%rsp
  403169:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    MCB_P p_mcb;
    int flag, sz, temp = 0, aligned_size;
  40316d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)

    // Align elem_size to header size
    aligned_size = ((((elem_size - 1) >> 3) + 1) << 3);
  403174:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403178:	48 ff c8             	dec    %rax
  40317b:	48 c1 e8 03          	shr    $0x3,%rax
  40317f:	48 ff c0             	inc    %rax
  403182:	48 c1 e0 03          	shl    $0x3,%rax
  403186:	89 45 ec             	mov    %eax,-0x14(%rbp)
    heap_end=heap_end;
  403189:	48 8b 05 e0 14 20 00 	mov    0x2014e0(%rip),%rax        # 604670 <heap_end>
  403190:	48 89 05 d9 14 20 00 	mov    %rax,0x2014d9(%rip)        # 604670 <heap_end>
    if (heap_end == 0) {
  403197:	48 8b 05 d2 14 20 00 	mov    0x2014d2(%rip),%rax        # 604670 <heap_end>
  40319e:	48 85 c0             	test   %rax,%rax
  4031a1:	75 0f                	jne    4031b2 <malloc+0x51>
        /*no heap has been assigned yet*/
        return alloc_new(aligned_size);
  4031a3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  4031a6:	89 c7                	mov    %eax,%edi
  4031a8:	e8 4f fe ff ff       	callq  402ffc <alloc_new>
  4031ad:	e9 1a 01 00 00       	jmpq   4032cc <malloc+0x16b>
    } else {

        flag  = NO_MCB;
  4031b2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
        p_mcb = (MCB_P)mem_start_p;
  4031b9:	48 8b 05 a8 14 20 00 	mov    0x2014a8(%rip),%rax        # 604668 <mem_start_p>
  4031c0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        sz    = sizeof(MCB_t);
  4031c4:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%rbp)

        //printf("\nheap_end : %p\treqd size: %p",heap_end, ((char *)p_mcb + aligned_size + sz));
        while (heap_end >= ((char *)p_mcb + aligned_size + sz)) {
  4031cb:	eb 33                	jmp    403200 <malloc+0x9f>
            if (p_mcb->is_available == FREE) {
  4031cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4031d1:	8b 00                	mov    (%rax),%eax
  4031d3:	85 c0                	test   %eax,%eax
  4031d5:	75 1c                	jne    4031f3 <malloc+0x92>
                if (p_mcb->size >= (aligned_size + sz)) {
  4031d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4031db:	8b 40 04             	mov    0x4(%rax),%eax
  4031de:	8b 55 e8             	mov    -0x18(%rbp),%edx
  4031e1:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  4031e4:	01 ca                	add    %ecx,%edx
  4031e6:	39 d0                	cmp    %edx,%eax
  4031e8:	7c 09                	jl     4031f3 <malloc+0x92>
                    flag = REUSE_MCB;
  4031ea:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%rbp)
                    break;
  4031f1:	eb 2e                	jmp    403221 <malloc+0xc0>
                }
            }
            p_mcb = (MCB_P) ((char *)p_mcb + p_mcb->size);
  4031f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4031f7:	8b 40 04             	mov    0x4(%rax),%eax
  4031fa:	48 98                	cltq   
  4031fc:	48 01 45 f8          	add    %rax,-0x8(%rbp)
        flag  = NO_MCB;
        p_mcb = (MCB_P)mem_start_p;
        sz    = sizeof(MCB_t);

        //printf("\nheap_end : %p\treqd size: %p",heap_end, ((char *)p_mcb + aligned_size + sz));
        while (heap_end >= ((char *)p_mcb + aligned_size + sz)) {
  403200:	8b 45 ec             	mov    -0x14(%rbp),%eax
  403203:	48 63 d0             	movslq %eax,%rdx
  403206:	8b 45 e8             	mov    -0x18(%rbp),%eax
  403209:	48 98                	cltq   
  40320b:	48 01 c2             	add    %rax,%rdx
  40320e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  403212:	48 01 c2             	add    %rax,%rdx
  403215:	48 8b 05 54 14 20 00 	mov    0x201454(%rip),%rax        # 604670 <heap_end>
  40321c:	48 39 c2             	cmp    %rax,%rdx
  40321f:	76 ac                	jbe    4031cd <malloc+0x6c>
                }
            }
            p_mcb = (MCB_P) ((char *)p_mcb + p_mcb->size);
        }

        if (flag != NO_MCB) {
  403221:	83 7d f4 01          	cmpl   $0x1,-0xc(%rbp)
  403225:	0f 84 97 00 00 00    	je     4032c2 <malloc+0x161>
            p_mcb->is_available = IN_USE;
  40322b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40322f:	c7 00 01 00 00 00    	movl   $0x1,(%rax)

            if (flag == REUSE_MCB) {
  403235:	83 7d f4 02          	cmpl   $0x2,-0xc(%rbp)
  403239:	75 67                	jne    4032a2 <malloc+0x141>
                if (p_mcb->size > aligned_size + sz) {
  40323b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40323f:	8b 40 04             	mov    0x4(%rax),%eax
  403242:	8b 55 e8             	mov    -0x18(%rbp),%edx
  403245:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  403248:	01 ca                	add    %ecx,%edx
  40324a:	39 d0                	cmp    %edx,%eax
  40324c:	7e 46                	jle    403294 <malloc+0x133>
                    temp        = p_mcb->size; 
  40324e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  403252:	8b 40 04             	mov    0x4(%rax),%eax
  403255:	89 45 f0             	mov    %eax,-0x10(%rbp)
                    p_mcb->size = aligned_size + sz;
  403258:	8b 45 e8             	mov    -0x18(%rbp),%eax
  40325b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  40325e:	01 c2                	add    %eax,%edx
  403260:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  403264:	89 50 04             	mov    %edx,0x4(%rax)

                    make_head(((char *)p_mcb + aligned_size + sz),(temp - aligned_size - sz));
  403267:	8b 45 ec             	mov    -0x14(%rbp),%eax
  40326a:	8b 55 f0             	mov    -0x10(%rbp),%edx
  40326d:	29 c2                	sub    %eax,%edx
  40326f:	89 d0                	mov    %edx,%eax
  403271:	2b 45 e8             	sub    -0x18(%rbp),%eax
  403274:	8b 55 ec             	mov    -0x14(%rbp),%edx
  403277:	48 63 ca             	movslq %edx,%rcx
  40327a:	8b 55 e8             	mov    -0x18(%rbp),%edx
  40327d:	48 63 d2             	movslq %edx,%rdx
  403280:	48 01 d1             	add    %rdx,%rcx
  403283:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  403287:	48 01 ca             	add    %rcx,%rdx
  40328a:	89 c6                	mov    %eax,%esi
  40328c:	48 89 d7             	mov    %rdx,%rdi
  40328f:	e8 3b fd ff ff       	callq  402fcf <make_head>
                }        
                mcb_count++;
  403294:	8b 05 e6 13 20 00    	mov    0x2013e6(%rip),%eax        # 604680 <mcb_count>
  40329a:	ff c0                	inc    %eax
  40329c:	89 05 de 13 20 00    	mov    %eax,0x2013de(%rip)        # 604680 <mcb_count>
            }
            allocated_mem += aligned_size;
  4032a2:	8b 15 d4 13 20 00    	mov    0x2013d4(%rip),%edx        # 60467c <allocated_mem>
  4032a8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  4032ab:	01 d0                	add    %edx,%eax
  4032ad:	89 05 c9 13 20 00    	mov    %eax,0x2013c9(%rip)        # 60467c <allocated_mem>
            return ((char *) p_mcb + sz);
  4032b3:	8b 45 e8             	mov    -0x18(%rbp),%eax
  4032b6:	48 63 d0             	movslq %eax,%rdx
  4032b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4032bd:	48 01 d0             	add    %rdx,%rax
  4032c0:	eb 0a                	jmp    4032cc <malloc+0x16b>
        }

        /*when no hole is found to match the request*/
        return alloc_new(aligned_size); 
  4032c2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  4032c5:	89 c7                	mov    %eax,%edi
  4032c7:	e8 30 fd ff ff       	callq  402ffc <alloc_new>
    }

}
  4032cc:	c9                   	leaveq 
  4032cd:	c3                   	retq   

00000000004032ce <free>:

void free(void *p)
{
  4032ce:	55                   	push   %rbp
  4032cf:	48 89 e5             	mov    %rsp,%rbp
  4032d2:	48 83 ec 18          	sub    $0x18,%rsp
  4032d6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    MCB_P ptr = (MCB_P)p;
  4032da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4032de:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    ptr--;
  4032e2:	48 83 6d f8 08       	subq   $0x8,-0x8(%rbp)

    mcb_count--;
  4032e7:	8b 05 93 13 20 00    	mov    0x201393(%rip),%eax        # 604680 <mcb_count>
  4032ed:	ff c8                	dec    %eax
  4032ef:	89 05 8b 13 20 00    	mov    %eax,0x20138b(%rip)        # 604680 <mcb_count>
    ptr->is_available = FREE;
  4032f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4032f9:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
    allocated_mem    -= (ptr->size - sizeof(MCB_t));
  4032ff:	8b 05 77 13 20 00    	mov    0x201377(%rip),%eax        # 60467c <allocated_mem>
  403305:	89 c2                	mov    %eax,%edx
  403307:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40330b:	8b 40 04             	mov    0x4(%rax),%eax
  40330e:	29 c2                	sub    %eax,%edx
  403310:	89 d0                	mov    %edx,%eax
  403312:	83 c0 08             	add    $0x8,%eax
  403315:	89 05 61 13 20 00    	mov    %eax,0x201361(%rip)        # 60467c <allocated_mem>

}
  40331b:	c9                   	leaveq 
  40331c:	c3                   	retq   

000000000040331d <syscall_1>:
			:"=r"(ret):"m"(n));

	return ret;
}

static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
  40331d:	55                   	push   %rbp
  40331e:	48 89 e5             	mov    %rsp,%rbp
  403321:	48 83 ec 20          	sub    $0x20,%rsp
  403325:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  403329:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int64_t ret;

	__asm__("movq $78,%r15");
  40332d:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
	//__asm__("movq %0,%%rax;"
	//		::"m"(n));

	//while(1);

	if(n==60){
  403334:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403338:	48 83 f8 3c          	cmp    $0x3c,%rax
  40333c:	75 0c                	jne    40334a <syscall_1+0x2d>
		__asm__("movq %0,%%rax;"
  40333e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403342:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  403346:	cd 80                	int    $0x80
  403348:	eb 11                	jmp    40335b <syscall_1+0x3e>

		//while(1);
	}
	else{

		__asm__("movq %1,%%rax;"
  40334a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40334e:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  403352:	cd 80                	int    $0x80
  403354:	48 89 c0             	mov    %rax,%rax
  403357:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				"movq %2,%%rdi;"
				"int $0x80;"
				"movq %%rax,%0;"
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
  40335b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  40335f:	c9                   	leaveq 
  403360:	c3                   	retq   

0000000000403361 <chdir>:
#include <sys/syscall.h>
#include <syscall.h>
#include <errno.h>
#include <stdlib.h>

int chdir(const char *path){
  403361:	55                   	push   %rbp
  403362:	48 89 e5             	mov    %rsp,%rbp
  403365:	48 83 ec 18          	sub    $0x18,%rsp
  403369:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	int retvalue;
	retvalue=syscall_1(SYS_chdir,(uint64_t)path);
  40336d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403371:	48 89 c6             	mov    %rax,%rsi
  403374:	bf 50 00 00 00       	mov    $0x50,%edi
  403379:	e8 9f ff ff ff       	callq  40331d <syscall_1>
  40337e:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(retvalue >=0){
  403381:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  403385:	78 05                	js     40338c <chdir+0x2b>
		return retvalue;
  403387:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40338a:	eb 05                	jmp    403391 <chdir+0x30>
	}
	return -1;
  40338c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
  403391:	c9                   	leaveq 
  403392:	c3                   	retq   
