
rootfs/bin/hello:     file format elf64-x86-64


Disassembly of section .text:

00000000004000e8 <_start>:
#include <stdlib.h>
#include <stdio.h>
int main(int argc, char* argv[], char* envp[]);

void _start(void) {
  4000e8:	55                   	push   %rbp
  4000e9:	48 89 e5             	mov    %rsp,%rbp
  4000ec:	48 83 ec 10          	sub    $0x10,%rsp
//	int argc = 1;
//	char* argv[0];
//	char* envp[0];
	int res;
//	res = main(0, NULL, NULL);
 volatile int x=89;
  4000f0:	c7 45 f8 59 00 00 00 	movl   $0x59,-0x8(%rbp)
  res=  main(*((uint64_t*)(&x+0x3UL)),(char**)(uint64_t*)(&x+0x5UL), (char **)((&x+5) +  (2*(*(&x+3)+ 1))));
  4000f7:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  4000fb:	48 83 c0 0c          	add    $0xc,%rax
  4000ff:	8b 00                	mov    (%rax),%eax
  400101:	ff c0                	inc    %eax
  400103:	48 98                	cltq   
  400105:	48 c1 e0 03          	shl    $0x3,%rax
  400109:	48 8d 50 14          	lea    0x14(%rax),%rdx
  40010d:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  400111:	48 01 c2             	add    %rax,%rdx
  400114:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  400118:	48 83 c0 0c          	add    $0xc,%rax
  40011c:	48 8b 00             	mov    (%rax),%rax
  40011f:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  400123:	48 83 c1 14          	add    $0x14,%rcx
  400127:	48 89 ce             	mov    %rcx,%rsi
  40012a:	89 c7                	mov    %eax,%edi
  40012c:	e8 fb 15 00 00       	callq  40172c <main>
  400131:	89 45 fc             	mov    %eax,-0x4(%rbp)

    exit(res);
  400134:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400137:	89 c7                	mov    %eax,%edi
  400139:	e8 78 28 00 00       	callq  4029b6 <exit>
  }
  40013e:	c9                   	leaveq 
  40013f:	c3                   	retq   

0000000000400140 <changedir>:
#include <errno.h>
#include <string.h>
#include <shell.h>


void changedir(char* path){
  400140:	55                   	push   %rbp
  400141:	48 89 e5             	mov    %rsp,%rbp
  400144:	48 81 ec 40 02 00 00 	sub    $0x240,%rsp
  40014b:	48 89 bd c8 fd ff ff 	mov    %rdi,-0x238(%rbp)

int pathLen = strlen(path);
  400152:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  400159:	48 89 c7             	mov    %rax,%rdi
  40015c:	e8 71 28 00 00       	callq  4029d2 <strlen>
  400161:	89 45 ec             	mov    %eax,-0x14(%rbp)

    int forward=0;
  400164:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    int back = 0;
  40016b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
    char temp[20];
    int i=0;
  400172:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    int x=0;
  400179:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
    int numOfComponents = 0;
  400180:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)

    char components[10][20];

    for(forward=0;forward<pathLen;){
  400187:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  40018e:	e9 1a 01 00 00       	jmpq   4002ad <changedir+0x16d>
        
        if(forward == 0 && path[forward] == '/'){
  400193:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  400197:	75 3b                	jne    4001d4 <changedir+0x94>
  400199:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40019c:	48 63 d0             	movslq %eax,%rdx
  40019f:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  4001a6:	48 01 d0             	add    %rdx,%rax
  4001a9:	0f b6 00             	movzbl (%rax),%eax
  4001ac:	3c 2f                	cmp    $0x2f,%al
  4001ae:	75 24                	jne    4001d4 <changedir+0x94>
            strcpy(components[0],"/");
  4001b0:	48 8d 85 08 ff ff ff 	lea    -0xf8(%rbp),%rax
  4001b7:	48 8d 35 e2 31 00 00 	lea    0x31e2(%rip),%rsi        # 4033a0 <chdir+0x36>
  4001be:	48 89 c7             	mov    %rax,%rdi
  4001c1:	e8 41 28 00 00       	callq  402a07 <strcpy>
            back++;
  4001c6:	ff 45 f8             	incl   -0x8(%rbp)
            forward++;
  4001c9:	ff 45 fc             	incl   -0x4(%rbp)
            numOfComponents++;
  4001cc:	ff 45 f0             	incl   -0x10(%rbp)
            continue;
  4001cf:	e9 d9 00 00 00       	jmpq   4002ad <changedir+0x16d>
        }

        if(path[forward] == '/'){
  4001d4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4001d7:	48 63 d0             	movslq %eax,%rdx
  4001da:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  4001e1:	48 01 d0             	add    %rdx,%rax
  4001e4:	0f b6 00             	movzbl (%rax),%eax
  4001e7:	3c 2f                	cmp    $0x2f,%al
  4001e9:	0f 85 bb 00 00 00    	jne    4002aa <changedir+0x16a>

            if(path[forward-1] == '/'){
  4001ef:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4001f2:	48 98                	cltq   
  4001f4:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  4001f8:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  4001ff:	48 01 d0             	add    %rdx,%rax
  400202:	0f b6 00             	movzbl (%rax),%eax
  400205:	3c 2f                	cmp    $0x2f,%al
  400207:	75 16                	jne    40021f <changedir+0xdf>
                printf("Malformed path\n");
  400209:	48 8d 3d 92 31 00 00 	lea    0x3192(%rip),%rdi        # 4033a2 <chdir+0x38>
  400210:	b8 00 00 00 00       	mov    $0x0,%eax
  400215:	e8 e2 20 00 00       	callq  4022fc <printf>
  40021a:	e9 4d 03 00 00       	jmpq   40056c <changedir+0x42c>
                return;
            }

            //copy from back till forward-1
            i=0;
  40021f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
            
            x = (forward-back);
  400226:	8b 45 f8             	mov    -0x8(%rbp),%eax
  400229:	8b 55 fc             	mov    -0x4(%rbp),%edx
  40022c:	29 c2                	sub    %eax,%edx
  40022e:	89 d0                	mov    %edx,%eax
  400230:	89 45 e8             	mov    %eax,-0x18(%rbp)
            while(i< x){
  400233:	eb 28                	jmp    40025d <changedir+0x11d>

                temp[i++] = path[back++];
  400235:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400238:	8d 50 01             	lea    0x1(%rax),%edx
  40023b:	89 55 f4             	mov    %edx,-0xc(%rbp)
  40023e:	8b 55 f8             	mov    -0x8(%rbp),%edx
  400241:	8d 4a 01             	lea    0x1(%rdx),%ecx
  400244:	89 4d f8             	mov    %ecx,-0x8(%rbp)
  400247:	48 63 ca             	movslq %edx,%rcx
  40024a:	48 8b 95 c8 fd ff ff 	mov    -0x238(%rbp),%rdx
  400251:	48 01 ca             	add    %rcx,%rdx
  400254:	0f b6 12             	movzbl (%rdx),%edx
  400257:	48 98                	cltq   
  400259:	88 54 05 d0          	mov    %dl,-0x30(%rbp,%rax,1)

            //copy from back till forward-1
            i=0;
            
            x = (forward-back);
            while(i< x){
  40025d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400260:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  400263:	7c d0                	jl     400235 <changedir+0xf5>

                temp[i++] = path[back++];
              
            }
            temp[i]= '\0';
  400265:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400268:	48 98                	cltq   
  40026a:	c6 44 05 d0 00       	movb   $0x0,-0x30(%rbp,%rax,1)
            //printf("%s\n", temp );
            
            strcpy(components[numOfComponents],temp);
  40026f:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
  400276:	8b 45 f0             	mov    -0x10(%rbp),%eax
  400279:	48 98                	cltq   
  40027b:	48 c1 e0 02          	shl    $0x2,%rax
  40027f:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  400286:	00 
  400287:	48 01 c8             	add    %rcx,%rax
  40028a:	48 01 c2             	add    %rax,%rdx
  40028d:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  400291:	48 89 c6             	mov    %rax,%rsi
  400294:	48 89 d7             	mov    %rdx,%rdi
  400297:	e8 6b 27 00 00       	callq  402a07 <strcpy>
            //printf("%s\n", &components[0] );
            forward++;
  40029c:	ff 45 fc             	incl   -0x4(%rbp)
            back = forward;
  40029f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4002a2:	89 45 f8             	mov    %eax,-0x8(%rbp)
            numOfComponents++;
  4002a5:	ff 45 f0             	incl   -0x10(%rbp)
            continue;
  4002a8:	eb 03                	jmp    4002ad <changedir+0x16d>

        }

        forward++;
  4002aa:	ff 45 fc             	incl   -0x4(%rbp)
    int x=0;
    int numOfComponents = 0;

    char components[10][20];

    for(forward=0;forward<pathLen;){
  4002ad:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4002b0:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  4002b3:	0f 8c da fe ff ff    	jl     400193 <changedir+0x53>

        forward++;

    } //End of for

    if(path[forward-1] != '/'){
  4002b9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4002bc:	48 98                	cltq   
  4002be:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  4002c2:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  4002c9:	48 01 d0             	add    %rdx,%rax
  4002cc:	0f b6 00             	movzbl (%rax),%eax
  4002cf:	3c 2f                	cmp    $0x2f,%al
  4002d1:	0f 84 83 00 00 00    	je     40035a <changedir+0x21a>

        i=0;
  4002d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
        x = forward-back;
  4002de:	8b 45 f8             	mov    -0x8(%rbp),%eax
  4002e1:	8b 55 fc             	mov    -0x4(%rbp),%edx
  4002e4:	29 c2                	sub    %eax,%edx
  4002e6:	89 d0                	mov    %edx,%eax
  4002e8:	89 45 e8             	mov    %eax,-0x18(%rbp)
        while(i<x){
  4002eb:	eb 28                	jmp    400315 <changedir+0x1d5>
            temp[i++]=path[back++];
  4002ed:	8b 45 f4             	mov    -0xc(%rbp),%eax
  4002f0:	8d 50 01             	lea    0x1(%rax),%edx
  4002f3:	89 55 f4             	mov    %edx,-0xc(%rbp)
  4002f6:	8b 55 f8             	mov    -0x8(%rbp),%edx
  4002f9:	8d 4a 01             	lea    0x1(%rdx),%ecx
  4002fc:	89 4d f8             	mov    %ecx,-0x8(%rbp)
  4002ff:	48 63 ca             	movslq %edx,%rcx
  400302:	48 8b 95 c8 fd ff ff 	mov    -0x238(%rbp),%rdx
  400309:	48 01 ca             	add    %rcx,%rdx
  40030c:	0f b6 12             	movzbl (%rdx),%edx
  40030f:	48 98                	cltq   
  400311:	88 54 05 d0          	mov    %dl,-0x30(%rbp,%rax,1)

    if(path[forward-1] != '/'){

        i=0;
        x = forward-back;
        while(i<x){
  400315:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400318:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  40031b:	7c d0                	jl     4002ed <changedir+0x1ad>
            temp[i++]=path[back++];
        }
        temp[i] = '\0';
  40031d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400320:	48 98                	cltq   
  400322:	c6 44 05 d0 00       	movb   $0x0,-0x30(%rbp,%rax,1)
        strcpy(components[numOfComponents++],temp);
  400327:	8b 45 f0             	mov    -0x10(%rbp),%eax
  40032a:	8d 50 01             	lea    0x1(%rax),%edx
  40032d:	89 55 f0             	mov    %edx,-0x10(%rbp)
  400330:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
  400337:	48 98                	cltq   
  400339:	48 c1 e0 02          	shl    $0x2,%rax
  40033d:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  400344:	00 
  400345:	48 01 c8             	add    %rcx,%rax
  400348:	48 01 c2             	add    %rax,%rdx
  40034b:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  40034f:	48 89 c6             	mov    %rax,%rsi
  400352:	48 89 d7             	mov    %rdx,%rdi
  400355:	e8 ad 26 00 00       	callq  402a07 <strcpy>

    char buff[100];
    char originalWorkingDirectory[100];
    char toSend[100];

    getcwd(originalWorkingDirectory,100);
  40035a:	48 8d 85 40 fe ff ff 	lea    -0x1c0(%rbp),%rax
  400361:	be 64 00 00 00       	mov    $0x64,%esi
  400366:	48 89 c7             	mov    %rax,%rdi
  400369:	e8 67 1b 00 00       	callq  401ed5 <getcwd>

   
    i=0;
  40036e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

    
    while(i < numOfComponents){
  400375:	e9 e4 01 00 00       	jmpq   40055e <changedir+0x41e>

        if(i == numOfComponents){
  40037a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  40037d:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  400380:	75 05                	jne    400387 <changedir+0x247>
            break;
  400382:	e9 e5 01 00 00       	jmpq   40056c <changedir+0x42c>
        }

        if(i==0){
  400387:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  40038b:	75 5c                	jne    4003e9 <changedir+0x2a9>
            strcpy(toSend,components[i]);
  40038d:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
  400394:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400397:	48 98                	cltq   
  400399:	48 c1 e0 02          	shl    $0x2,%rax
  40039d:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  4003a4:	00 
  4003a5:	48 01 c8             	add    %rcx,%rax
  4003a8:	48 01 c2             	add    %rax,%rdx
  4003ab:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  4003b2:	48 89 d6             	mov    %rdx,%rsi
  4003b5:	48 89 c7             	mov    %rax,%rdi
  4003b8:	e8 4a 26 00 00       	callq  402a07 <strcpy>
            
            if(chdir(toSend) == -1){
  4003bd:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  4003c4:	48 89 c7             	mov    %rax,%rdi
  4003c7:	e8 9e 2f 00 00       	callq  40336a <chdir>
  4003cc:	83 f8 ff             	cmp    $0xffffffff,%eax
  4003cf:	0f 85 7c 01 00 00    	jne    400551 <changedir+0x411>
            chdir(originalWorkingDirectory);
  4003d5:	48 8d 85 40 fe ff ff 	lea    -0x1c0(%rbp),%rax
  4003dc:	48 89 c7             	mov    %rax,%rdi
  4003df:	e8 86 2f 00 00       	callq  40336a <chdir>
            break;
  4003e4:	e9 83 01 00 00       	jmpq   40056c <changedir+0x42c>
            }
        }

        else if(strcmp(components[i],".")==0){
  4003e9:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
  4003f0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  4003f3:	48 98                	cltq   
  4003f5:	48 c1 e0 02          	shl    $0x2,%rax
  4003f9:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  400400:	00 
  400401:	48 01 c8             	add    %rcx,%rax
  400404:	48 01 d0             	add    %rdx,%rax
  400407:	48 8d 35 a4 2f 00 00 	lea    0x2fa4(%rip),%rsi        # 4033b2 <chdir+0x48>
  40040e:	48 89 c7             	mov    %rax,%rdi
  400411:	e8 50 26 00 00       	callq  402a66 <strcmp>
  400416:	85 c0                	test   %eax,%eax
  400418:	75 08                	jne    400422 <changedir+0x2e2>

        	//nothing to do
        	i++;
  40041a:	ff 45 f4             	incl   -0xc(%rbp)
        	continue;
  40041d:	e9 3c 01 00 00       	jmpq   40055e <changedir+0x41e>

        }

        else if(strcmp(components[i],"..")==0){
  400422:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
  400429:	8b 45 f4             	mov    -0xc(%rbp),%eax
  40042c:	48 98                	cltq   
  40042e:	48 c1 e0 02          	shl    $0x2,%rax
  400432:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  400439:	00 
  40043a:	48 01 c8             	add    %rcx,%rax
  40043d:	48 01 d0             	add    %rdx,%rax
  400440:	48 8d 35 6d 2f 00 00 	lea    0x2f6d(%rip),%rsi        # 4033b4 <chdir+0x4a>
  400447:	48 89 c7             	mov    %rax,%rdi
  40044a:	e8 17 26 00 00       	callq  402a66 <strcmp>
  40044f:	85 c0                	test   %eax,%eax
  400451:	75 4b                	jne    40049e <changedir+0x35e>

            if(i == numOfComponents){
  400453:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400456:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  400459:	75 05                	jne    400460 <changedir+0x320>
                break;
  40045b:	e9 0c 01 00 00       	jmpq   40056c <changedir+0x42c>
            }

            chdir("..");
  400460:	48 8d 3d 4d 2f 00 00 	lea    0x2f4d(%rip),%rdi        # 4033b4 <chdir+0x4a>
  400467:	e8 fe 2e 00 00       	callq  40336a <chdir>
            getcwd(buff,100);
  40046c:	48 8d 85 a4 fe ff ff 	lea    -0x15c(%rbp),%rax
  400473:	be 64 00 00 00       	mov    $0x64,%esi
  400478:	48 89 c7             	mov    %rax,%rdi
  40047b:	e8 55 1a 00 00       	callq  401ed5 <getcwd>
            strcpy(toSend,buff);
  400480:	48 8d 95 a4 fe ff ff 	lea    -0x15c(%rbp),%rdx
  400487:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  40048e:	48 89 d6             	mov    %rdx,%rsi
  400491:	48 89 c7             	mov    %rax,%rdi
  400494:	e8 6e 25 00 00       	callq  402a07 <strcpy>
  400499:	e9 b3 00 00 00       	jmpq   400551 <changedir+0x411>
        }


        else{

            if(i == numOfComponents){
  40049e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  4004a1:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  4004a4:	75 05                	jne    4004ab <changedir+0x36b>
                break;
  4004a6:	e9 c1 00 00 00       	jmpq   40056c <changedir+0x42c>
            }


            if(toSend[strlen(toSend)-1] != '/'){
  4004ab:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  4004b2:	48 89 c7             	mov    %rax,%rdi
  4004b5:	e8 18 25 00 00       	callq  4029d2 <strlen>
  4004ba:	ff c8                	dec    %eax
  4004bc:	48 98                	cltq   
  4004be:	0f b6 84 05 dc fd ff 	movzbl -0x224(%rbp,%rax,1),%eax
  4004c5:	ff 
  4004c6:	3c 2f                	cmp    $0x2f,%al
  4004c8:	74 16                	je     4004e0 <changedir+0x3a0>
                
                strcat(toSend,"/");
  4004ca:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  4004d1:	48 8d 35 c8 2e 00 00 	lea    0x2ec8(%rip),%rsi        # 4033a0 <chdir+0x36>
  4004d8:	48 89 c7             	mov    %rax,%rdi
  4004db:	e8 eb 26 00 00       	callq  402bcb <strcat>
            }
            
            strcat(toSend,components[i]);
  4004e0:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
  4004e7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  4004ea:	48 98                	cltq   
  4004ec:	48 c1 e0 02          	shl    $0x2,%rax
  4004f0:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  4004f7:	00 
  4004f8:	48 01 c8             	add    %rcx,%rax
  4004fb:	48 01 c2             	add    %rax,%rdx
  4004fe:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  400505:	48 89 d6             	mov    %rdx,%rsi
  400508:	48 89 c7             	mov    %rax,%rdi
  40050b:	e8 bb 26 00 00       	callq  402bcb <strcat>

            if(chdir(toSend) == -1){
  400510:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  400517:	48 89 c7             	mov    %rax,%rdi
  40051a:	e8 4b 2e 00 00       	callq  40336a <chdir>
  40051f:	83 f8 ff             	cmp    $0xffffffff,%eax
  400522:	75 2d                	jne    400551 <changedir+0x411>
            //Invalid path
            //restore to the cwd
           int ret= chdir(originalWorkingDirectory);
  400524:	48 8d 85 40 fe ff ff 	lea    -0x1c0(%rbp),%rax
  40052b:	48 89 c7             	mov    %rax,%rdi
  40052e:	e8 37 2e 00 00       	callq  40336a <chdir>
  400533:	89 45 e4             	mov    %eax,-0x1c(%rbp)
           if(ret<0)
  400536:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  40053a:	79 13                	jns    40054f <changedir+0x40f>
               printf("Could Not Change Directory");
  40053c:	48 8d 3d 74 2e 00 00 	lea    0x2e74(%rip),%rdi        # 4033b7 <chdir+0x4d>
  400543:	b8 00 00 00 00       	mov    $0x0,%eax
  400548:	e8 af 1d 00 00       	callq  4022fc <printf>
            break;
  40054d:	eb 1d                	jmp    40056c <changedir+0x42c>
  40054f:	eb 1b                	jmp    40056c <changedir+0x42c>
            }
        }

        i = i + 1;
  400551:	ff 45 f4             	incl   -0xc(%rbp)

        if(i == numOfComponents){
  400554:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400557:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  40055a:	75 02                	jne    40055e <changedir+0x41e>
            break;
  40055c:	eb 0e                	jmp    40056c <changedir+0x42c>

   
    i=0;

    
    while(i < numOfComponents){
  40055e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400561:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  400564:	0f 8c 10 fe ff ff    	jl     40037a <changedir+0x23a>
  40056a:	eb 00                	jmp    40056c <changedir+0x42c>
        }

    }
	

}
  40056c:	c9                   	leaveq 
  40056d:	c3                   	retq   

000000000040056e <setPath>:
#include <errno.h>
#include <string.h>
#include <shell.h>


char * setPath(char* env,char* path,int mode){
  40056e:	55                   	push   %rbp
  40056f:	48 89 e5             	mov    %rsp,%rbp
  400572:	53                   	push   %rbx
  400573:	48 83 ec 38          	sub    $0x38,%rsp
  400577:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  40057b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  40057f:	89 55 cc             	mov    %edx,-0x34(%rbp)

	int newEnvVarLength;
	//char p[500];
	char *new;

	if(mode == EASIS){
  400582:	83 7d cc 01          	cmpl   $0x1,-0x34(%rbp)
  400586:	75 6f                	jne    4005f7 <setPath+0x89>

		//Calculate new space for the path
		newEnvVarLength = strlen("PATH=") + strlen(path)+1;
  400588:	48 8d 3d 43 2e 00 00 	lea    0x2e43(%rip),%rdi        # 4033d2 <chdir+0x68>
  40058f:	e8 3e 24 00 00       	callq  4029d2 <strlen>
  400594:	89 c3                	mov    %eax,%ebx
  400596:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40059a:	48 89 c7             	mov    %rax,%rdi
  40059d:	e8 30 24 00 00       	callq  4029d2 <strlen>
  4005a2:	01 d8                	add    %ebx,%eax
  4005a4:	ff c0                	inc    %eax
  4005a6:	89 45 e4             	mov    %eax,-0x1c(%rbp)

		//printf("In setPath.... passed path is :%s:\n newEnvVarLength :%d\n",path,newEnvVarLength);


		//Allocate that space fr the new path
		new = (char*)malloc(sizeof(char)*newEnvVarLength);
  4005a9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  4005ac:	48 98                	cltq   
  4005ae:	48 89 c7             	mov    %rax,%rdi
  4005b1:	e8 b4 2b 00 00       	callq  40316a <malloc>
  4005b6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		strcpy(new,"PATH=");//copy the old env variable
  4005ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4005be:	48 8d 35 0d 2e 00 00 	lea    0x2e0d(%rip),%rsi        # 4033d2 <chdir+0x68>
  4005c5:	48 89 c7             	mov    %rax,%rdi
  4005c8:	e8 3a 24 00 00       	callq  402a07 <strcpy>
		strcpy(new+strlen("PATH="),path);
  4005cd:	48 8d 3d fe 2d 00 00 	lea    0x2dfe(%rip),%rdi        # 4033d2 <chdir+0x68>
  4005d4:	e8 f9 23 00 00       	callq  4029d2 <strlen>
  4005d9:	48 63 d0             	movslq %eax,%rdx
  4005dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4005e0:	48 01 c2             	add    %rax,%rdx
  4005e3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4005e7:	48 89 c6             	mov    %rax,%rsi
  4005ea:	48 89 d7             	mov    %rdx,%rdi
  4005ed:	e8 15 24 00 00       	callq  402a07 <strcpy>
  4005f2:	e9 92 00 00 00       	jmpq   400689 <setPath+0x11b>
	}
	else{


		//Calculate new space for the path
		newEnvVarLength = strlen(env) + strlen(path)+1;
  4005f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4005fb:	48 89 c7             	mov    %rax,%rdi
  4005fe:	e8 cf 23 00 00       	callq  4029d2 <strlen>
  400603:	89 c3                	mov    %eax,%ebx
  400605:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  400609:	48 89 c7             	mov    %rax,%rdi
  40060c:	e8 c1 23 00 00       	callq  4029d2 <strlen>
  400611:	01 d8                	add    %ebx,%eax
  400613:	ff c0                	inc    %eax
  400615:	89 45 e4             	mov    %eax,-0x1c(%rbp)

		//Allocate that space fr the new path
		new = (char*)malloc(sizeof(char)*newEnvVarLength);
  400618:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  40061b:	48 98                	cltq   
  40061d:	48 89 c7             	mov    %rax,%rdi
  400620:	e8 45 2b 00 00       	callq  40316a <malloc>
  400625:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		strcpy(new,env);//copy the old env variable
  400629:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  40062d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400631:	48 89 d6             	mov    %rdx,%rsi
  400634:	48 89 c7             	mov    %rax,%rdi
  400637:	e8 cb 23 00 00       	callq  402a07 <strcpy>
		strcpy(new+strlen(env),":");
  40063c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400640:	48 89 c7             	mov    %rax,%rdi
  400643:	e8 8a 23 00 00       	callq  4029d2 <strlen>
  400648:	48 63 d0             	movslq %eax,%rdx
  40064b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40064f:	48 01 d0             	add    %rdx,%rax
  400652:	48 8d 35 7f 2d 00 00 	lea    0x2d7f(%rip),%rsi        # 4033d8 <chdir+0x6e>
  400659:	48 89 c7             	mov    %rax,%rdi
  40065c:	e8 a6 23 00 00       	callq  402a07 <strcpy>
		strcpy(new+strlen(env)+1,path);
  400661:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400665:	48 89 c7             	mov    %rax,%rdi
  400668:	e8 65 23 00 00       	callq  4029d2 <strlen>
  40066d:	48 98                	cltq   
  40066f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  400673:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400677:	48 01 c2             	add    %rax,%rdx
  40067a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40067e:	48 89 c6             	mov    %rax,%rsi
  400681:	48 89 d7             	mov    %rdx,%rdi
  400684:	e8 7e 23 00 00       	callq  402a07 <strcpy>
	}


	//printf("Returning new path from setPath %s\n",new);

	return new;
  400689:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  40068d:	48 83 c4 38          	add    $0x38,%rsp
  400691:	5b                   	pop    %rbx
  400692:	5d                   	pop    %rbp
  400693:	c3                   	retq   

0000000000400694 <set>:



void set(char * args, char** envp){
  400694:	55                   	push   %rbp
  400695:	48 89 e5             	mov    %rsp,%rbp
  400698:	48 81 ec 30 04 00 00 	sub    $0x430,%rsp
  40069f:	48 89 bd d8 fb ff ff 	mov    %rdi,-0x428(%rbp)
  4006a6:	48 89 b5 d0 fb ff ff 	mov    %rsi,-0x430(%rbp)

	char *path=NULL;
  4006ad:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  4006b4:	00 
	//include logic to check for entire string ${PATH} or $PATH


	//printf("In set path\n\n");

	tokenEquals = tokenize(args,"=");
  4006b5:	48 8b 85 d8 fb ff ff 	mov    -0x428(%rbp),%rax
  4006bc:	48 8d 35 17 2d 00 00 	lea    0x2d17(%rip),%rsi        # 4033da <chdir+0x70>
  4006c3:	48 89 c7             	mov    %rax,%rdi
  4006c6:	e8 21 14 00 00       	callq  401aec <tokenize>
  4006cb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	 * Get the location in the envp array where PATH
	 * is stored. We will keep the modified PATH string in this location only.
	 */


	envLoc=findEnvVar("PATH",envp);
  4006cf:	48 8b 85 d0 fb ff ff 	mov    -0x430(%rbp),%rax
  4006d6:	48 89 c6             	mov    %rax,%rsi
  4006d9:	48 8d 3d fc 2c 00 00 	lea    0x2cfc(%rip),%rdi        # 4033dc <chdir+0x72>
  4006e0:	e8 9f 09 00 00       	callq  401084 <findEnvVar>
  4006e5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	if(tokenEquals->numOfTokens==1){
  4006e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4006ed:	8b 00                	mov    (%rax),%eax
  4006ef:	83 f8 01             	cmp    $0x1,%eax
  4006f2:	75 3d                	jne    400731 <set+0x9d>

		//printf("PATH= case.......\n\n");
		strcpy(tokentoPass,"");
  4006f4:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  4006fb:	48 8d 35 df 2c 00 00 	lea    0x2cdf(%rip),%rsi        # 4033e1 <chdir+0x77>
  400702:	48 89 c7             	mov    %rax,%rdi
  400705:	e8 fd 22 00 00       	callq  402a07 <strcpy>
		path = setPath(*envLoc,tokentoPass,EASIS);
  40070a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40070e:	48 8b 00             	mov    (%rax),%rax
  400711:	48 8d 8d dc fd ff ff 	lea    -0x224(%rbp),%rcx
  400718:	ba 01 00 00 00       	mov    $0x1,%edx
  40071d:	48 89 ce             	mov    %rcx,%rsi
  400720:	48 89 c7             	mov    %rax,%rdi
  400723:	e8 46 fe ff ff       	callq  40056e <setPath>
  400728:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  40072c:	e9 ab 01 00 00       	jmpq   4008dc <set+0x248>
		return;

	}


	strcpy(tokentoPass,tokenEquals->tokenArr[1]);
  400731:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400735:	48 8b 50 10          	mov    0x10(%rax),%rdx
  400739:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  400740:	48 89 d6             	mov    %rdx,%rsi
  400743:	48 89 c7             	mov    %rax,%rdi
  400746:	e8 bc 22 00 00       	callq  402a07 <strcpy>
	//printf("Token to pass after tokenizing on colon is .%s.\n",tokentoPass);
	tokenColon = tokenize(tokentoPass,":");
  40074b:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  400752:	48 8d 35 7f 2c 00 00 	lea    0x2c7f(%rip),%rsi        # 4033d8 <chdir+0x6e>
  400759:	48 89 c7             	mov    %rax,%rdi
  40075c:	e8 8b 13 00 00       	callq  401aec <tokenize>
  400761:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	/*
	 * Save the value of PATH in oldSysPath.We will need this
	 * when we need to expand ${PATH}
	 */
	char oldSysPath[500];
	token = tokenize(*envLoc,"=");
  400765:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400769:	48 8b 00             	mov    (%rax),%rax
  40076c:	48 8d 35 67 2c 00 00 	lea    0x2c67(%rip),%rsi        # 4033da <chdir+0x70>
  400773:	48 89 c7             	mov    %rax,%rdi
  400776:	e8 71 13 00 00       	callq  401aec <tokenize>
  40077b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	strcpy(oldSysPath,token->tokenArr[1]);
  40077f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  400783:	48 8b 50 10          	mov    0x10(%rax),%rdx
  400787:	48 8d 85 e8 fb ff ff 	lea    -0x418(%rbp),%rax
  40078e:	48 89 d6             	mov    %rdx,%rsi
  400791:	48 89 c7             	mov    %rax,%rdi
  400794:	e8 6e 22 00 00       	callq  402a07 <strcpy>

	/*
	 * First element of the tokenColon always needs to be addes ASIS
	 * Check if the component to add is ${PATH}.If yes send oldSysPath
	 */
	if((strcmp(tokenColon->tokenArr[0],"${PATH}")==0)||(strcmp(tokenColon->tokenArr[0],"$PATH")==0)){
  400799:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40079d:	48 8b 40 08          	mov    0x8(%rax),%rax
  4007a1:	48 8d 35 3a 2c 00 00 	lea    0x2c3a(%rip),%rsi        # 4033e2 <chdir+0x78>
  4007a8:	48 89 c7             	mov    %rax,%rdi
  4007ab:	e8 b6 22 00 00       	callq  402a66 <strcmp>
  4007b0:	85 c0                	test   %eax,%eax
  4007b2:	74 1b                	je     4007cf <set+0x13b>
  4007b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4007b8:	48 8b 40 08          	mov    0x8(%rax),%rax
  4007bc:	48 8d 35 27 2c 00 00 	lea    0x2c27(%rip),%rsi        # 4033ea <chdir+0x80>
  4007c3:	48 89 c7             	mov    %rax,%rdi
  4007c6:	e8 9b 22 00 00       	callq  402a66 <strcmp>
  4007cb:	85 c0                	test   %eax,%eax
  4007cd:	75 24                	jne    4007f3 <set+0x15f>
		path = setPath(*envLoc,oldSysPath,EASIS);
  4007cf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4007d3:	48 8b 00             	mov    (%rax),%rax
  4007d6:	48 8d 8d e8 fb ff ff 	lea    -0x418(%rbp),%rcx
  4007dd:	ba 01 00 00 00       	mov    $0x1,%edx
  4007e2:	48 89 ce             	mov    %rcx,%rsi
  4007e5:	48 89 c7             	mov    %rax,%rdi
  4007e8:	e8 81 fd ff ff       	callq  40056e <setPath>
  4007ed:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  4007f1:	eb 23                	jmp    400816 <set+0x182>
		//printf("PATH IS %s\n",path);
	}
	else{
		path = setPath(*envLoc,tokenColon->tokenArr[0],EASIS);
  4007f3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4007f7:	48 8b 48 08          	mov    0x8(%rax),%rcx
  4007fb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4007ff:	48 8b 00             	mov    (%rax),%rax
  400802:	ba 01 00 00 00       	mov    $0x1,%edx
  400807:	48 89 ce             	mov    %rcx,%rsi
  40080a:	48 89 c7             	mov    %rax,%rdi
  40080d:	e8 5c fd ff ff       	callq  40056e <setPath>
  400812:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}

	//Assign the newly modified path to envLoc.This causes the envp array to get updated
	*envLoc = path;
  400816:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40081a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  40081e:	48 89 10             	mov    %rdx,(%rax)

	//printf("The new environment is: %s\n", getenv("PATH"));


	//Append the later elements in a loop
	for(i=1;i<tokenColon->numOfTokens;i++){
  400821:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
  400828:	e9 a0 00 00 00       	jmpq   4008cd <set+0x239>

		/*
		 * Check if the component to add is ${PATH}.If yes send oldSysPath
		 *
		 */
		if((strcmp(tokenColon->tokenArr[i],"${PATH}")==0)||(strcmp(tokenColon->tokenArr[i],"$PATH")==0)){
  40082d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400831:	8b 55 f4             	mov    -0xc(%rbp),%edx
  400834:	48 63 d2             	movslq %edx,%rdx
  400837:	48 8b 44 d0 08       	mov    0x8(%rax,%rdx,8),%rax
  40083c:	48 8d 35 9f 2b 00 00 	lea    0x2b9f(%rip),%rsi        # 4033e2 <chdir+0x78>
  400843:	48 89 c7             	mov    %rax,%rdi
  400846:	e8 1b 22 00 00       	callq  402a66 <strcmp>
  40084b:	85 c0                	test   %eax,%eax
  40084d:	74 22                	je     400871 <set+0x1dd>
  40084f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400853:	8b 55 f4             	mov    -0xc(%rbp),%edx
  400856:	48 63 d2             	movslq %edx,%rdx
  400859:	48 8b 44 d0 08       	mov    0x8(%rax,%rdx,8),%rax
  40085e:	48 8d 35 85 2b 00 00 	lea    0x2b85(%rip),%rsi        # 4033ea <chdir+0x80>
  400865:	48 89 c7             	mov    %rax,%rdi
  400868:	e8 f9 21 00 00       	callq  402a66 <strcmp>
  40086d:	85 c0                	test   %eax,%eax
  40086f:	75 24                	jne    400895 <set+0x201>
			path = setPath(*envLoc,oldSysPath,EAPPEND);
  400871:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400875:	48 8b 00             	mov    (%rax),%rax
  400878:	48 8d 8d e8 fb ff ff 	lea    -0x418(%rbp),%rcx
  40087f:	ba 02 00 00 00       	mov    $0x2,%edx
  400884:	48 89 ce             	mov    %rcx,%rsi
  400887:	48 89 c7             	mov    %rax,%rdi
  40088a:	e8 df fc ff ff       	callq  40056e <setPath>
  40088f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  400893:	eb 2a                	jmp    4008bf <set+0x22b>
			//printf("PATH IS %s\n",path);
		}
		else{
			path = setPath(*envLoc,tokenColon->tokenArr[i],EAPPEND);
  400895:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400899:	8b 55 f4             	mov    -0xc(%rbp),%edx
  40089c:	48 63 d2             	movslq %edx,%rdx
  40089f:	48 8b 4c d0 08       	mov    0x8(%rax,%rdx,8),%rcx
  4008a4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4008a8:	48 8b 00             	mov    (%rax),%rax
  4008ab:	ba 02 00 00 00       	mov    $0x2,%edx
  4008b0:	48 89 ce             	mov    %rcx,%rsi
  4008b3:	48 89 c7             	mov    %rax,%rdi
  4008b6:	e8 b3 fc ff ff       	callq  40056e <setPath>
  4008bb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		}

		//Assign the newly modified path to envLoc.This causes the envp array to get updated
		*envLoc = path;
  4008bf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4008c3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  4008c7:	48 89 10             	mov    %rdx,(%rax)

	//printf("The new environment is: %s\n", getenv("PATH"));


	//Append the later elements in a loop
	for(i=1;i<tokenColon->numOfTokens;i++){
  4008ca:	ff 45 f4             	incl   -0xc(%rbp)
  4008cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4008d1:	8b 00                	mov    (%rax),%eax
  4008d3:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  4008d6:	0f 8f 51 ff ff ff    	jg     40082d <set+0x199>


	}//End of for loop

	//printf("The new environment is: %s\n", getenv("PATH"));
}
  4008dc:	c9                   	leaveq 
  4008dd:	c3                   	retq   

00000000004008de <executeBuiltins>:
#include <parser.h>
#include <errno.h>
#include <string.h>
#include <shell.h>

void executeBuiltins(parseInfo* command,char*envp[]){
  4008de:	55                   	push   %rbp
  4008df:	48 89 e5             	mov    %rsp,%rbp
  4008e2:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  4008e6:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
  4008ea:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
		printf("Token %d : %s\n",i,command->CommArray[0]->VarList[i]);
	}*/



	if(strcmp(command->CommArray[0]->commandName,"set")==0){
  4008ee:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4008f2:	48 8b 00             	mov    (%rax),%rax
  4008f5:	48 8b 00             	mov    (%rax),%rax
  4008f8:	48 8d 35 f1 2a 00 00 	lea    0x2af1(%rip),%rsi        # 4033f0 <chdir+0x86>
  4008ff:	48 89 c7             	mov    %rax,%rdi
  400902:	e8 5f 21 00 00       	callq  402a66 <strcmp>
  400907:	85 c0                	test   %eax,%eax
  400909:	0f 85 f5 00 00 00    	jne    400a04 <executeBuiltins+0x126>

		if(strstr(command->CommArray[0]->VarList[1],"PATH")!=NULL){
  40090f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400913:	48 8b 00             	mov    (%rax),%rax
  400916:	48 8b 40 10          	mov    0x10(%rax),%rax
  40091a:	48 8d 35 d3 2a 00 00 	lea    0x2ad3(%rip),%rsi        # 4033f4 <chdir+0x8a>
  400921:	48 89 c7             	mov    %rax,%rdi
  400924:	e8 c4 21 00 00       	callq  402aed <strstr>
  400929:	48 85 c0             	test   %rax,%rax
  40092c:	74 76                	je     4009a4 <executeBuiltins+0xc6>
			//execute change PATH
			//printf("Going to change path");


			if(command->CommArray[0]->VarNum >2){
  40092e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400932:	48 8b 00             	mov    (%rax),%rax
  400935:	8b 40 58             	mov    0x58(%rax),%eax
  400938:	83 f8 02             	cmp    $0x2,%eax
  40093b:	7e 16                	jle    400953 <executeBuiltins+0x75>

				printf("Too many arguments to set PATH.Please enter set PATH=ABC:XYX:... (no spaces in between)\n");
  40093d:	48 8d 3d bc 2a 00 00 	lea    0x2abc(%rip),%rdi        # 403400 <chdir+0x96>
  400944:	b8 00 00 00 00       	mov    $0x0,%eax
  400949:	e8 ae 19 00 00       	callq  4022fc <printf>
				return;
  40094e:	e9 56 01 00 00       	jmpq   400aa9 <executeBuiltins+0x1cb>
			}


			set(command->CommArray[0]->VarList[1],envp);
  400953:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400957:	48 8b 00             	mov    (%rax),%rax
  40095a:	48 8b 40 10          	mov    0x10(%rax),%rax
  40095e:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  400962:	48 89 d6             	mov    %rdx,%rsi
  400965:	48 89 c7             	mov    %rax,%rdi
  400968:	e8 27 fd ff ff       	callq  400694 <set>
			envVar=findEnvVar("PATH",envp);
  40096d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  400971:	48 89 c6             	mov    %rax,%rsi
  400974:	48 8d 3d 79 2a 00 00 	lea    0x2a79(%rip),%rdi        # 4033f4 <chdir+0x8a>
  40097b:	e8 04 07 00 00       	callq  401084 <findEnvVar>
  400980:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			printf("Current Path is :\n %s\n",*envVar);
  400984:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  400988:	48 8b 00             	mov    (%rax),%rax
  40098b:	48 89 c6             	mov    %rax,%rsi
  40098e:	48 8d 3d c4 2a 00 00 	lea    0x2ac4(%rip),%rdi        # 403459 <chdir+0xef>
  400995:	b8 00 00 00 00       	mov    $0x0,%eax
  40099a:	e8 5d 19 00 00       	callq  4022fc <printf>
  40099f:	e9 04 01 00 00       	jmpq   400aa8 <executeBuiltins+0x1ca>


		}
		else if(strstr(command->CommArray[0]->VarList[1],"PS1")!=NULL){
  4009a4:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4009a8:	48 8b 00             	mov    (%rax),%rax
  4009ab:	48 8b 40 10          	mov    0x10(%rax),%rax
  4009af:	48 8d 35 ba 2a 00 00 	lea    0x2aba(%rip),%rsi        # 403470 <chdir+0x106>
  4009b6:	48 89 c7             	mov    %rax,%rdi
  4009b9:	e8 2f 21 00 00       	callq  402aed <strstr>
  4009be:	48 85 c0             	test   %rax,%rax
  4009c1:	0f 84 e1 00 00 00    	je     400aa8 <executeBuiltins+0x1ca>
			//simple change the shell variable PS1
			//Add function to remove spaces from PS1=hgchbvh

			//printf("Going to change PS1");

			if(command->CommArray[0]->VarNum >2){
  4009c7:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4009cb:	48 8b 00             	mov    (%rax),%rax
  4009ce:	8b 40 58             	mov    0x58(%rax),%eax
  4009d1:	83 f8 02             	cmp    $0x2,%eax
  4009d4:	7e 16                	jle    4009ec <executeBuiltins+0x10e>

				printf("Too many arguments to set PS1.Please enter set PS1=ABCD (no spaces in between)\n");
  4009d6:	48 8d 3d 9b 2a 00 00 	lea    0x2a9b(%rip),%rdi        # 403478 <chdir+0x10e>
  4009dd:	b8 00 00 00 00       	mov    $0x0,%eax
  4009e2:	e8 15 19 00 00       	callq  4022fc <printf>
				return;
  4009e7:	e9 bd 00 00 00       	jmpq   400aa9 <executeBuiltins+0x1cb>
			}

			changePS1(command->CommArray[0]->VarList[1]);
  4009ec:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4009f0:	48 8b 00             	mov    (%rax),%rax
  4009f3:	48 8b 40 10          	mov    0x10(%rax),%rax
  4009f7:	48 89 c7             	mov    %rax,%rdi
  4009fa:	e8 03 0b 00 00       	callq  401502 <changePS1>
		printf("Current Working Directory is: %s\n",cmdWithoutSpaces);

	}


	return;
  4009ff:	e9 a5 00 00 00       	jmpq   400aa9 <executeBuiltins+0x1cb>

		}
	}


	else if(strcmp(command->CommArray[0]->commandName,"exit")==0){
  400a04:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400a08:	48 8b 00             	mov    (%rax),%rax
  400a0b:	48 8b 00             	mov    (%rax),%rax
  400a0e:	48 8d 35 b3 2a 00 00 	lea    0x2ab3(%rip),%rsi        # 4034c8 <chdir+0x15e>
  400a15:	48 89 c7             	mov    %rax,%rdi
  400a18:	e8 49 20 00 00       	callq  402a66 <strcmp>
  400a1d:	85 c0                	test   %eax,%eax
  400a1f:	75 0c                	jne    400a2d <executeBuiltins+0x14f>

		exit(0);
  400a21:	bf 00 00 00 00       	mov    $0x0,%edi
  400a26:	e8 8b 1f 00 00       	callq  4029b6 <exit>
  400a2b:	eb 7b                	jmp    400aa8 <executeBuiltins+0x1ca>
	}

	else if(strcmp(command->CommArray[0]->commandName,"cd")==0) {
  400a2d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400a31:	48 8b 00             	mov    (%rax),%rax
  400a34:	48 8b 00             	mov    (%rax),%rax
  400a37:	48 8d 35 8f 2a 00 00 	lea    0x2a8f(%rip),%rsi        # 4034cd <chdir+0x163>
  400a3e:	48 89 c7             	mov    %rax,%rdi
  400a41:	e8 20 20 00 00       	callq  402a66 <strcmp>
  400a46:	85 c0                	test   %eax,%eax
  400a48:	75 5e                	jne    400aa8 <executeBuiltins+0x1ca>
		if(command->CommArray[0]->VarNum >2){
  400a4a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400a4e:	48 8b 00             	mov    (%rax),%rax
  400a51:	8b 40 58             	mov    0x58(%rax),%eax
  400a54:	83 f8 02             	cmp    $0x2,%eax
  400a57:	7e 13                	jle    400a6c <executeBuiltins+0x18e>

			printf("Too many arguments to cd.Please enter cd <directory name>\n");
  400a59:	48 8d 3d 70 2a 00 00 	lea    0x2a70(%rip),%rdi        # 4034d0 <chdir+0x166>
  400a60:	b8 00 00 00 00       	mov    $0x0,%eax
  400a65:	e8 92 18 00 00       	callq  4022fc <printf>
			return;
  400a6a:	eb 3d                	jmp    400aa9 <executeBuiltins+0x1cb>
		}


		//execute change directory
		changedir(command->CommArray[0]->VarList[1]);
  400a6c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400a70:	48 8b 00             	mov    (%rax),%rax
  400a73:	48 8b 40 10          	mov    0x10(%rax),%rax
  400a77:	48 89 c7             	mov    %rax,%rdi
  400a7a:	e8 c1 f6 ff ff       	callq  400140 <changedir>
		getcwd(cmdWithoutSpaces,100);
  400a7f:	48 8d 45 94          	lea    -0x6c(%rbp),%rax
  400a83:	be 64 00 00 00       	mov    $0x64,%esi
  400a88:	48 89 c7             	mov    %rax,%rdi
  400a8b:	e8 45 14 00 00       	callq  401ed5 <getcwd>
		printf("Current Working Directory is: %s\n",cmdWithoutSpaces);
  400a90:	48 8d 45 94          	lea    -0x6c(%rbp),%rax
  400a94:	48 89 c6             	mov    %rax,%rsi
  400a97:	48 8d 3d 72 2a 00 00 	lea    0x2a72(%rip),%rdi        # 403510 <chdir+0x1a6>
  400a9e:	b8 00 00 00 00       	mov    $0x0,%eax
  400aa3:	e8 54 18 00 00       	callq  4022fc <printf>

	}


	return;
  400aa8:	90                   	nop


}
  400aa9:	c9                   	leaveq 
  400aaa:	c3                   	retq   

0000000000400aab <execute_cmd>:
#include <shell.h>



void execute_cmd(parseInfo * info,char*envp[])
{
  400aab:	55                   	push   %rbp
  400aac:	48 89 e5             	mov    %rsp,%rbp
  400aaf:	53                   	push   %rbx
  400ab0:	48 81 ec 28 08 00 00 	sub    $0x828,%rsp
  400ab7:	48 89 bd d8 f7 ff ff 	mov    %rdi,-0x828(%rbp)
  400abe:	48 89 b5 d0 f7 ff ff 	mov    %rsi,-0x830(%rbp)
	int i,j,*pipes=NULL,status;
  400ac5:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  400acc:	00 
	char cmd[20][100];

	int  *proc_ids;
	//printf("pipes=%d \n",info->pipeNum);

	for(i=0; i<=info->pipeNum; i++)
  400acd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  400ad4:	eb 36                	jmp    400b0c <execute_cmd+0x61>
	{
		//printf("info: %s\n", info->CommArray[i]->commandName);
		strcpy(cmd[i],info->CommArray[i]->commandName);
  400ad6:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400add:	8b 55 ec             	mov    -0x14(%rbp),%edx
  400ae0:	48 63 d2             	movslq %edx,%rdx
  400ae3:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  400ae7:	48 8b 00             	mov    (%rax),%rax
  400aea:	48 8d 8d fc f7 ff ff 	lea    -0x804(%rbp),%rcx
  400af1:	8b 55 ec             	mov    -0x14(%rbp),%edx
  400af4:	48 63 d2             	movslq %edx,%rdx
  400af7:	48 6b d2 64          	imul   $0x64,%rdx,%rdx
  400afb:	48 01 ca             	add    %rcx,%rdx
  400afe:	48 89 c6             	mov    %rax,%rsi
  400b01:	48 89 d7             	mov    %rdx,%rdi
  400b04:	e8 fe 1e 00 00       	callq  402a07 <strcpy>
	char cmd[20][100];

	int  *proc_ids;
	//printf("pipes=%d \n",info->pipeNum);

	for(i=0; i<=info->pipeNum; i++)
  400b09:	ff 45 ec             	incl   -0x14(%rbp)
  400b0c:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400b13:	8b 40 50             	mov    0x50(%rax),%eax
  400b16:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  400b19:	7d bb                	jge    400ad6 <execute_cmd+0x2b>
		//printf("varList=%s\n",info->CommArray[i]->VarList[j]);
	}



	proc_ids = (int *)malloc(info->pipeNum+1);
  400b1b:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400b22:	8b 40 50             	mov    0x50(%rax),%eax
  400b25:	ff c0                	inc    %eax
  400b27:	48 98                	cltq   
  400b29:	48 89 c7             	mov    %rax,%rdi
  400b2c:	e8 39 26 00 00       	callq  40316a <malloc>
  400b31:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	if(info->pipeNum==0)
  400b35:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400b3c:	8b 40 50             	mov    0x50(%rax),%eax
  400b3f:	85 c0                	test   %eax,%eax
  400b41:	0f 85 ca 00 00 00    	jne    400c11 <execute_cmd+0x166>
	{
		printf("forking");
  400b47:	48 8d 3d e4 29 00 00 	lea    0x29e4(%rip),%rdi        # 403532 <chdir+0x1c8>
  400b4e:	b8 00 00 00 00       	mov    $0x0,%eax
  400b53:	e8 a4 17 00 00       	callq  4022fc <printf>


		proc_ids[0]=fork();
  400b58:	e8 ee 1d 00 00       	callq  40294b <fork>
  400b5d:	89 c2                	mov    %eax,%edx
  400b5f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400b63:	89 10                	mov    %edx,(%rax)

		if (proc_ids[0] < 0)
  400b65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400b69:	8b 00                	mov    (%rax),%eax
  400b6b:	85 c0                	test   %eax,%eax
  400b6d:	79 1a                	jns    400b89 <execute_cmd+0xde>
		{
			strerror( errno);
  400b6f:	48 8b 05 ea 39 20 00 	mov    0x2039ea(%rip),%rax        # 604560 <chdir+0x2011f6>
  400b76:	8b 00                	mov    (%rax),%eax
  400b78:	89 c7                	mov    %eax,%edi
  400b7a:	e8 87 20 00 00       	callq  402c06 <strerror>
			exit(1);
  400b7f:	bf 01 00 00 00       	mov    $0x1,%edi
  400b84:	e8 2d 1e 00 00       	callq  4029b6 <exit>
		}
		if(proc_ids[0]==0)
  400b89:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400b8d:	8b 00                	mov    (%rax),%eax
  400b8f:	85 c0                	test   %eax,%eax
  400b91:	0f 85 08 03 00 00    	jne    400e9f <execute_cmd+0x3f4>
		{
			//printf("executing %s\n",cmd[0]);

			printf("Executing Command %s\n",cmd[0]);
  400b97:	48 8d 85 fc f7 ff ff 	lea    -0x804(%rbp),%rax
  400b9e:	48 89 c6             	mov    %rax,%rsi
  400ba1:	48 8d 3d 92 29 00 00 	lea    0x2992(%rip),%rdi        # 40353a <chdir+0x1d0>
  400ba8:	b8 00 00 00 00       	mov    $0x0,%eax
  400bad:	e8 4a 17 00 00       	callq  4022fc <printf>

			char* envpChildProcess[]={NULL};
  400bb2:	48 c7 85 f0 f7 ff ff 	movq   $0x0,-0x810(%rbp)
  400bb9:	00 00 00 00 
			int ret = execve(cmd[0],info->CommArray[0]->VarList,envpChildProcess);
  400bbd:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400bc4:	48 8b 00             	mov    (%rax),%rax
  400bc7:	48 8d 48 08          	lea    0x8(%rax),%rcx
  400bcb:	48 8d 95 f0 f7 ff ff 	lea    -0x810(%rbp),%rdx
  400bd2:	48 8d 85 fc f7 ff ff 	lea    -0x804(%rbp),%rax
  400bd9:	48 89 ce             	mov    %rcx,%rsi
  400bdc:	48 89 c7             	mov    %rax,%rdi
  400bdf:	e8 06 1d 00 00       	callq  4028ea <execve>
  400be4:	89 45 d4             	mov    %eax,-0x2c(%rbp)
			if(ret == -1)
  400be7:	83 7d d4 ff          	cmpl   $0xffffffff,-0x2c(%rbp)
  400beb:	75 1f                	jne    400c0c <execute_cmd+0x161>
			{
				strerror(errno);
  400bed:	48 8b 05 6c 39 20 00 	mov    0x20396c(%rip),%rax        # 604560 <chdir+0x2011f6>
  400bf4:	8b 00                	mov    (%rax),%eax
  400bf6:	89 c7                	mov    %eax,%edi
  400bf8:	e8 09 20 00 00       	callq  402c06 <strerror>
				exit(1);
  400bfd:	bf 01 00 00 00       	mov    $0x1,%edi
  400c02:	e8 af 1d 00 00       	callq  4029b6 <exit>
  400c07:	e9 93 02 00 00       	jmpq   400e9f <execute_cmd+0x3f4>
  400c0c:	e9 8e 02 00 00       	jmpq   400e9f <execute_cmd+0x3f4>
		//printf("\ndone\n");
	}
	else
	{

		pipes=(int*)malloc(2*info->pipeNum*sizeof(int));
  400c11:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400c18:	8b 40 50             	mov    0x50(%rax),%eax
  400c1b:	48 98                	cltq   
  400c1d:	48 c1 e0 03          	shl    $0x3,%rax
  400c21:	48 89 c7             	mov    %rax,%rdi
  400c24:	e8 41 25 00 00       	callq  40316a <malloc>
  400c29:	48 89 45 e0          	mov    %rax,-0x20(%rbp)


		for(i=0; i<info->pipeNum; i++)
  400c2d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  400c34:	eb 34                	jmp    400c6a <execute_cmd+0x1bf>
		{
			if(pipe(pipes+i*2) == -1)
  400c36:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400c39:	48 98                	cltq   
  400c3b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  400c42:	00 
  400c43:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400c47:	48 01 d0             	add    %rdx,%rax
  400c4a:	48 89 c7             	mov    %rax,%rdi
  400c4d:	e8 2f 1c 00 00       	callq  402881 <pipe>
  400c52:	83 f8 ff             	cmp    $0xffffffff,%eax
  400c55:	75 10                	jne    400c67 <execute_cmd+0x1bc>
				strerror(errno);
  400c57:	48 8b 05 02 39 20 00 	mov    0x203902(%rip),%rax        # 604560 <chdir+0x2011f6>
  400c5e:	8b 00                	mov    (%rax),%eax
  400c60:	89 c7                	mov    %eax,%edi
  400c62:	e8 9f 1f 00 00       	callq  402c06 <strerror>
	{

		pipes=(int*)malloc(2*info->pipeNum*sizeof(int));


		for(i=0; i<info->pipeNum; i++)
  400c67:	ff 45 ec             	incl   -0x14(%rbp)
  400c6a:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400c71:	8b 40 50             	mov    0x50(%rax),%eax
  400c74:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  400c77:	7f bd                	jg     400c36 <execute_cmd+0x18b>
		{
			if(pipe(pipes+i*2) == -1)
				strerror(errno);
		}
		//printf("Multiple Commands");
		for(i=0; i<=info->pipeNum;i++)
  400c79:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  400c80:	e9 b2 01 00 00       	jmpq   400e37 <execute_cmd+0x38c>
		{
			proc_ids[i]=fork();
  400c85:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400c88:	48 98                	cltq   
  400c8a:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400c91:	00 
  400c92:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400c96:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  400c9a:	e8 ac 1c 00 00       	callq  40294b <fork>
  400c9f:	89 03                	mov    %eax,(%rbx)
			if (proc_ids[i] < 0)
  400ca1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400ca4:	48 98                	cltq   
  400ca6:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400cad:	00 
  400cae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400cb2:	48 01 d0             	add    %rdx,%rax
  400cb5:	8b 00                	mov    (%rax),%eax
  400cb7:	85 c0                	test   %eax,%eax
  400cb9:	79 1a                	jns    400cd5 <execute_cmd+0x22a>
			{
				strerror(errno);
  400cbb:	48 8b 05 9e 38 20 00 	mov    0x20389e(%rip),%rax        # 604560 <chdir+0x2011f6>
  400cc2:	8b 00                	mov    (%rax),%eax
  400cc4:	89 c7                	mov    %eax,%edi
  400cc6:	e8 3b 1f 00 00       	callq  402c06 <strerror>
				exit(1);
  400ccb:	bf 01 00 00 00       	mov    $0x1,%edi
  400cd0:	e8 e1 1c 00 00       	callq  4029b6 <exit>
			}
			//printf("pid=%d",proc_ids[i]);
			if(proc_ids[i]==0)
  400cd5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400cd8:	48 98                	cltq   
  400cda:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400ce1:	00 
  400ce2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400ce6:	48 01 d0             	add    %rdx,%rax
  400ce9:	8b 00                	mov    (%rax),%eax
  400ceb:	85 c0                	test   %eax,%eax
  400ced:	0f 85 41 01 00 00    	jne    400e34 <execute_cmd+0x389>
			{
				//printf("in child%d",i);

				if(i!=0)
  400cf3:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  400cf7:	74 37                	je     400d30 <execute_cmd+0x285>
				{
					if(dup2(pipes[i*2-2],0)==-1)
  400cf9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400cfc:	48 98                	cltq   
  400cfe:	48 c1 e0 03          	shl    $0x3,%rax
  400d02:	48 8d 50 f8          	lea    -0x8(%rax),%rdx
  400d06:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400d0a:	48 01 d0             	add    %rdx,%rax
  400d0d:	8b 00                	mov    (%rax),%eax
  400d0f:	be 00 00 00 00       	mov    $0x0,%esi
  400d14:	89 c7                	mov    %eax,%edi
  400d16:	e8 e6 10 00 00       	callq  401e01 <dup2>
  400d1b:	83 f8 ff             	cmp    $0xffffffff,%eax
  400d1e:	75 10                	jne    400d30 <execute_cmd+0x285>
						strerror(errno);
  400d20:	48 8b 05 39 38 20 00 	mov    0x203839(%rip),%rax        # 604560 <chdir+0x2011f6>
  400d27:	8b 00                	mov    (%rax),%eax
  400d29:	89 c7                	mov    %eax,%edi
  400d2b:	e8 d6 1e 00 00       	callq  402c06 <strerror>
				}
				if(i!=info->pipeNum)
  400d30:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400d37:	8b 40 50             	mov    0x50(%rax),%eax
  400d3a:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  400d3d:	74 37                	je     400d76 <execute_cmd+0x2cb>
				{

					if(dup2(pipes[i*2+1],1)==-1)
  400d3f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400d42:	48 98                	cltq   
  400d44:	48 c1 e0 03          	shl    $0x3,%rax
  400d48:	48 8d 50 04          	lea    0x4(%rax),%rdx
  400d4c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400d50:	48 01 d0             	add    %rdx,%rax
  400d53:	8b 00                	mov    (%rax),%eax
  400d55:	be 01 00 00 00       	mov    $0x1,%esi
  400d5a:	89 c7                	mov    %eax,%edi
  400d5c:	e8 a0 10 00 00       	callq  401e01 <dup2>
  400d61:	83 f8 ff             	cmp    $0xffffffff,%eax
  400d64:	75 10                	jne    400d76 <execute_cmd+0x2cb>
						strerror(errno);
  400d66:	48 8b 05 f3 37 20 00 	mov    0x2037f3(%rip),%rax        # 604560 <chdir+0x2011f6>
  400d6d:	8b 00                	mov    (%rax),%eax
  400d6f:	89 c7                	mov    %eax,%edi
  400d71:	e8 90 1e 00 00       	callq  402c06 <strerror>
				}

				for(j=0;j<info->pipeNum;j++)
  400d76:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
  400d7d:	eb 3d                	jmp    400dbc <execute_cmd+0x311>
				{
					close(pipes[j*2]);
  400d7f:	8b 45 e8             	mov    -0x18(%rbp),%eax
  400d82:	48 98                	cltq   
  400d84:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  400d8b:	00 
  400d8c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400d90:	48 01 d0             	add    %rdx,%rax
  400d93:	8b 00                	mov    (%rax),%eax
  400d95:	89 c7                	mov    %eax,%edi
  400d97:	e8 b8 11 00 00       	callq  401f54 <close>
					close(pipes[j*2+1]);
  400d9c:	8b 45 e8             	mov    -0x18(%rbp),%eax
  400d9f:	48 98                	cltq   
  400da1:	48 c1 e0 03          	shl    $0x3,%rax
  400da5:	48 8d 50 04          	lea    0x4(%rax),%rdx
  400da9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400dad:	48 01 d0             	add    %rdx,%rax
  400db0:	8b 00                	mov    (%rax),%eax
  400db2:	89 c7                	mov    %eax,%edi
  400db4:	e8 9b 11 00 00       	callq  401f54 <close>

					if(dup2(pipes[i*2+1],1)==-1)
						strerror(errno);
				}

				for(j=0;j<info->pipeNum;j++)
  400db9:	ff 45 e8             	incl   -0x18(%rbp)
  400dbc:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400dc3:	8b 40 50             	mov    0x50(%rax),%eax
  400dc6:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  400dc9:	7f b4                	jg     400d7f <execute_cmd+0x2d4>
				//printf("debug:%s ", cmd[i]);


				//printf("Executing Command %s\n",cmd[i]);

				char* envpChildProcess[]={NULL};
  400dcb:	48 c7 85 e8 f7 ff ff 	movq   $0x0,-0x818(%rbp)
  400dd2:	00 00 00 00 
				int ret=execve(cmd[i],info->CommArray[i]->VarList,envpChildProcess);
  400dd6:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400ddd:	8b 55 ec             	mov    -0x14(%rbp),%edx
  400de0:	48 63 d2             	movslq %edx,%rdx
  400de3:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  400de7:	48 8d 70 08          	lea    0x8(%rax),%rsi
  400deb:	48 8d 95 fc f7 ff ff 	lea    -0x804(%rbp),%rdx
  400df2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400df5:	48 98                	cltq   
  400df7:	48 6b c0 64          	imul   $0x64,%rax,%rax
  400dfb:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  400dff:	48 8d 85 e8 f7 ff ff 	lea    -0x818(%rbp),%rax
  400e06:	48 89 c2             	mov    %rax,%rdx
  400e09:	48 89 cf             	mov    %rcx,%rdi
  400e0c:	e8 d9 1a 00 00       	callq  4028ea <execve>
  400e11:	89 45 d0             	mov    %eax,-0x30(%rbp)
				if(ret == -1)
  400e14:	83 7d d0 ff          	cmpl   $0xffffffff,-0x30(%rbp)
  400e18:	75 1a                	jne    400e34 <execute_cmd+0x389>
				{
					strerror(errno);
  400e1a:	48 8b 05 3f 37 20 00 	mov    0x20373f(%rip),%rax        # 604560 <chdir+0x2011f6>
  400e21:	8b 00                	mov    (%rax),%eax
  400e23:	89 c7                	mov    %eax,%edi
  400e25:	e8 dc 1d 00 00       	callq  402c06 <strerror>
					exit(1);
  400e2a:	bf 01 00 00 00       	mov    $0x1,%edi
  400e2f:	e8 82 1b 00 00       	callq  4029b6 <exit>
		{
			if(pipe(pipes+i*2) == -1)
				strerror(errno);
		}
		//printf("Multiple Commands");
		for(i=0; i<=info->pipeNum;i++)
  400e34:	ff 45 ec             	incl   -0x14(%rbp)
  400e37:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400e3e:	8b 40 50             	mov    0x50(%rax),%eax
  400e41:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  400e44:	0f 8d 3b fe ff ff    	jge    400c85 <execute_cmd+0x1da>
				}
			}
		}
		//printf("\nin multiple's parent\n");

		for(i=0;i<info->pipeNum;i++)
  400e4a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  400e51:	eb 3d                	jmp    400e90 <execute_cmd+0x3e5>
		{
			close(pipes[i*2]);
  400e53:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400e56:	48 98                	cltq   
  400e58:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  400e5f:	00 
  400e60:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400e64:	48 01 d0             	add    %rdx,%rax
  400e67:	8b 00                	mov    (%rax),%eax
  400e69:	89 c7                	mov    %eax,%edi
  400e6b:	e8 e4 10 00 00       	callq  401f54 <close>
			close(pipes[i*2+1]);
  400e70:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400e73:	48 98                	cltq   
  400e75:	48 c1 e0 03          	shl    $0x3,%rax
  400e79:	48 8d 50 04          	lea    0x4(%rax),%rdx
  400e7d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400e81:	48 01 d0             	add    %rdx,%rax
  400e84:	8b 00                	mov    (%rax),%eax
  400e86:	89 c7                	mov    %eax,%edi
  400e88:	e8 c7 10 00 00       	callq  401f54 <close>
				}
			}
		}
		//printf("\nin multiple's parent\n");

		for(i=0;i<info->pipeNum;i++)
  400e8d:	ff 45 ec             	incl   -0x14(%rbp)
  400e90:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400e97:	8b 40 50             	mov    0x50(%rax),%eax
  400e9a:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  400e9d:	7f b4                	jg     400e53 <execute_cmd+0x3a8>
			close(pipes[i*2+1]);
			//printf("closed");
		}
	}
	//printf("\nin singles's parent\n");
	for (i = 0; i <= info->pipeNum; i++)
  400e9f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  400ea6:	eb 2c                	jmp    400ed4 <execute_cmd+0x429>
		waitpid(proc_ids[i], &status, 0);
  400ea8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400eab:	48 98                	cltq   
  400ead:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400eb4:	00 
  400eb5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400eb9:	48 01 d0             	add    %rdx,%rax
  400ebc:	8b 00                	mov    (%rax),%eax
  400ebe:	48 8d 4d cc          	lea    -0x34(%rbp),%rcx
  400ec2:	ba 00 00 00 00       	mov    $0x0,%edx
  400ec7:	48 89 ce             	mov    %rcx,%rsi
  400eca:	89 c7                	mov    %eax,%edi
  400ecc:	e8 59 11 00 00       	callq  40202a <waitpid>
			close(pipes[i*2+1]);
			//printf("closed");
		}
	}
	//printf("\nin singles's parent\n");
	for (i = 0; i <= info->pipeNum; i++)
  400ed1:	ff 45 ec             	incl   -0x14(%rbp)
  400ed4:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400edb:	8b 40 50             	mov    0x50(%rax),%eax
  400ede:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  400ee1:	7d c5                	jge    400ea8 <execute_cmd+0x3fd>
		waitpid(proc_ids[i], &status, 0);
	//printf("child returned:%d\n",waitpid(proc_ids[i], &status, 0));

}
  400ee3:	48 81 c4 28 08 00 00 	add    $0x828,%rsp
  400eea:	5b                   	pop    %rbx
  400eeb:	5d                   	pop    %rbp
  400eec:	c3                   	retq   

0000000000400eed <find_file_in_dir>:




char* find_file_in_dir (char *path, char *file)
{
  400eed:	55                   	push   %rbp
  400eee:	48 89 e5             	mov    %rsp,%rbp
  400ef1:	48 83 ec 30          	sub    $0x30,%rsp
  400ef5:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  400ef9:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	struct dirent *entry=NULL;
  400efd:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  400f04:	00 
	char* ret = NULL;
  400f05:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  400f0c:	00 
	//ret=NULL;
	void *dir;
	dir = opendir (path);
  400f0d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400f11:	48 89 c7             	mov    %rax,%rdi
  400f14:	e8 41 18 00 00       	callq  40275a <opendir>
  400f19:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if(dir == NULL)
  400f1d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  400f22:	75 0a                	jne    400f2e <find_file_in_dir+0x41>
		return (char *)NULL;
  400f24:	b8 00 00 00 00       	mov    $0x0,%eax
  400f29:	e9 ae 00 00 00       	jmpq   400fdc <find_file_in_dir+0xef>

	errno = 0;
  400f2e:	48 8b 05 2b 36 20 00 	mov    0x20362b(%rip),%rax        # 604560 <chdir+0x2011f6>
  400f35:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	//printf("In find_file_in_dir....searching %s\n",path);
	while ((entry = readdir (dir)) != NULL) {
  400f3b:	eb 3e                	jmp    400f7b <find_file_in_dir+0x8e>
		//printf("entry->dname=%s file=%s",entry->d_name, file);
		if (!strcmp(entry->d_name, file)) {
  400f3d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  400f41:	48 8d 50 12          	lea    0x12(%rax),%rdx
  400f45:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  400f49:	48 89 c6             	mov    %rax,%rsi
  400f4c:	48 89 d7             	mov    %rdx,%rdi
  400f4f:	e8 12 1b 00 00       	callq  402a66 <strcmp>
  400f54:	85 c0                	test   %eax,%eax
  400f56:	75 23                	jne    400f7b <find_file_in_dir+0x8e>
			ret=malloc(sizeof(strlen(path)+1));
  400f58:	bf 04 00 00 00       	mov    $0x4,%edi
  400f5d:	e8 08 22 00 00       	callq  40316a <malloc>
  400f62:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			strcpy(ret,path);
  400f66:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  400f6a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  400f6e:	48 89 d6             	mov    %rdx,%rsi
  400f71:	48 89 c7             	mov    %rax,%rdi
  400f74:	e8 8e 1a 00 00       	callq  402a07 <strcpy>
			break;
  400f79:	eb 17                	jmp    400f92 <find_file_in_dir+0xa5>
	if(dir == NULL)
		return (char *)NULL;

	errno = 0;
	//printf("In find_file_in_dir....searching %s\n",path);
	while ((entry = readdir (dir)) != NULL) {
  400f7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400f7f:	48 89 c7             	mov    %rax,%rdi
  400f82:	e8 a8 0d 00 00       	callq  401d2f <readdir>
  400f87:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  400f8b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  400f90:	75 ab                	jne    400f3d <find_file_in_dir+0x50>
			ret=malloc(sizeof(strlen(path)+1));
			strcpy(ret,path);
			break;
		}
	}
	if (errno && !entry){
  400f92:	48 8b 05 c7 35 20 00 	mov    0x2035c7(%rip),%rax        # 604560 <chdir+0x2011f6>
  400f99:	8b 00                	mov    (%rax),%eax
  400f9b:	85 c0                	test   %eax,%eax
  400f9d:	74 17                	je     400fb6 <find_file_in_dir+0xc9>
  400f9f:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  400fa4:	75 10                	jne    400fb6 <find_file_in_dir+0xc9>
		strerror(errno);
  400fa6:	48 8b 05 b3 35 20 00 	mov    0x2035b3(%rip),%rax        # 604560 <chdir+0x2011f6>
  400fad:	8b 00                	mov    (%rax),%eax
  400faf:	89 c7                	mov    %eax,%edi
  400fb1:	e8 50 1c 00 00       	callq  402c06 <strerror>
	}

	if(closedir (dir) == -1){
  400fb6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400fba:	48 89 c7             	mov    %rax,%rdi
  400fbd:	e8 e0 10 00 00       	callq  4020a2 <closedir>
  400fc2:	83 f8 ff             	cmp    $0xffffffff,%eax
  400fc5:	75 11                	jne    400fd8 <find_file_in_dir+0xeb>

		printf("Fatal error. Could not close a directory\n");
  400fc7:	48 8d 3d 82 25 00 00 	lea    0x2582(%rip),%rdi        # 403550 <chdir+0x1e6>
  400fce:	b8 00 00 00 00       	mov    $0x0,%eax
  400fd3:	e8 24 13 00 00       	callq  4022fc <printf>

	}


	//printf("In find_file_in_dir....returning %s\n",ret);
	return ret;
  400fd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  400fdc:	c9                   	leaveq 
  400fdd:	c3                   	retq   

0000000000400fde <findBinaryFullPath>:


char* findBinaryFullPath(char* srchPath,char* binaryName){
  400fde:	55                   	push   %rbp
  400fdf:	48 89 e5             	mov    %rsp,%rbp
  400fe2:	48 83 ec 60          	sub    $0x60,%rsp
  400fe6:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  400fea:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	 * Else if none of the above are there then find the full path
	 *
	 */

	int i;
	char* x=NULL;
  400fee:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  400ff5:	00 
	//printf("In find full binary path\n");


	//printf("After strstr call. Search Path is :%s \n",srchPath);

	Token* dirToSearch = tokenize(srchPath,":");
  400ff6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  400ffa:	48 8d 35 79 25 00 00 	lea    0x2579(%rip),%rsi        # 40357a <chdir+0x210>
  401001:	48 89 c7             	mov    %rax,%rdi
  401004:	e8 e3 0a 00 00       	callq  401aec <tokenize>
  401009:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	//printf("After tokenize on : Number of tokens %d\n",dirToSearch->numOfTokens);

	for(i=0;i<dirToSearch->numOfTokens;i++){
  40100d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  401014:	eb 5d                	jmp    401073 <findBinaryFullPath+0x95>

		//printf("Calling find_file_in_dir token number %d of %d",i,dirToSearch->numOfTokens);
		//printf("\n\npath component 1 %s\n\n",dirToSearch->tokenArr[i]);
		strcpy(temp,dirToSearch->tokenArr[i]);
  401016:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40101a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  40101d:	48 63 d2             	movslq %edx,%rdx
  401020:	48 8b 54 d0 08       	mov    0x8(%rax,%rdx,8),%rdx
  401025:	48 8d 45 b6          	lea    -0x4a(%rbp),%rax
  401029:	48 89 d6             	mov    %rdx,%rsi
  40102c:	48 89 c7             	mov    %rax,%rdi
  40102f:	e8 d3 19 00 00       	callq  402a07 <strcpy>
		printf("\n\nBefore calling find_file_in_dir %s binary=%s\n",temp, binaryName	);
  401034:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  401038:	48 8d 45 b6          	lea    -0x4a(%rbp),%rax
  40103c:	48 89 c6             	mov    %rax,%rsi
  40103f:	48 8d 3d 3a 25 00 00 	lea    0x253a(%rip),%rdi        # 403580 <chdir+0x216>
  401046:	b8 00 00 00 00       	mov    $0x0,%eax
  40104b:	e8 ac 12 00 00       	callq  4022fc <printf>

		x=find_file_in_dir(temp,binaryName);
  401050:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  401054:	48 8d 45 b6          	lea    -0x4a(%rbp),%rax
  401058:	48 89 d6             	mov    %rdx,%rsi
  40105b:	48 89 c7             	mov    %rax,%rdi
  40105e:	e8 8a fe ff ff       	callq  400eed <find_file_in_dir>
  401063:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		if(x!=NULL){
  401067:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  40106c:	74 02                	je     401070 <findBinaryFullPath+0x92>

			break;
  40106e:	eb 0e                	jmp    40107e <findBinaryFullPath+0xa0>

	Token* dirToSearch = tokenize(srchPath,":");

	//printf("After tokenize on : Number of tokens %d\n",dirToSearch->numOfTokens);

	for(i=0;i<dirToSearch->numOfTokens;i++){
  401070:	ff 45 fc             	incl   -0x4(%rbp)
  401073:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401077:	8b 00                	mov    (%rax),%eax
  401079:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  40107c:	7f 98                	jg     401016 <findBinaryFullPath+0x38>

		}
	}


	return x;
  40107e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax


}
  401082:	c9                   	leaveq 
  401083:	c3                   	retq   

0000000000401084 <findEnvVar>:
#include <parser.h>
#include <errno.h>
#include <string.h>
#include <shell.h>

char** findEnvVar(char* envVar, char* envp[]){
  401084:	55                   	push   %rbp
  401085:	48 89 e5             	mov    %rsp,%rbp
  401088:	48 83 ec 20          	sub    $0x20,%rsp
  40108c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401090:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	 * envVar in the evnp[]. It returns a pointer, which is a pointer to the array
	 * envp[] that contains a the pointer to the envVar string.
	 * If not found returns null.
	 */

	int count=0;
  401094:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	Token* tokens;

	//printf("Inside findEnv var\n");
    
	while(envp[count]!= NULL){
  40109b:	eb 6a                	jmp    401107 <findEnvVar+0x83>

		tokens = tokenize(envp[count],"=");
  40109d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4010a0:	48 98                	cltq   
  4010a2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  4010a9:	00 
  4010aa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4010ae:	48 01 d0             	add    %rdx,%rax
  4010b1:	48 8b 00             	mov    (%rax),%rax
  4010b4:	48 8d 35 f5 24 00 00 	lea    0x24f5(%rip),%rsi        # 4035b0 <chdir+0x246>
  4010bb:	48 89 c7             	mov    %rax,%rdi
  4010be:	e8 29 0a 00 00       	callq  401aec <tokenize>
  4010c3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		//printf("%s\n",envp[count]);

		if(strcmp(tokens->tokenArr[0],envVar)==0){
  4010c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4010cb:	48 8b 40 08          	mov    0x8(%rax),%rax
  4010cf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  4010d3:	48 89 d6             	mov    %rdx,%rsi
  4010d6:	48 89 c7             	mov    %rax,%rdi
  4010d9:	e8 88 19 00 00       	callq  402a66 <strcmp>
  4010de:	85 c0                	test   %eax,%eax
  4010e0:	75 16                	jne    4010f8 <findEnvVar+0x74>
			return(envp+count);
  4010e2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4010e5:	48 98                	cltq   
  4010e7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  4010ee:	00 
  4010ef:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4010f3:	48 01 d0             	add    %rdx,%rax
  4010f6:	eb 34                	jmp    40112c <findEnvVar+0xa8>
		}
		free(tokens);
  4010f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4010fc:	48 89 c7             	mov    %rax,%rdi
  4010ff:	e8 d3 21 00 00       	callq  4032d7 <free>
		count++;
  401104:	ff 45 fc             	incl   -0x4(%rbp)
	int count=0;
	Token* tokens;

	//printf("Inside findEnv var\n");
    
	while(envp[count]!= NULL){
  401107:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40110a:	48 98                	cltq   
  40110c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  401113:	00 
  401114:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  401118:	48 01 d0             	add    %rdx,%rax
  40111b:	48 8b 00             	mov    (%rax),%rax
  40111e:	48 85 c0             	test   %rax,%rax
  401121:	0f 85 76 ff ff ff    	jne    40109d <findEnvVar+0x19>
			return(envp+count);
		}
		free(tokens);
		count++;
	}
	return (char**)NULL;
  401127:	b8 00 00 00 00       	mov    $0x0,%eax
}
  40112c:	c9                   	leaveq 
  40112d:	c3                   	retq   

000000000040112e <main1>:
#include <stdio.h>

int main1(int argc, char* argv[], char* envp[]) {
  40112e:	55                   	push   %rbp
  40112f:	48 89 e5             	mov    %rsp,%rbp
  401132:	48 83 ec 20          	sub    $0x20,%rsp
  401136:	89 7d fc             	mov    %edi,-0x4(%rbp)
  401139:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  40113d:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	printf("Hello World!\n");
  401141:	48 8d 3d 6a 24 00 00 	lea    0x246a(%rip),%rdi        # 4035b2 <chdir+0x248>
  401148:	b8 00 00 00 00       	mov    $0x0,%eax
  40114d:	e8 aa 11 00 00       	callq  4022fc <printf>
	return 0;
  401152:	b8 00 00 00 00       	mov    $0x0,%eax
}
  401157:	c9                   	leaveq 
  401158:	c3                   	retq   

0000000000401159 <print_info>:
#include <shell.h>




void print_info (parseInfo *info) {
  401159:	55                   	push   %rbp
  40115a:	48 89 e5             	mov    %rsp,%rbp
  40115d:	48 83 ec 20          	sub    $0x20,%rsp
  401161:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	printf("print_info: printing info about parseInfo struct\n");
  401165:	48 8d 3d 54 24 00 00 	lea    0x2454(%rip),%rdi        # 4035c0 <chdir+0x256>
  40116c:	b8 00 00 00 00       	mov    $0x0,%eax
  401171:	e8 86 11 00 00       	callq  4022fc <printf>
	//printf("Number of pipe separated commands %d\n",info->pipeNum);


	int i,j;

	for(i=0;i<=info->pipeNum;i++){
  401176:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  40117d:	eb 25                	jmp    4011a4 <print_info+0x4b>
		//printf("Command Name : %s\n",info->CommArray[i]->commandName);

		//printf("Command Arguments :\n");
		//printf("Number of arguments %d\n",info->CommArray[i]->VarNum);

		for(j=0;j<info->CommArray[i]->VarNum;j++){
  40117f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  401186:	eb 03                	jmp    40118b <print_info+0x32>
  401188:	ff 45 f8             	incl   -0x8(%rbp)
  40118b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40118f:	8b 55 fc             	mov    -0x4(%rbp),%edx
  401192:	48 63 d2             	movslq %edx,%rdx
  401195:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  401199:	8b 40 58             	mov    0x58(%rax),%eax
  40119c:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  40119f:	7f e7                	jg     401188 <print_info+0x2f>
	//printf("Number of pipe separated commands %d\n",info->pipeNum);


	int i,j;

	for(i=0;i<=info->pipeNum;i++){
  4011a1:	ff 45 fc             	incl   -0x4(%rbp)
  4011a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4011a8:	8b 40 50             	mov    0x50(%rax),%eax
  4011ab:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  4011ae:	7d cf                	jge    40117f <print_info+0x26>
			//printf("Argument %d : %s \n", j,info->CommArray[i]->VarList[j]);
		}

	}

	return;
  4011b0:	90                   	nop
}
  4011b1:	c9                   	leaveq 
  4011b2:	c3                   	retq   

00000000004011b3 <free_info>:

void free_info (parseInfo *info) {
  4011b3:	55                   	push   %rbp
  4011b4:	48 89 e5             	mov    %rsp,%rbp
  4011b7:	48 83 ec 10          	sub    $0x10,%rsp
  4011bb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	//printf("free_info: freeing memory associated to parseInfo struct\n");
	free(info);
  4011bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4011c3:	48 89 c7             	mov    %rax,%rdi
  4011c6:	e8 0c 21 00 00       	callq  4032d7 <free>
}
  4011cb:	c9                   	leaveq 
  4011cc:	c3                   	retq   

00000000004011cd <parseModified>:

parseInfo* parseModified(char *cmd,char* envp[]){
  4011cd:	55                   	push   %rbp
  4011ce:	48 89 e5             	mov    %rsp,%rbp
  4011d1:	48 81 ec 40 02 00 00 	sub    $0x240,%rsp
  4011d8:	48 89 bd c8 fd ff ff 	mov    %rdi,-0x238(%rbp)
  4011df:	48 89 b5 c0 fd ff ff 	mov    %rsi,-0x240(%rbp)

	parseInfo *Result;
	Token* tokenPipe;
	Token* tokenSpace;
	//Token* path;
	singleCommand* sc = NULL;
  4011e6:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  4011ed:	00 
//	char** envVar=NULL;
	char *fullPath=NULL;
  4011ee:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  4011f5:	00 
	int i=0,j=0;
  4011f6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  4011fd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	char srchPath[500];
	//printf("In PARSE MODIFIED");
	Result = (parseInfo*)malloc(sizeof(parseInfo));
  401204:	bf 58 00 00 00       	mov    $0x58,%edi
  401209:	e8 5c 1f 00 00       	callq  40316a <malloc>
  40120e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

//	envVar=findEnvVar("PATH",envp);
    //envVar[0]="PATH=/bin";
	printf("In parser... full PATH= %s\n\n",cmd);
  401212:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  401219:	48 89 c6             	mov    %rax,%rsi
  40121c:	48 8d 3d cf 23 00 00 	lea    0x23cf(%rip),%rdi        # 4035f2 <chdir+0x288>
  401223:	b8 00 00 00 00       	mov    $0x0,%eax
  401228:	e8 cf 10 00 00       	callq  4022fc <printf>
//		printf("PATH is ---> %s",path->tokenArr[1]);

    

	//strcpy(srchPath,path->tokenArr[1]);
	strcpy(srchPath,"/bin");
  40122d:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  401234:	48 8d 35 d4 23 00 00 	lea    0x23d4(%rip),%rsi        # 40360f <chdir+0x2a5>
  40123b:	48 89 c7             	mov    %rax,%rdi
  40123e:	e8 c4 17 00 00       	callq  402a07 <strcpy>

	printf("Seatch PAth is %s",srchPath);
  401243:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  40124a:	48 89 c6             	mov    %rax,%rsi
  40124d:	48 8d 3d c0 23 00 00 	lea    0x23c0(%rip),%rdi        # 403614 <chdir+0x2aa>
  401254:	b8 00 00 00 00       	mov    $0x0,%eax
  401259:	e8 9e 10 00 00       	callq  4022fc <printf>

	tokenPipe = tokenize(cmd,"|");
  40125e:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  401265:	48 8d 35 ba 23 00 00 	lea    0x23ba(%rip),%rsi        # 403626 <chdir+0x2bc>
  40126c:	48 89 c7             	mov    %rax,%rdi
  40126f:	e8 78 08 00 00       	callq  401aec <tokenize>
  401274:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	printf("In PARSE MODIFIED%d\n",tokenPipe->numOfTokens);
  401278:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40127c:	8b 00                	mov    (%rax),%eax
  40127e:	89 c6                	mov    %eax,%esi
  401280:	48 8d 3d a1 23 00 00 	lea    0x23a1(%rip),%rdi        # 403628 <chdir+0x2be>
  401287:	b8 00 00 00 00       	mov    $0x0,%eax
  40128c:	e8 6b 10 00 00       	callq  4022fc <printf>
	for(i=0;i<tokenPipe->numOfTokens;i++){
  401291:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  401298:	e9 14 02 00 00       	jmpq   4014b1 <parseModified+0x2e4>

		//for each pipe separated token find space separated tokens
		tokenSpace=tokenize(tokenPipe->tokenArr[i]," ");
  40129d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4012a1:	8b 55 fc             	mov    -0x4(%rbp),%edx
  4012a4:	48 63 d2             	movslq %edx,%rdx
  4012a7:	48 8b 44 d0 08       	mov    0x8(%rax,%rdx,8),%rax
  4012ac:	48 8d 35 8a 23 00 00 	lea    0x238a(%rip),%rsi        # 40363d <chdir+0x2d3>
  4012b3:	48 89 c7             	mov    %rax,%rdi
  4012b6:	e8 31 08 00 00       	callq  401aec <tokenize>
  4012bb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

		//initialize the singleCommand Structure
		sc = (singleCommand*)malloc(sizeof(singleCommand));
  4012bf:	bf 60 00 00 00       	mov    $0x60,%edi
  4012c4:	e8 a1 1e 00 00       	callq  40316a <malloc>
  4012c9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		sc->commandName=(char*)malloc(100);
  4012cd:	bf 64 00 00 00       	mov    $0x64,%edi
  4012d2:	e8 93 1e 00 00       	callq  40316a <malloc>
  4012d7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  4012db:	48 89 02             	mov    %rax,(%rdx)
		sc->commandName[0]='\0';
  4012de:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4012e2:	48 8b 00             	mov    (%rax),%rax
  4012e5:	c6 00 00             	movb   $0x0,(%rax)
		printf("Before find full binary path\n\n\n");
  4012e8:	48 8d 3d 51 23 00 00 	lea    0x2351(%rip),%rdi        # 403640 <chdir+0x2d6>
  4012ef:	b8 00 00 00 00       	mov    $0x0,%eax
  4012f4:	e8 03 10 00 00       	callq  4022fc <printf>
		sc->commandName=tokenSpace->tokenArr[0];
  4012f9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4012fd:	48 8b 50 08          	mov    0x8(%rax),%rdx
  401301:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401305:	48 89 10             	mov    %rdx,(%rax)
		if(strcmp(tokenSpace->tokenArr[0],"set") && strcmp(tokenSpace->tokenArr[0],"cd") && strcmp(tokenSpace->tokenArr[0],"exit") )
  401308:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40130c:	48 8b 40 08          	mov    0x8(%rax),%rax
  401310:	48 8d 35 49 23 00 00 	lea    0x2349(%rip),%rsi        # 403660 <chdir+0x2f6>
  401317:	48 89 c7             	mov    %rax,%rdi
  40131a:	e8 47 17 00 00       	callq  402a66 <strcmp>
  40131f:	85 c0                	test   %eax,%eax
  401321:	0f 84 05 01 00 00    	je     40142c <parseModified+0x25f>
  401327:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40132b:	48 8b 40 08          	mov    0x8(%rax),%rax
  40132f:	48 8d 35 2e 23 00 00 	lea    0x232e(%rip),%rsi        # 403664 <chdir+0x2fa>
  401336:	48 89 c7             	mov    %rax,%rdi
  401339:	e8 28 17 00 00       	callq  402a66 <strcmp>
  40133e:	85 c0                	test   %eax,%eax
  401340:	0f 84 e6 00 00 00    	je     40142c <parseModified+0x25f>
  401346:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40134a:	48 8b 40 08          	mov    0x8(%rax),%rax
  40134e:	48 8d 35 12 23 00 00 	lea    0x2312(%rip),%rsi        # 403667 <chdir+0x2fd>
  401355:	48 89 c7             	mov    %rax,%rdi
  401358:	e8 09 17 00 00       	callq  402a66 <strcmp>
  40135d:	85 c0                	test   %eax,%eax
  40135f:	0f 84 c7 00 00 00    	je     40142c <parseModified+0x25f>
		{
			printf("Loop %d cmd: %s\n\n",i,tokenSpace->tokenArr[0] );
  401365:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401369:	48 8b 50 08          	mov    0x8(%rax),%rdx
  40136d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401370:	89 c6                	mov    %eax,%esi
  401372:	48 8d 3d f3 22 00 00 	lea    0x22f3(%rip),%rdi        # 40366c <chdir+0x302>
  401379:	b8 00 00 00 00       	mov    $0x0,%eax
  40137e:	e8 79 0f 00 00       	callq  4022fc <printf>

			if(strstr(tokenSpace->tokenArr[0],"/")==NULL){
  401383:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401387:	48 8b 40 08          	mov    0x8(%rax),%rax
  40138b:	48 8d 35 ec 22 00 00 	lea    0x22ec(%rip),%rsi        # 40367e <chdir+0x314>
  401392:	48 89 c7             	mov    %rax,%rdi
  401395:	e8 53 17 00 00       	callq  402aed <strstr>
  40139a:	48 85 c0             	test   %rax,%rax
  40139d:	0f 85 89 00 00 00    	jne    40142c <parseModified+0x25f>

				fullPath=findBinaryFullPath(srchPath,tokenSpace->tokenArr[0]);
  4013a3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4013a7:	48 8b 50 08          	mov    0x8(%rax),%rdx
  4013ab:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  4013b2:	48 89 d6             	mov    %rdx,%rsi
  4013b5:	48 89 c7             	mov    %rax,%rdi
  4013b8:	e8 21 fc ff ff       	callq  400fde <findBinaryFullPath>
  4013bd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				if(fullPath==NULL)
  4013c1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  4013c6:	75 1b                	jne    4013e3 <parseModified+0x216>
				{
					printf("Error:Command Not found.\n");
  4013c8:	48 8d 3d b1 22 00 00 	lea    0x22b1(%rip),%rdi        # 403680 <chdir+0x316>
  4013cf:	b8 00 00 00 00       	mov    $0x0,%eax
  4013d4:	e8 23 0f 00 00       	callq  4022fc <printf>
					return NULL;
  4013d9:	b8 00 00 00 00       	mov    $0x0,%eax
  4013de:	e9 f1 00 00 00       	jmpq   4014d4 <parseModified+0x307>
				}
				sc->commandName = fullPath;
  4013e3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4013e7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  4013eb:	48 89 10             	mov    %rdx,(%rax)
				sc->commandName = strcat(sc->commandName,"/");
  4013ee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4013f2:	48 8b 00             	mov    (%rax),%rax
  4013f5:	48 8d 35 82 22 00 00 	lea    0x2282(%rip),%rsi        # 40367e <chdir+0x314>
  4013fc:	48 89 c7             	mov    %rax,%rdi
  4013ff:	e8 c7 17 00 00       	callq  402bcb <strcat>
  401404:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  401408:	48 89 02             	mov    %rax,(%rdx)
				sc->commandName = strcat(sc->commandName,tokenSpace->tokenArr[0]);
  40140b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40140f:	48 8b 50 08          	mov    0x8(%rax),%rdx
  401413:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401417:	48 8b 00             	mov    (%rax),%rax
  40141a:	48 89 d6             	mov    %rdx,%rsi
  40141d:	48 89 c7             	mov    %rax,%rdi
  401420:	e8 a6 17 00 00       	callq  402bcb <strcat>
  401425:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  401429:	48 89 02             	mov    %rax,(%rdx)
		}

		//printf("In parser..fullpath for %s is %s\n",tokenSpace->tokenArr[0],fullPath);


		printf("COMMAND NAME=%s\n",sc->commandName);
  40142c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401430:	48 8b 00             	mov    (%rax),%rax
  401433:	48 89 c6             	mov    %rax,%rsi
  401436:	48 8d 3d 5d 22 00 00 	lea    0x225d(%rip),%rdi        # 40369a <chdir+0x330>
  40143d:	b8 00 00 00 00       	mov    $0x0,%eax
  401442:	e8 b5 0e 00 00       	callq  4022fc <printf>
		//sc->VarList[0]=fullPath;
		sc->VarNum = tokenSpace->numOfTokens;
  401447:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40144b:	8b 10                	mov    (%rax),%edx
  40144d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401451:	89 50 58             	mov    %edx,0x58(%rax)
		for(j=0;j<tokenSpace->numOfTokens;j++){
  401454:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  40145b:	eb 21                	jmp    40147e <parseModified+0x2b1>
			sc->VarList[j]=tokenSpace->tokenArr[j];
  40145d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401461:	8b 55 f8             	mov    -0x8(%rbp),%edx
  401464:	48 63 d2             	movslq %edx,%rdx
  401467:	48 8b 4c d0 08       	mov    0x8(%rax,%rdx,8),%rcx
  40146c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401470:	8b 55 f8             	mov    -0x8(%rbp),%edx
  401473:	48 63 d2             	movslq %edx,%rdx
  401476:	48 89 4c d0 08       	mov    %rcx,0x8(%rax,%rdx,8)


		printf("COMMAND NAME=%s\n",sc->commandName);
		//sc->VarList[0]=fullPath;
		sc->VarNum = tokenSpace->numOfTokens;
		for(j=0;j<tokenSpace->numOfTokens;j++){
  40147b:	ff 45 f8             	incl   -0x8(%rbp)
  40147e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401482:	8b 00                	mov    (%rax),%eax
  401484:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  401487:	7f d4                	jg     40145d <parseModified+0x290>
			sc->VarList[j]=tokenSpace->tokenArr[j];
		}
		sc->VarList[j]=NULL;
  401489:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40148d:	8b 55 f8             	mov    -0x8(%rbp),%edx
  401490:	48 63 d2             	movslq %edx,%rdx
  401493:	48 c7 44 d0 08 00 00 	movq   $0x0,0x8(%rax,%rdx,8)
  40149a:	00 00 

		Result->CommArray[i]=sc;
  40149c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4014a0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  4014a3:	48 63 d2             	movslq %edx,%rdx
  4014a6:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  4014aa:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
	printf("Seatch PAth is %s",srchPath);

	tokenPipe = tokenize(cmd,"|");

	printf("In PARSE MODIFIED%d\n",tokenPipe->numOfTokens);
	for(i=0;i<tokenPipe->numOfTokens;i++){
  4014ae:	ff 45 fc             	incl   -0x4(%rbp)
  4014b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4014b5:	8b 00                	mov    (%rax),%eax
  4014b7:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  4014ba:	0f 8f dd fd ff ff    	jg     40129d <parseModified+0xd0>

		Result->CommArray[i]=sc;

	}

	Result->pipeNum=tokenPipe->numOfTokens-1; //set the number of pipe separated commands
  4014c0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4014c4:	8b 00                	mov    (%rax),%eax
  4014c6:	8d 50 ff             	lea    -0x1(%rax),%edx
  4014c9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4014cd:	89 50 50             	mov    %edx,0x50(%rax)

	return Result;
  4014d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  4014d4:	c9                   	leaveq 
  4014d5:	c3                   	retq   

00000000004014d6 <read_line>:

int read_line(int fd, char* buf)
{
  4014d6:	55                   	push   %rbp
  4014d7:	48 89 e5             	mov    %rsp,%rbp
  4014da:	48 83 ec 10          	sub    $0x10,%rsp
  4014de:	89 7d fc             	mov    %edi,-0x4(%rbp)
  4014e1:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
		//printf("read: %c ",*byte);
		if (ret == -1)
			return -1;
	}
	*(byte-1)='\0';*/
    read(0,buf,MAXLINE);
  4014e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4014e9:	ba 00 01 00 00       	mov    $0x100,%edx
  4014ee:	48 89 c6             	mov    %rax,%rsi
  4014f1:	bf 00 00 00 00       	mov    $0x0,%edi
  4014f6:	e8 eb 12 00 00       	callq  4027e6 <read>
	return 1;
  4014fb:	b8 01 00 00 00       	mov    $0x1,%eax
}
  401500:	c9                   	leaveq 
  401501:	c3                   	retq   

0000000000401502 <changePS1>:
#include <parser.h>
#include <errno.h>
#include <string.h>
#include <shell.h>

void changePS1(char*str){
  401502:	55                   	push   %rbp
  401503:	48 89 e5             	mov    %rsp,%rbp
  401506:	48 83 ec 20          	sub    $0x20,%rsp
  40150a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	 * The PS1 is a shell variable
	 *
	 */

	Token* tokenEqulas;
	tokenEqulas = tokenize(str,"=");
  40150e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401512:	48 8d 35 97 21 00 00 	lea    0x2197(%rip),%rsi        # 4036b0 <chdir+0x346>
  401519:	48 89 c7             	mov    %rax,%rdi
  40151c:	e8 cb 05 00 00       	callq  401aec <tokenize>
  401521:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	//printf("no:%d\n\n",tokenEqulas->numOfTokens);

	if(tokenEqulas->numOfTokens < 2)
  401525:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401529:	8b 00                	mov    (%rax),%eax
  40152b:	83 f8 01             	cmp    $0x1,%eax
  40152e:	7f 13                	jg     401543 <changePS1+0x41>
	{
		printf("Error:Invalid PS1\n");
  401530:	48 8d 3d 7b 21 00 00 	lea    0x217b(%rip),%rdi        # 4036b2 <chdir+0x348>
  401537:	b8 00 00 00 00       	mov    $0x0,%eax
  40153c:	e8 bb 0d 00 00       	callq  4022fc <printf>
  401541:	eb 5d                	jmp    4015a0 <changePS1+0x9e>
	}
	else if(strlen(tokenEqulas->tokenArr[1])>100){
  401543:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401547:	48 8b 40 10          	mov    0x10(%rax),%rax
  40154b:	48 89 c7             	mov    %rax,%rdi
  40154e:	e8 7f 14 00 00       	callq  4029d2 <strlen>
  401553:	83 f8 64             	cmp    $0x64,%eax
  401556:	7e 13                	jle    40156b <changePS1+0x69>
		printf("Too long a prompt name.Pleasee try again\n");
  401558:	48 8d 3d 69 21 00 00 	lea    0x2169(%rip),%rdi        # 4036c8 <chdir+0x35e>
  40155f:	b8 00 00 00 00       	mov    $0x0,%eax
  401564:	e8 93 0d 00 00       	callq  4022fc <printf>
  401569:	eb 35                	jmp    4015a0 <changePS1+0x9e>
	}


	else{

		strcpy(PS1,tokenEqulas->tokenArr[1]);
  40156b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40156f:	48 8b 40 10          	mov    0x10(%rax),%rax
  401573:	48 89 c6             	mov    %rax,%rsi
  401576:	48 8d 05 23 30 20 00 	lea    0x203023(%rip),%rax        # 6045a0 <PS1>
  40157d:	48 89 c7             	mov    %rax,%rdi
  401580:	e8 82 14 00 00       	callq  402a07 <strcpy>
		printf("PS1 after change %s\n",PS1);
  401585:	48 8d 05 14 30 20 00 	lea    0x203014(%rip),%rax        # 6045a0 <PS1>
  40158c:	48 89 c6             	mov    %rax,%rsi
  40158f:	48 8d 3d 5c 21 00 00 	lea    0x215c(%rip),%rdi        # 4036f2 <chdir+0x388>
  401596:	b8 00 00 00 00       	mov    $0x0,%eax
  40159b:	e8 5c 0d 00 00       	callq  4022fc <printf>
	}

}
  4015a0:	c9                   	leaveq 
  4015a1:	c3                   	retq   

00000000004015a2 <removeSpaces>:
#include<stdio.h>
#include<string.h>
#include<stdlib.h>


char* removeSpaces(char*str){
  4015a2:	55                   	push   %rbp
  4015a3:	48 89 e5             	mov    %rsp,%rbp
  4015a6:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  4015ad:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
	/*
	 * This function removes spaces from str without modifying it
	 * The string returned must be malloced
	 */

	int i=0,j=0;
  4015b4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  4015bb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	char *noSpaceStr=NULL;
  4015c2:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  4015c9:	00 
	char temp[100];


	for(i=0;i<strlen(str);i++){
  4015ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  4015d1:	eb 3c                	jmp    40160f <removeSpaces+0x6d>

		if(str[i]!=' '){
  4015d3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4015d6:	48 63 d0             	movslq %eax,%rdx
  4015d9:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  4015e0:	48 01 d0             	add    %rdx,%rax
  4015e3:	0f b6 00             	movzbl (%rax),%eax
  4015e6:	3c 20                	cmp    $0x20,%al
  4015e8:	74 22                	je     40160c <removeSpaces+0x6a>
			temp[j++]=str[i];
  4015ea:	8b 45 f8             	mov    -0x8(%rbp),%eax
  4015ed:	8d 50 01             	lea    0x1(%rax),%edx
  4015f0:	89 55 f8             	mov    %edx,-0x8(%rbp)
  4015f3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  4015f6:	48 63 ca             	movslq %edx,%rcx
  4015f9:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  401600:	48 01 ca             	add    %rcx,%rdx
  401603:	0f b6 12             	movzbl (%rdx),%edx
  401606:	48 98                	cltq   
  401608:	88 54 05 8c          	mov    %dl,-0x74(%rbp,%rax,1)
	int i=0,j=0;
	char *noSpaceStr=NULL;
	char temp[100];


	for(i=0;i<strlen(str);i++){
  40160c:	ff 45 fc             	incl   -0x4(%rbp)
  40160f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  401616:	48 89 c7             	mov    %rax,%rdi
  401619:	e8 b4 13 00 00       	callq  4029d2 <strlen>
  40161e:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  401621:	7f b0                	jg     4015d3 <removeSpaces+0x31>
		if(str[i]!=' '){
			temp[j++]=str[i];
		}

	}
	temp[j]='\0';
  401623:	8b 45 f8             	mov    -0x8(%rbp),%eax
  401626:	48 98                	cltq   
  401628:	c6 44 05 8c 00       	movb   $0x0,-0x74(%rbp,%rax,1)

	noSpaceStr = malloc(sizeof(char)*(strlen(temp)));
  40162d:	48 8d 45 8c          	lea    -0x74(%rbp),%rax
  401631:	48 89 c7             	mov    %rax,%rdi
  401634:	e8 99 13 00 00       	callq  4029d2 <strlen>
  401639:	48 98                	cltq   
  40163b:	48 89 c7             	mov    %rax,%rdi
  40163e:	e8 27 1b 00 00       	callq  40316a <malloc>
  401643:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	strcpy(noSpaceStr,temp);
  401647:	48 8d 55 8c          	lea    -0x74(%rbp),%rdx
  40164b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40164f:	48 89 d6             	mov    %rdx,%rsi
  401652:	48 89 c7             	mov    %rax,%rdi
  401655:	e8 ad 13 00 00       	callq  402a07 <strcpy>

	return noSpaceStr;
  40165a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax

}
  40165e:	c9                   	leaveq 
  40165f:	c3                   	retq   

0000000000401660 <parallel_fork>:
#include <stdlib.h>
#include <test.h>
#include <errno.h>
#include <string.h>

void parallel_fork(){
  401660:	55                   	push   %rbp
  401661:	48 89 e5             	mov    %rsp,%rbp


    //int *pipe = (int*)malloc(4*sizeof(int));


}
  401664:	5d                   	pop    %rbp
  401665:	c3                   	retq   

0000000000401666 <main11>:
int main11(int argc, char* argv[], char* envp[])
{
  401666:	55                   	push   %rbp
  401667:	48 89 e5             	mov    %rsp,%rbp
  40166a:	48 83 ec 40          	sub    $0x40,%rsp
  40166e:	89 7d dc             	mov    %edi,-0x24(%rbp)
  401671:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  401675:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
//    parallel_fork();
    int pid[tot] ;

    int i;
    int p;
    int status=(uint64_t)&p;
  401679:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  40167d:	89 45 ec             	mov    %eax,-0x14(%rbp)

    for(i=0;i<tot;i++){
  401680:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  401687:	eb 36                	jmp    4016bf <main11+0x59>


        pid[i] = fork();
  401689:	e8 bd 12 00 00       	callq  40294b <fork>
  40168e:	89 c2                	mov    %eax,%edx
  401690:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401693:	48 98                	cltq   
  401695:	89 54 85 f4          	mov    %edx,-0xc(%rbp,%rax,4)

       if(pid[i] == 0){
  401699:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40169c:	48 98                	cltq   
  40169e:	8b 44 85 f4          	mov    -0xc(%rbp,%rax,4),%eax
  4016a2:	85 c0                	test   %eax,%eax
  4016a4:	75 16                	jne    4016bc <main11+0x56>

            execve("/bin/malluaunty",NULL,NULL);
  4016a6:	ba 00 00 00 00       	mov    $0x0,%edx
  4016ab:	be 00 00 00 00       	mov    $0x0,%esi
  4016b0:	48 8d 3d 50 20 00 00 	lea    0x2050(%rip),%rdi        # 403707 <chdir+0x39d>
  4016b7:	e8 2e 12 00 00       	callq  4028ea <execve>

    int i;
    int p;
    int status=(uint64_t)&p;

    for(i=0;i<tot;i++){
  4016bc:	ff 45 fc             	incl   -0x4(%rbp)
  4016bf:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  4016c3:	7e c4                	jle    401689 <main11+0x23>
            execve("/bin/malluaunty",NULL,NULL);

        }

      }
    status=status;
  4016c5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  4016c8:	89 45 ec             	mov    %eax,-0x14(%rbp)
     for(i=0;i<tot;i++)
  4016cb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  4016d2:	eb 3a                	jmp    40170e <main11+0xa8>
     {
         printf("chpid[%d]= %d",0,pid[0]);
  4016d4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  4016d7:	89 c2                	mov    %eax,%edx
  4016d9:	be 00 00 00 00       	mov    $0x0,%esi
  4016de:	48 8d 3d 32 20 00 00 	lea    0x2032(%rip),%rdi        # 403717 <chdir+0x3ad>
  4016e5:	b8 00 00 00 00       	mov    $0x0,%eax
  4016ea:	e8 0d 0c 00 00       	callq  4022fc <printf>
         waitpid(pid[i],&status,0);
  4016ef:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4016f2:	48 98                	cltq   
  4016f4:	8b 44 85 f4          	mov    -0xc(%rbp,%rax,4),%eax
  4016f8:	48 8d 4d ec          	lea    -0x14(%rbp),%rcx
  4016fc:	ba 00 00 00 00       	mov    $0x0,%edx
  401701:	48 89 ce             	mov    %rcx,%rsi
  401704:	89 c7                	mov    %eax,%edi
  401706:	e8 1f 09 00 00       	callq  40202a <waitpid>

        }

      }
    status=status;
     for(i=0;i<tot;i++)
  40170b:	ff 45 fc             	incl   -0x4(%rbp)
  40170e:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  401712:	7e c0                	jle    4016d4 <main11+0x6e>
     {
         printf("chpid[%d]= %d",0,pid[0]);
         waitpid(pid[i],&status,0);
   }
printf("\n***PARENT EXITNG***\n");
  401714:	48 8d 3d 0a 20 00 00 	lea    0x200a(%rip),%rdi        # 403725 <chdir+0x3bb>
  40171b:	b8 00 00 00 00       	mov    $0x0,%eax
  401720:	e8 d7 0b 00 00       	callq  4022fc <printf>

return 0;
  401725:	b8 00 00 00 00       	mov    $0x0,%eax
}
  40172a:	c9                   	leaveq 
  40172b:	c3                   	retq   

000000000040172c <main>:


char PS1[200]="SBUSH";

int main (int argc, char *argv[], char* envp[])
{
  40172c:	55                   	push   %rbp
  40172d:	48 89 e5             	mov    %rsp,%rbp
  401730:	48 81 ec 50 01 00 00 	sub    $0x150,%rsp
  401737:	89 bd cc fe ff ff    	mov    %edi,-0x134(%rbp)
  40173d:	48 89 b5 c0 fe ff ff 	mov    %rsi,-0x140(%rbp)
  401744:	48 89 95 b8 fe ff ff 	mov    %rdx,-0x148(%rbp)


	char cmdLine[MAXLINE];


	int fd=0,ret;
  40174b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	//char x[10] ="akshay";
	parseInfo *info; //info stores all the information returned by parser.
	//printf("Akshay Kale %s, \n",x);
	//exit(0);

	if(argv[1]!=NULL)
  401752:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
  401759:	48 83 c0 08          	add    $0x8,%rax
  40175d:	48 8b 00             	mov    (%rax),%rax
  401760:	48 85 c0             	test   %rax,%rax
  401763:	74 1e                	je     401783 <main+0x57>
	{
		//printf("executing script");
		fd=open(argv[1],0);
  401765:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
  40176c:	48 83 c0 08          	add    $0x8,%rax
  401770:	48 8b 00             	mov    (%rax),%rax
  401773:	be 00 00 00 00       	mov    $0x0,%esi
  401778:	48 89 c7             	mov    %rax,%rdi
  40177b:	e8 eb 06 00 00       	callq  401e6b <open>
  401780:	89 45 fc             	mov    %eax,-0x4(%rbp)

	while(1)
	{
		//cmdLine = "Santosh 1 2 3 | ls -l";

		if(argv[1] == NULL)
  401783:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
  40178a:	48 83 c0 08          	add    $0x8,%rax
  40178e:	48 8b 00             	mov    (%rax),%rax
  401791:	48 85 c0             	test   %rax,%rax
  401794:	75 1d                	jne    4017b3 <main+0x87>
		{
			printf("%s> ",PS1);
  401796:	48 8d 05 03 2e 20 00 	lea    0x202e03(%rip),%rax        # 6045a0 <PS1>
  40179d:	48 89 c6             	mov    %rax,%rsi
  4017a0:	48 8d 3d 94 1f 00 00 	lea    0x1f94(%rip),%rdi        # 40373b <chdir+0x3d1>
  4017a7:	b8 00 00 00 00       	mov    $0x0,%eax
  4017ac:	e8 4b 0b 00 00       	callq  4022fc <printf>
  4017b1:	eb 46                	jmp    4017f9 <main+0xcd>
			//read_line(0,cmdLine);
		}
		else
		{
			//printf("here");
			ret=read_line(fd, cmdLine);
  4017b3:	48 8d 95 f0 fe ff ff 	lea    -0x110(%rbp),%rdx
  4017ba:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4017bd:	48 89 d6             	mov    %rdx,%rsi
  4017c0:	89 c7                	mov    %eax,%edi
  4017c2:	e8 0f fd ff ff       	callq  4014d6 <read_line>
  4017c7:	89 45 f8             	mov    %eax,-0x8(%rbp)
			while (cmdLine[0] == '#')
  4017ca:	eb 17                	jmp    4017e3 <main+0xb7>
				ret=read_line(fd,cmdLine);
  4017cc:	48 8d 95 f0 fe ff ff 	lea    -0x110(%rbp),%rdx
  4017d3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4017d6:	48 89 d6             	mov    %rdx,%rsi
  4017d9:	89 c7                	mov    %eax,%edi
  4017db:	e8 f6 fc ff ff       	callq  4014d6 <read_line>
  4017e0:	89 45 f8             	mov    %eax,-0x8(%rbp)
		}
		else
		{
			//printf("here");
			ret=read_line(fd, cmdLine);
			while (cmdLine[0] == '#')
  4017e3:	0f b6 85 f0 fe ff ff 	movzbl -0x110(%rbp),%eax
  4017ea:	3c 23                	cmp    $0x23,%al
  4017ec:	74 de                	je     4017cc <main+0xa0>
				ret=read_line(fd,cmdLine);
			if(ret == -1)
  4017ee:	83 7d f8 ff          	cmpl   $0xffffffff,-0x8(%rbp)
  4017f2:	75 05                	jne    4017f9 <main+0xcd>
				break;
  4017f4:	e9 72 01 00 00       	jmpq   40196b <main+0x23f>
		}
    strcpy(cmdLine,"malluaunty");
  4017f9:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  401800:	48 8d 35 39 1f 00 00 	lea    0x1f39(%rip),%rsi        # 403740 <chdir+0x3d6>
  401807:	48 89 c7             	mov    %rax,%rdi
  40180a:	e8 f8 11 00 00       	callq  402a07 <strcpy>
        printf("entered: %s",cmdLine);
  40180f:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  401816:	48 89 c6             	mov    %rax,%rsi
  401819:	48 8d 3d 2b 1f 00 00 	lea    0x1f2b(%rip),%rdi        # 40374b <chdir+0x3e1>
  401820:	b8 00 00 00 00       	mov    $0x0,%eax
  401825:	e8 d2 0a 00 00       	callq  4022fc <printf>
		if (cmdLine == NULL) {
			printf("Unable to read last command\n");
			continue;
		}

		if(!(*cmdLine)){
  40182a:	0f b6 85 f0 fe ff ff 	movzbl -0x110(%rbp),%eax
  401831:	84 c0                	test   %al,%al
  401833:	75 05                	jne    40183a <main+0x10e>
			//printf("No command entered\n");
			continue;
  401835:	e9 2c 01 00 00       	jmpq   401966 <main+0x23a>
		}

		printf("Calling parser%s",cmdLine);
  40183a:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  401841:	48 89 c6             	mov    %rax,%rsi
  401844:	48 8d 3d 0c 1f 00 00 	lea    0x1f0c(%rip),%rdi        # 403757 <chdir+0x3ed>
  40184b:	b8 00 00 00 00       	mov    $0x0,%eax
  401850:	e8 a7 0a 00 00       	callq  4022fc <printf>
		info = parseModified(cmdLine,envp);
  401855:	48 8b 95 b8 fe ff ff 	mov    -0x148(%rbp),%rdx
  40185c:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  401863:	48 89 d6             	mov    %rdx,%rsi
  401866:	48 89 c7             	mov    %rax,%rdi
  401869:	e8 5f f9 ff ff       	callq  4011cd <parseModified>
  40186e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		if (info == NULL){
  401872:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  401877:	75 14                	jne    40188d <main+0x161>
			free(cmdLine);
  401879:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  401880:	48 89 c7             	mov    %rax,%rdi
  401883:	e8 4f 1a 00 00       	callq  4032d7 <free>
			continue;
  401888:	e9 d9 00 00 00       	jmpq   401966 <main+0x23a>
		}

		//prints the info struct
		print_info(info);
  40188d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401891:	48 89 c7             	mov    %rax,%rdi
  401894:	e8 c0 f8 ff ff       	callq  401159 <print_info>

		strcpy(temp,info->CommArray[0]->commandName);
  401899:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40189d:	48 8b 00             	mov    (%rax),%rax
  4018a0:	48 8b 10             	mov    (%rax),%rdx
  4018a3:	48 8d 85 dc fe ff ff 	lea    -0x124(%rbp),%rax
  4018aa:	48 89 d6             	mov    %rdx,%rsi
  4018ad:	48 89 c7             	mov    %rax,%rdi
  4018b0:	e8 52 11 00 00       	callq  402a07 <strcpy>

		if(strcmp(temp,"set")==0||strcmp(temp,"cd")==0 || strcmp(temp,"exit")==0){
  4018b5:	48 8d 85 dc fe ff ff 	lea    -0x124(%rbp),%rax
  4018bc:	48 8d 35 a5 1e 00 00 	lea    0x1ea5(%rip),%rsi        # 403768 <chdir+0x3fe>
  4018c3:	48 89 c7             	mov    %rax,%rdi
  4018c6:	e8 9b 11 00 00       	callq  402a66 <strcmp>
  4018cb:	85 c0                	test   %eax,%eax
  4018cd:	74 34                	je     401903 <main+0x1d7>
  4018cf:	48 8d 85 dc fe ff ff 	lea    -0x124(%rbp),%rax
  4018d6:	48 8d 35 8f 1e 00 00 	lea    0x1e8f(%rip),%rsi        # 40376c <chdir+0x402>
  4018dd:	48 89 c7             	mov    %rax,%rdi
  4018e0:	e8 81 11 00 00       	callq  402a66 <strcmp>
  4018e5:	85 c0                	test   %eax,%eax
  4018e7:	74 1a                	je     401903 <main+0x1d7>
  4018e9:	48 8d 85 dc fe ff ff 	lea    -0x124(%rbp),%rax
  4018f0:	48 8d 35 78 1e 00 00 	lea    0x1e78(%rip),%rsi        # 40376f <chdir+0x405>
  4018f7:	48 89 c7             	mov    %rax,%rdi
  4018fa:	e8 67 11 00 00       	callq  402a66 <strcmp>
  4018ff:	85 c0                	test   %eax,%eax
  401901:	75 29                	jne    40192c <main+0x200>

			printf("Executing Builtin command\n");
  401903:	48 8d 3d 6a 1e 00 00 	lea    0x1e6a(%rip),%rdi        # 403774 <chdir+0x40a>
  40190a:	b8 00 00 00 00       	mov    $0x0,%eax
  40190f:	e8 e8 09 00 00       	callq  4022fc <printf>
			executeBuiltins(info,envp);
  401914:	48 8b 95 b8 fe ff ff 	mov    -0x148(%rbp),%rdx
  40191b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40191f:	48 89 d6             	mov    %rdx,%rsi
  401922:	48 89 c7             	mov    %rax,%rdi
  401925:	e8 b4 ef ff ff       	callq  4008de <executeBuiltins>
  40192a:	eb 27                	jmp    401953 <main+0x227>
		}

		else{
            printf("Calling Execute");
  40192c:	48 8d 3d 5c 1e 00 00 	lea    0x1e5c(%rip),%rdi        # 40378f <chdir+0x425>
  401933:	b8 00 00 00 00       	mov    $0x0,%eax
  401938:	e8 bf 09 00 00       	callq  4022fc <printf>
			execute_cmd(info,envp);
  40193d:	48 8b 95 b8 fe ff ff 	mov    -0x148(%rbp),%rdx
  401944:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401948:	48 89 d6             	mov    %rdx,%rsi
  40194b:	48 89 c7             	mov    %rax,%rdi
  40194e:	e8 58 f1 ff ff       	callq  400aab <execute_cmd>
		}



		static int loop=0;
		loop++;
  401953:	8b 05 27 2d 20 00    	mov    0x202d27(%rip),%eax        # 604680 <loop.1275>
  401959:	ff c0                	inc    %eax
  40195b:	89 05 1f 2d 20 00    	mov    %eax,0x202d1f(%rip)        # 604680 <loop.1275>
		//printf("Out of execute%d\n",loop++);
		//exit(0);
	}/* while(1) */
  401961:	e9 1d fe ff ff       	jmpq   401783 <main+0x57>
  401966:	e9 18 fe ff ff       	jmpq   401783 <main+0x57>
	//printf("BYE BYE");
	return 0;
  40196b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  401970:	c9                   	leaveq 
  401971:	c3                   	retq   

0000000000401972 <onlyWhiteSpace>:
#include <string.h>
#include <shell.h>



int onlyWhiteSpace(char *str){
  401972:	55                   	push   %rbp
  401973:	48 89 e5             	mov    %rsp,%rbp
  401976:	48 83 ec 18          	sub    $0x18,%rsp
  40197a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	//checks if a token is solely composed of white space.
	//if yes returns 1 else returns 0.So that token is not added to the array.

	int i=0;
  40197e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

	while(str[i]!='\0'){
  401985:	eb 32                	jmp    4019b9 <onlyWhiteSpace+0x47>

		if(!((str[i]=='\t') || (str[i]==' '))){
  401987:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40198a:	48 63 d0             	movslq %eax,%rdx
  40198d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401991:	48 01 d0             	add    %rdx,%rax
  401994:	0f b6 00             	movzbl (%rax),%eax
  401997:	3c 09                	cmp    $0x9,%al
  401999:	74 1b                	je     4019b6 <onlyWhiteSpace+0x44>
  40199b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40199e:	48 63 d0             	movslq %eax,%rdx
  4019a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4019a5:	48 01 d0             	add    %rdx,%rax
  4019a8:	0f b6 00             	movzbl (%rax),%eax
  4019ab:	3c 20                	cmp    $0x20,%al
  4019ad:	74 07                	je     4019b6 <onlyWhiteSpace+0x44>

			return 0;
  4019af:	b8 00 00 00 00       	mov    $0x0,%eax
  4019b4:	eb 1c                	jmp    4019d2 <onlyWhiteSpace+0x60>
		}
		i++;
  4019b6:	ff 45 fc             	incl   -0x4(%rbp)
	//checks if a token is solely composed of white space.
	//if yes returns 1 else returns 0.So that token is not added to the array.

	int i=0;

	while(str[i]!='\0'){
  4019b9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4019bc:	48 63 d0             	movslq %eax,%rdx
  4019bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4019c3:	48 01 d0             	add    %rdx,%rax
  4019c6:	0f b6 00             	movzbl (%rax),%eax
  4019c9:	84 c0                	test   %al,%al
  4019cb:	75 ba                	jne    401987 <onlyWhiteSpace+0x15>
			return 0;
		}
		i++;
	}

	return 1;
  4019cd:	b8 01 00 00 00       	mov    $0x1,%eax

}
  4019d2:	c9                   	leaveq 
  4019d3:	c3                   	retq   

00000000004019d4 <substring>:


char * substring(char* str, int front, int back){
  4019d4:	55                   	push   %rbp
  4019d5:	48 89 e5             	mov    %rsp,%rbp
  4019d8:	48 81 ec 20 02 00 00 	sub    $0x220,%rsp
  4019df:	48 89 bd e8 fd ff ff 	mov    %rdi,-0x218(%rbp)
  4019e6:	89 b5 e4 fd ff ff    	mov    %esi,-0x21c(%rbp)
  4019ec:	89 95 e0 fd ff ff    	mov    %edx,-0x220(%rbp)

	//temporary buffer to hold the token;
	char n[500];
	char *p;
	int i=0;
  4019f2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

	//Must handle condition of consequtive delims, delim at the end.Not done till now.

	if(back==front){
  4019f9:	8b 85 e0 fd ff ff    	mov    -0x220(%rbp),%eax
  4019ff:	3b 85 e4 fd ff ff    	cmp    -0x21c(%rbp),%eax
  401a05:	75 0a                	jne    401a11 <substring+0x3d>

		return (char*)NULL;
  401a07:	b8 00 00 00 00       	mov    $0x0,%eax
  401a0c:	e9 d9 00 00 00       	jmpq   401aea <substring+0x116>

	}

	while(back < front){
  401a11:	eb 31                	jmp    401a44 <substring+0x70>
		n[i++]=str[back++];
  401a13:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401a16:	8d 50 01             	lea    0x1(%rax),%edx
  401a19:	89 55 fc             	mov    %edx,-0x4(%rbp)
  401a1c:	8b 95 e0 fd ff ff    	mov    -0x220(%rbp),%edx
  401a22:	8d 4a 01             	lea    0x1(%rdx),%ecx
  401a25:	89 8d e0 fd ff ff    	mov    %ecx,-0x220(%rbp)
  401a2b:	48 63 ca             	movslq %edx,%rcx
  401a2e:	48 8b 95 e8 fd ff ff 	mov    -0x218(%rbp),%rdx
  401a35:	48 01 ca             	add    %rcx,%rdx
  401a38:	0f b6 12             	movzbl (%rdx),%edx
  401a3b:	48 98                	cltq   
  401a3d:	88 94 05 fc fd ff ff 	mov    %dl,-0x204(%rbp,%rax,1)

		return (char*)NULL;

	}

	while(back < front){
  401a44:	8b 85 e0 fd ff ff    	mov    -0x220(%rbp),%eax
  401a4a:	3b 85 e4 fd ff ff    	cmp    -0x21c(%rbp),%eax
  401a50:	7c c1                	jl     401a13 <substring+0x3f>
		n[i++]=str[back++];
	}
	n[i] = '\0';
  401a52:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401a55:	48 98                	cltq   
  401a57:	c6 84 05 fc fd ff ff 	movb   $0x0,-0x204(%rbp,%rax,1)
  401a5e:	00 
	printf("nIn substring... %s\n",n);
  401a5f:	48 8d 85 fc fd ff ff 	lea    -0x204(%rbp),%rax
  401a66:	48 89 c6             	mov    %rax,%rsi
  401a69:	48 8d 3d 2f 1d 00 00 	lea    0x1d2f(%rip),%rdi        # 40379f <chdir+0x435>
  401a70:	b8 00 00 00 00       	mov    $0x0,%eax
  401a75:	e8 82 08 00 00       	callq  4022fc <printf>

	if(onlyWhiteSpace(n)==0){
  401a7a:	48 8d 85 fc fd ff ff 	lea    -0x204(%rbp),%rax
  401a81:	48 89 c7             	mov    %rax,%rdi
  401a84:	e8 e9 fe ff ff       	callq  401972 <onlyWhiteSpace>
  401a89:	85 c0                	test   %eax,%eax
  401a8b:	75 40                	jne    401acd <substring+0xf9>
		p = (char*)malloc(sizeof(char)*(i+1));
  401a8d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401a90:	ff c0                	inc    %eax
  401a92:	48 98                	cltq   
  401a94:	48 89 c7             	mov    %rax,%rdi
  401a97:	e8 ce 16 00 00       	callq  40316a <malloc>
  401a9c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		strcpy(p,n);
  401aa0:	48 8d 95 fc fd ff ff 	lea    -0x204(%rbp),%rdx
  401aa7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401aab:	48 89 d6             	mov    %rdx,%rsi
  401aae:	48 89 c7             	mov    %rax,%rdi
  401ab1:	e8 51 0f 00 00       	callq  402a07 <strcpy>
		printf("After white space p=  ");
  401ab6:	48 8d 3d f7 1c 00 00 	lea    0x1cf7(%rip),%rdi        # 4037b4 <chdir+0x44a>
  401abd:	b8 00 00 00 00       	mov    $0x0,%eax
  401ac2:	e8 35 08 00 00       	callq  4022fc <printf>
        return p;
  401ac7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401acb:	eb 1d                	jmp    401aea <substring+0x116>
	}
	else
		p = (char*)NULL;
  401acd:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  401ad4:	00 

    printf("Returning %s from substring");
  401ad5:	48 8d 3d ef 1c 00 00 	lea    0x1cef(%rip),%rdi        # 4037cb <chdir+0x461>
  401adc:	b8 00 00 00 00       	mov    $0x0,%eax
  401ae1:	e8 16 08 00 00       	callq  4022fc <printf>
	return p;
  401ae6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax

}
  401aea:	c9                   	leaveq 
  401aeb:	c3                   	retq   

0000000000401aec <tokenize>:


Token* tokenize(char *str,char* delim){
  401aec:	55                   	push   %rbp
  401aed:	48 89 e5             	mov    %rsp,%rbp
  401af0:	48 83 ec 30          	sub    $0x30,%rsp
  401af4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  401af8:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)

	Token* token=(Token*)malloc(sizeof(Token));
  401afc:	bf 98 01 00 00       	mov    $0x198,%edi
  401b01:	e8 64 16 00 00       	callq  40316a <malloc>
  401b06:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//printf("In Tokenize Printing str %s\n",str);
	int tokenCount=0;
  401b0a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	int front=0,back=0;
  401b11:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  401b18:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	int i=0;
  401b1f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
	char *p;

	printf("IN TOKENIZER %s %s",str,delim);
  401b26:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  401b2a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401b2e:	48 89 c6             	mov    %rax,%rsi
  401b31:	48 8d 3d af 1c 00 00 	lea    0x1caf(%rip),%rdi        # 4037e7 <chdir+0x47d>
  401b38:	b8 00 00 00 00       	mov    $0x0,%eax
  401b3d:	e8 ba 07 00 00       	callq  4022fc <printf>

	while(str[front]!='\0'){
  401b42:	e9 c0 00 00 00       	jmpq   401c07 <tokenize+0x11b>

		if(str[front]== *delim){
  401b47:	8b 45 f8             	mov    -0x8(%rbp),%eax
  401b4a:	48 63 d0             	movslq %eax,%rdx
  401b4d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401b51:	48 01 d0             	add    %rdx,%rax
  401b54:	0f b6 10             	movzbl (%rax),%edx
  401b57:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401b5b:	0f b6 00             	movzbl (%rax),%eax
  401b5e:	38 c2                	cmp    %al,%dl
  401b60:	0f 85 9e 00 00 00    	jne    401c04 <tokenize+0x118>
			//delimiter found. Extract substring.
			p=substring(str,front,back);
  401b66:	8b 55 f4             	mov    -0xc(%rbp),%edx
  401b69:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  401b6c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401b70:	89 ce                	mov    %ecx,%esi
  401b72:	48 89 c7             	mov    %rax,%rdi
  401b75:	e8 5a fe ff ff       	callq  4019d4 <substring>
  401b7a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
            printf("Back in token %s %d ",p,p);
  401b7e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  401b82:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  401b86:	48 89 c6             	mov    %rax,%rsi
  401b89:	48 8d 3d 6a 1c 00 00 	lea    0x1c6a(%rip),%rdi        # 4037fa <chdir+0x490>
  401b90:	b8 00 00 00 00       	mov    $0x0,%eax
  401b95:	e8 62 07 00 00       	callq  4022fc <printf>
            
            if(p==NULL)
  401b9a:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  401b9f:	75 11                	jne    401bb2 <tokenize+0xc6>
                printf("p is null");
  401ba1:	48 8d 3d 67 1c 00 00 	lea    0x1c67(%rip),%rdi        # 40380f <chdir+0x4a5>
  401ba8:	b8 00 00 00 00       	mov    $0x0,%eax
  401bad:	e8 4a 07 00 00       	callq  4022fc <printf>

			if(p != NULL){
  401bb2:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  401bb7:	74 3e                	je     401bf7 <tokenize+0x10b>
				token->tokenArr[tokenCount++]=p;
  401bb9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401bbc:	8d 50 01             	lea    0x1(%rax),%edx
  401bbf:	89 55 fc             	mov    %edx,-0x4(%rbp)
  401bc2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  401bc6:	48 98                	cltq   
  401bc8:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  401bcc:	48 89 4c c2 08       	mov    %rcx,0x8(%rdx,%rax,8)
				printf("\nIn tokenizer..appending %s\n",token->tokenArr[tokenCount-1]);
  401bd1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401bd4:	8d 50 ff             	lea    -0x1(%rax),%edx
  401bd7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401bdb:	48 63 d2             	movslq %edx,%rdx
  401bde:	48 8b 44 d0 08       	mov    0x8(%rax,%rdx,8),%rax
  401be3:	48 89 c6             	mov    %rax,%rsi
  401be6:	48 8d 3d 2c 1c 00 00 	lea    0x1c2c(%rip),%rdi        # 403819 <chdir+0x4af>
  401bed:	b8 00 00 00 00       	mov    $0x0,%eax
  401bf2:	e8 05 07 00 00       	callq  4022fc <printf>
			}

			back = front +1;
  401bf7:	8b 45 f8             	mov    -0x8(%rbp),%eax
  401bfa:	ff c0                	inc    %eax
  401bfc:	89 45 f4             	mov    %eax,-0xc(%rbp)
			front++;
  401bff:	ff 45 f8             	incl   -0x8(%rbp)
  401c02:	eb 03                	jmp    401c07 <tokenize+0x11b>
			//continue;
		}

		else{
			front++;
  401c04:	ff 45 f8             	incl   -0x8(%rbp)
	int i=0;
	char *p;

	printf("IN TOKENIZER %s %s",str,delim);

	while(str[front]!='\0'){
  401c07:	8b 45 f8             	mov    -0x8(%rbp),%eax
  401c0a:	48 63 d0             	movslq %eax,%rdx
  401c0d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401c11:	48 01 d0             	add    %rdx,%rax
  401c14:	0f b6 00             	movzbl (%rax),%eax
  401c17:	84 c0                	test   %al,%al
  401c19:	0f 85 28 ff ff ff    	jne    401b47 <tokenize+0x5b>
		else{
			front++;
		}
	}//end while

	p = substring(str,front,back);
  401c1f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  401c22:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  401c25:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401c29:	89 ce                	mov    %ecx,%esi
  401c2b:	48 89 c7             	mov    %rax,%rdi
  401c2e:	e8 a1 fd ff ff       	callq  4019d4 <substring>
  401c33:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if(p != NULL){
  401c37:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  401c3c:	74 18                	je     401c56 <tokenize+0x16a>
		token->tokenArr[tokenCount++]=p;
  401c3e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401c41:	8d 50 01             	lea    0x1(%rax),%edx
  401c44:	89 55 fc             	mov    %edx,-0x4(%rbp)
  401c47:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  401c4b:	48 98                	cltq   
  401c4d:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  401c51:	48 89 4c c2 08       	mov    %rcx,0x8(%rdx,%rax,8)
	}
	token->numOfTokens=tokenCount;
  401c56:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401c5a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  401c5d:	89 10                	mov    %edx,(%rax)


	printf("Before Returning Token\n\n");
  401c5f:	48 8d 3d d0 1b 00 00 	lea    0x1bd0(%rip),%rdi        # 403836 <chdir+0x4cc>
  401c66:	b8 00 00 00 00       	mov    $0x0,%eax
  401c6b:	e8 8c 06 00 00       	callq  4022fc <printf>

	for(i=0;i<token->numOfTokens;i++){
  401c70:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  401c77:	eb 2e                	jmp    401ca7 <tokenize+0x1bb>

		printf("Token %d : %s %d\n",i,token->tokenArr[i],token->numOfTokens);
  401c79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401c7d:	8b 08                	mov    (%rax),%ecx
  401c7f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401c83:	8b 55 f0             	mov    -0x10(%rbp),%edx
  401c86:	48 63 d2             	movslq %edx,%rdx
  401c89:	48 8b 54 d0 08       	mov    0x8(%rax,%rdx,8),%rdx
  401c8e:	8b 45 f0             	mov    -0x10(%rbp),%eax
  401c91:	89 c6                	mov    %eax,%esi
  401c93:	48 8d 3d b5 1b 00 00 	lea    0x1bb5(%rip),%rdi        # 40384f <chdir+0x4e5>
  401c9a:	b8 00 00 00 00       	mov    $0x0,%eax
  401c9f:	e8 58 06 00 00       	callq  4022fc <printf>
	token->numOfTokens=tokenCount;


	printf("Before Returning Token\n\n");

	for(i=0;i<token->numOfTokens;i++){
  401ca4:	ff 45 f0             	incl   -0x10(%rbp)
  401ca7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401cab:	8b 00                	mov    (%rax),%eax
  401cad:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  401cb0:	7f c7                	jg     401c79 <tokenize+0x18d>

		printf("Token %d : %s %d\n",i,token->tokenArr[i],token->numOfTokens);
	}


	return token;
  401cb2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax

}
  401cb6:	c9                   	leaveq 
  401cb7:	c3                   	retq   

0000000000401cb8 <main2>:
#include<stdlib.h>
#include<stdio.h>
int main2 (int argc, char *argv[], char* envp[])
{
  401cb8:	55                   	push   %rbp
  401cb9:	48 89 e5             	mov    %rsp,%rbp
  401cbc:	48 83 ec 30          	sub    $0x30,%rsp
  401cc0:	89 7d ec             	mov    %edi,-0x14(%rbp)
  401cc3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  401cc7:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
char* s=(char*)malloc(10);
  401ccb:	bf 0a 00 00 00       	mov    $0xa,%edi
  401cd0:	e8 95 14 00 00       	callq  40316a <malloc>
  401cd5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

printf("s=%d",s);
  401cd9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401cdd:	48 89 c6             	mov    %rax,%rsi
  401ce0:	48 8d 3d 7a 1b 00 00 	lea    0x1b7a(%rip),%rdi        # 403861 <chdir+0x4f7>
  401ce7:	b8 00 00 00 00       	mov    $0x0,%eax
  401cec:	e8 0b 06 00 00       	callq  4022fc <printf>
return 0;
  401cf1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  401cf6:	c9                   	leaveq 
  401cf7:	c3                   	retq   

0000000000401cf8 <test>:
#include <stdlib.h>
#include <string.h>


	
uint64_t test(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3){
  401cf8:	55                   	push   %rbp
  401cf9:	48 89 e5             	mov    %rsp,%rbp
  401cfc:	48 83 ec 30          	sub    $0x30,%rsp
  401d00:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401d04:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  401d08:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  401d0c:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)

	//printf("Inside test\n");


	uint64_t ret;
	__asm__("movq %1,%%rax;"
  401d10:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401d14:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401d18:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  401d1c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  401d20:	cd 80                	int    $0x80
  401d22:	48 89 c0             	mov    %rax,%rax
  401d25:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %3,%%rsi;"
			"movq %4, %%rdx;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2),"m"(a3));
	return ret;
  401d29:	48 8b 45 f8          	mov    -0x8(%rbp),%rax


}
  401d2d:	c9                   	leaveq 
  401d2e:	c3                   	retq   

0000000000401d2f <readdir>:




struct dirent* readdir(void *dir){
  401d2f:	55                   	push   %rbp
  401d30:	48 89 e5             	mov    %rsp,%rbp
  401d33:	48 81 ec 20 04 00 00 	sub    $0x420,%rsp
  401d3a:	48 89 bd e8 fb ff ff 	mov    %rdi,-0x418(%rbp)

	char buff[1024];

	if((uint64_t)dir == -1){
  401d41:	48 8b 85 e8 fb ff ff 	mov    -0x418(%rbp),%rax
  401d48:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  401d4c:	75 18                	jne    401d66 <readdir+0x37>

		printf("Bad directory stream\n");
  401d4e:	48 8d 3d 13 1b 00 00 	lea    0x1b13(%rip),%rdi        # 403868 <chdir+0x4fe>
  401d55:	b8 00 00 00 00       	mov    $0x0,%eax
  401d5a:	e8 9d 05 00 00       	callq  4022fc <printf>
		return NULL;
  401d5f:	b8 00 00 00 00       	mov    $0x0,%eax
  401d64:	eb 6a                	jmp    401dd0 <readdir+0xa1>
	}


	int ret = test(78,(uint64_t)dir,(uint64_t)buff,(uint64_t)1024);
  401d66:	48 8d 95 f0 fb ff ff 	lea    -0x410(%rbp),%rdx
  401d6d:	48 8b 85 e8 fb ff ff 	mov    -0x418(%rbp),%rax
  401d74:	b9 00 04 00 00       	mov    $0x400,%ecx
  401d79:	48 89 c6             	mov    %rax,%rsi
  401d7c:	bf 4e 00 00 00       	mov    $0x4e,%edi
  401d81:	e8 72 ff ff ff       	callq  401cf8 <test>
  401d86:	89 45 fc             	mov    %eax,-0x4(%rbp)

	//printf("Ret value %d\n", ret );

	if(ret == -1){
  401d89:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  401d8d:	75 18                	jne    401da7 <readdir+0x78>

		//Error
		printf("Error while reading directory\n");
  401d8f:	48 8d 3d ea 1a 00 00 	lea    0x1aea(%rip),%rdi        # 403880 <chdir+0x516>
  401d96:	b8 00 00 00 00       	mov    $0x0,%eax
  401d9b:	e8 5c 05 00 00       	callq  4022fc <printf>
		return NULL;
  401da0:	b8 00 00 00 00       	mov    $0x0,%eax
  401da5:	eb 29                	jmp    401dd0 <readdir+0xa1>

	}

	else if (ret == 0){
  401da7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  401dab:	75 07                	jne    401db4 <readdir+0x85>

		//End of directory stream
		return NULL;
  401dad:	b8 00 00 00 00       	mov    $0x0,%eax
  401db2:	eb 1c                	jmp    401dd0 <readdir+0xa1>

	}

	else if(ret !=0){
  401db4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  401db8:	74 11                	je     401dcb <readdir+0x9c>

		//There is a valid child
		//printf("Ret of readdir is not 0\n");
		struct dirent* x = (struct dirent*)buff;
  401dba:	48 8d 85 f0 fb ff ff 	lea    -0x410(%rbp),%rax
  401dc1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		//printf("Name of entry dir%s\n",x->d_name );
		return x;
  401dc5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401dc9:	eb 05                	jmp    401dd0 <readdir+0xa1>
	}


	return NULL;
  401dcb:	b8 00 00 00 00       	mov    $0x0,%eax

}
  401dd0:	c9                   	leaveq 
  401dd1:	c3                   	retq   

0000000000401dd2 <syscall_2>:
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
}

static __inline uint64_t syscall_2(uint64_t n, uint64_t a1, uint64_t a2) {
  401dd2:	55                   	push   %rbp
  401dd3:	48 89 e5             	mov    %rsp,%rbp
  401dd6:	48 83 ec 28          	sub    $0x28,%rsp
  401dda:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401dde:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  401de2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	uint64_t ret;
	__asm__("movq %1,%%rax;"
  401de6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401dea:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401dee:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  401df2:	cd 80                	int    $0x80
  401df4:	48 89 c0             	mov    %rax,%rax
  401df7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %2,%%rdi;"
			"movq %3,%%rsi;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
  401dfb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401dff:	c9                   	leaveq 
  401e00:	c3                   	retq   

0000000000401e01 <dup2>:
#include<sys/syscall.h>
#include<syscall.h>
#include<stdlib.h>

int dup2(int oldfd, int newfd)
{
  401e01:	55                   	push   %rbp
  401e02:	48 89 e5             	mov    %rsp,%rbp
  401e05:	48 83 ec 18          	sub    $0x18,%rsp
  401e09:	89 7d ec             	mov    %edi,-0x14(%rbp)
  401e0c:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int retvalue;
	retvalue = syscall_2(SYS_dup2, oldfd, newfd);
  401e0f:	8b 45 e8             	mov    -0x18(%rbp),%eax
  401e12:	48 63 d0             	movslq %eax,%rdx
  401e15:	8b 45 ec             	mov    -0x14(%rbp),%eax
  401e18:	48 98                	cltq   
  401e1a:	48 89 c6             	mov    %rax,%rsi
  401e1d:	bf 21 00 00 00       	mov    $0x21,%edi
  401e22:	e8 ab ff ff ff       	callq  401dd2 <syscall_2>
  401e27:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(retvalue >=0){
  401e2a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  401e2e:	78 05                	js     401e35 <dup2+0x34>
		return retvalue;
  401e30:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401e33:	eb 05                	jmp    401e3a <dup2+0x39>
	}
	return -1;
  401e35:	b8 ff ff ff ff       	mov    $0xffffffff,%eax


}
  401e3a:	c9                   	leaveq 
  401e3b:	c3                   	retq   

0000000000401e3c <syscall_2>:
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
}

static __inline uint64_t syscall_2(uint64_t n, uint64_t a1, uint64_t a2) {
  401e3c:	55                   	push   %rbp
  401e3d:	48 89 e5             	mov    %rsp,%rbp
  401e40:	48 83 ec 28          	sub    $0x28,%rsp
  401e44:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401e48:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  401e4c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	uint64_t ret;
	__asm__("movq %1,%%rax;"
  401e50:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401e54:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401e58:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  401e5c:	cd 80                	int    $0x80
  401e5e:	48 89 c0             	mov    %rax,%rax
  401e61:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %2,%%rdi;"
			"movq %3,%%rsi;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
  401e65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401e69:	c9                   	leaveq 
  401e6a:	c3                   	retq   

0000000000401e6b <open>:
#include <errno.h>

//int errno = 0;

int open(const char *pathname, int flags)
{
  401e6b:	55                   	push   %rbp
  401e6c:	48 89 e5             	mov    %rsp,%rbp
  401e6f:	48 83 ec 20          	sub    $0x20,%rsp
  401e73:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401e77:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int retvalue;
	retvalue = syscall_2(SYS_open, (uint64_t)pathname, (uint64_t)flags);
  401e7a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  401e7d:	48 63 d0             	movslq %eax,%rdx
  401e80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401e84:	48 89 c6             	mov    %rax,%rsi
  401e87:	bf 02 00 00 00       	mov    $0x2,%edi
  401e8c:	e8 ab ff ff ff       	callq  401e3c <syscall_2>
  401e91:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(retvalue >=0){
  401e94:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  401e98:	78 05                	js     401e9f <open+0x34>
		return retvalue;
  401e9a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401e9d:	eb 05                	jmp    401ea4 <open+0x39>
	}

	return -1;
  401e9f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
  401ea4:	c9                   	leaveq 
  401ea5:	c3                   	retq   

0000000000401ea6 <syscall_2>:
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
}

static __inline uint64_t syscall_2(uint64_t n, uint64_t a1, uint64_t a2) {
  401ea6:	55                   	push   %rbp
  401ea7:	48 89 e5             	mov    %rsp,%rbp
  401eaa:	48 83 ec 28          	sub    $0x28,%rsp
  401eae:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401eb2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  401eb6:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	uint64_t ret;
	__asm__("movq %1,%%rax;"
  401eba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401ebe:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401ec2:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  401ec6:	cd 80                	int    $0x80
  401ec8:	48 89 c0             	mov    %rax,%rax
  401ecb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %2,%%rdi;"
			"movq %3,%%rsi;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
  401ecf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401ed3:	c9                   	leaveq 
  401ed4:	c3                   	retq   

0000000000401ed5 <getcwd>:
#include <stdlib.h>
#include <errno.h>

//int errno=0; //Only define here. declaration seeps through to the files via stdlib.h

char* getcwd(char *buf, size_t size){
  401ed5:	55                   	push   %rbp
  401ed6:	48 89 e5             	mov    %rsp,%rbp
  401ed9:	48 83 ec 20          	sub    $0x20,%rsp
  401edd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401ee1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int retvalue;
	retvalue=syscall_2(SYS_getcwd,(uint64_t)buf,(uint64_t)size);
  401ee5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401ee9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  401eed:	48 89 c6             	mov    %rax,%rsi
  401ef0:	bf 4f 00 00 00       	mov    $0x4f,%edi
  401ef5:	e8 ac ff ff ff       	callq  401ea6 <syscall_2>
  401efa:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(retvalue >=0){
  401efd:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  401f01:	78 06                	js     401f09 <getcwd+0x34>
		return buf;
  401f03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401f07:	eb 05                	jmp    401f0e <getcwd+0x39>
	}
	return NULL;
  401f09:	b8 00 00 00 00       	mov    $0x0,%eax

}
  401f0e:	c9                   	leaveq 
  401f0f:	c3                   	retq   

0000000000401f10 <syscall_1>:
			:"=r"(ret):"m"(n));

	return ret;
}

static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
  401f10:	55                   	push   %rbp
  401f11:	48 89 e5             	mov    %rsp,%rbp
  401f14:	48 83 ec 20          	sub    $0x20,%rsp
  401f18:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401f1c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int64_t ret;

	__asm__("movq $78,%r15");
  401f20:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
	//__asm__("movq %0,%%rax;"
	//		::"m"(n));

	//while(1);

	if(n==60){
  401f27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401f2b:	48 83 f8 3c          	cmp    $0x3c,%rax
  401f2f:	75 0c                	jne    401f3d <syscall_1+0x2d>
		__asm__("movq %0,%%rax;"
  401f31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401f35:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401f39:	cd 80                	int    $0x80
  401f3b:	eb 11                	jmp    401f4e <syscall_1+0x3e>

		//while(1);
	}
	else{

		__asm__("movq %1,%%rax;"
  401f3d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401f41:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401f45:	cd 80                	int    $0x80
  401f47:	48 89 c0             	mov    %rax,%rax
  401f4a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				"movq %2,%%rdi;"
				"int $0x80;"
				"movq %%rax,%0;"
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
  401f4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401f52:	c9                   	leaveq 
  401f53:	c3                   	retq   

0000000000401f54 <close>:
#include<sys/syscall.h>
#include<syscall.h>
#include <stdlib.h>

int close(int fd)
{
  401f54:	55                   	push   %rbp
  401f55:	48 89 e5             	mov    %rsp,%rbp
  401f58:	48 83 ec 18          	sub    $0x18,%rsp
  401f5c:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int retvalue;
	retvalue = syscall_1(SYS_close, fd);
  401f5f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  401f62:	48 98                	cltq   
  401f64:	48 89 c6             	mov    %rax,%rsi
  401f67:	bf 03 00 00 00       	mov    $0x3,%edi
  401f6c:	e8 9f ff ff ff       	callq  401f10 <syscall_1>
  401f71:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(retvalue >=0){
  401f74:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  401f78:	78 05                	js     401f7f <close+0x2b>
		return retvalue;
  401f7a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401f7d:	eb 05                	jmp    401f84 <close+0x30>
	}
	return -1;
  401f7f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
  401f84:	c9                   	leaveq 
  401f85:	c3                   	retq   

0000000000401f86 <syscall_0>:
#define _SYSCALL_H

#include <sys/defs.h>
#include <sys/syscall.h>

static __inline uint64_t syscall_0(uint64_t n) {
  401f86:	55                   	push   %rbp
  401f87:	48 89 e5             	mov    %rsp,%rbp
  401f8a:	48 83 ec 18          	sub    $0x18,%rsp
  401f8e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	uint64_t ret;
	__asm__("movq %1,%%rax;"
  401f92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401f96:	cd 80                	int    $0x80
  401f98:	48 89 c0             	mov    %rax,%rax
  401f9b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n));

	return ret;
  401f9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401fa3:	c9                   	leaveq 
  401fa4:	c3                   	retq   

0000000000401fa5 <syscall_3>:
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
}

static __inline uint64_t syscall_3(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3) {
  401fa5:	55                   	push   %rbp
  401fa6:	48 89 e5             	mov    %rsp,%rbp
  401fa9:	48 83 ec 30          	sub    $0x30,%rsp
  401fad:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401fb1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  401fb5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  401fb9:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)

	uint64_t ret;
    
	__asm__("movq %1,%%rax;"
  401fbd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401fc1:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401fc5:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  401fc9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  401fcd:	cd 80                	int    $0x80
  401fcf:	48 89 c0             	mov    %rax,%rax
  401fd2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %3, %%rsi;"
			"movq %4, %%rdx;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2),"m"(a3));
	return ret;
  401fd6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401fda:	c9                   	leaveq 
  401fdb:	c3                   	retq   

0000000000401fdc <getpid>:
#include <sys/defs.h>
#include <stdlib.h>
#include <sys/syscall.h>

pid_t getpid()
{
  401fdc:	55                   	push   %rbp
  401fdd:	48 89 e5             	mov    %rsp,%rbp
  401fe0:	48 83 ec 10          	sub    $0x10,%rsp
	int retvalue;
	retvalue = syscall_0(SYS_getpid);
  401fe4:	bf 27 00 00 00       	mov    $0x27,%edi
  401fe9:	e8 98 ff ff ff       	callq  401f86 <syscall_0>
  401fee:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(retvalue >=0){
  401ff1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  401ff5:	78 05                	js     401ffc <getpid+0x20>
		return retvalue;
  401ff7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401ffa:	eb 05                	jmp    402001 <getpid+0x25>
	}
	return -1;
  401ffc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax


}
  402001:	c9                   	leaveq 
  402002:	c3                   	retq   

0000000000402003 <getppid>:

pid_t getppid()
{
  402003:	55                   	push   %rbp
  402004:	48 89 e5             	mov    %rsp,%rbp
  402007:	48 83 ec 10          	sub    $0x10,%rsp
	int retvalue;
	retvalue = syscall_0(SYS_getppid);
  40200b:	bf 6e 00 00 00       	mov    $0x6e,%edi
  402010:	e8 71 ff ff ff       	callq  401f86 <syscall_0>
  402015:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(retvalue >=0){
  402018:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  40201c:	78 05                	js     402023 <getppid+0x20>
		return retvalue;
  40201e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402021:	eb 05                	jmp    402028 <getppid+0x25>
	}

	return -1;
  402023:	b8 ff ff ff ff       	mov    $0xffffffff,%eax


}
  402028:	c9                   	leaveq 
  402029:	c3                   	retq   

000000000040202a <waitpid>:

pid_t waitpid(pid_t pid, int *status, int options)
{
  40202a:	55                   	push   %rbp
  40202b:	48 89 e5             	mov    %rsp,%rbp
  40202e:	48 83 ec 20          	sub    $0x20,%rsp
  402032:	89 7d ec             	mov    %edi,-0x14(%rbp)
  402035:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  402039:	89 55 e8             	mov    %edx,-0x18(%rbp)
	pid_t retvalue;
	retvalue = syscall_3(SYS_wait4,(uint64_t)pid,(uint64_t)status,(uint64_t)options);
  40203c:	8b 45 e8             	mov    -0x18(%rbp),%eax
  40203f:	48 63 c8             	movslq %eax,%rcx
  402042:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  402046:	8b 45 ec             	mov    -0x14(%rbp),%eax
  402049:	48 89 c6             	mov    %rax,%rsi
  40204c:	bf 3d 00 00 00       	mov    $0x3d,%edi
  402051:	e8 4f ff ff ff       	callq  401fa5 <syscall_3>
  402056:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(retvalue >=0){
		return retvalue;
  402059:	8b 45 fc             	mov    -0x4(%rbp),%eax
	}

	return -1;

}
  40205c:	c9                   	leaveq 
  40205d:	c3                   	retq   

000000000040205e <syscall_1>:
			:"=r"(ret):"m"(n));

	return ret;
}

static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
  40205e:	55                   	push   %rbp
  40205f:	48 89 e5             	mov    %rsp,%rbp
  402062:	48 83 ec 20          	sub    $0x20,%rsp
  402066:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  40206a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int64_t ret;

	__asm__("movq $78,%r15");
  40206e:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
	//__asm__("movq %0,%%rax;"
	//		::"m"(n));

	//while(1);

	if(n==60){
  402075:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402079:	48 83 f8 3c          	cmp    $0x3c,%rax
  40207d:	75 0c                	jne    40208b <syscall_1+0x2d>
		__asm__("movq %0,%%rax;"
  40207f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402083:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402087:	cd 80                	int    $0x80
  402089:	eb 11                	jmp    40209c <syscall_1+0x3e>

		//while(1);
	}
	else{

		__asm__("movq %1,%%rax;"
  40208b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40208f:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402093:	cd 80                	int    $0x80
  402095:	48 89 c0             	mov    %rax,%rax
  402098:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				"movq %2,%%rdi;"
				"int $0x80;"
				"movq %%rax,%0;"
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
  40209c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  4020a0:	c9                   	leaveq 
  4020a1:	c3                   	retq   

00000000004020a2 <closedir>:
#include<sys/defs.h>
#include<stdlib.h>
#include<errno.h>


int closedir(void *dir){
  4020a2:	55                   	push   %rbp
  4020a3:	48 89 e5             	mov    %rsp,%rbp
  4020a6:	48 83 ec 20          	sub    $0x20,%rsp
  4020aa:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)


	if((uint64_t)dir == -1){
  4020ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4020b2:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  4020b6:	75 18                	jne    4020d0 <closedir+0x2e>

		printf("Cannot close bad directory stream\n");
  4020b8:	48 8d 3d e1 17 00 00 	lea    0x17e1(%rip),%rdi        # 4038a0 <chdir+0x536>
  4020bf:	b8 00 00 00 00       	mov    $0x0,%eax
  4020c4:	e8 33 02 00 00       	callq  4022fc <printf>
		return -1;
  4020c9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4020ce:	eb 2c                	jmp    4020fc <closedir+0x5a>
	}
	int fd = (uint64_t)dir;
  4020d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4020d4:	89 45 fc             	mov    %eax,-0x4(%rbp)

	int retvalue;
	retvalue = syscall_1(SYS_close,(uint64_t)fd);
  4020d7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4020da:	48 98                	cltq   
  4020dc:	48 89 c6             	mov    %rax,%rsi
  4020df:	bf 03 00 00 00       	mov    $0x3,%edi
  4020e4:	e8 75 ff ff ff       	callq  40205e <syscall_1>
  4020e9:	89 45 f8             	mov    %eax,-0x8(%rbp)

	//printf("closedir syscall returned %d\n",retvalue );

	if(retvalue<0){
  4020ec:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  4020f0:	79 07                	jns    4020f9 <closedir+0x57>
		
		return -1;
  4020f2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4020f7:	eb 03                	jmp    4020fc <closedir+0x5a>

	}
	return retvalue;
  4020f9:	8b 45 f8             	mov    -0x8(%rbp),%eax


}
  4020fc:	c9                   	leaveq 
  4020fd:	c3                   	retq   

00000000004020fe <print_num>:

// update errno.
char screen[1024];
int screen_ctr;
void print_num(int num, int base)
{
  4020fe:	55                   	push   %rbp
  4020ff:	48 89 e5             	mov    %rsp,%rbp
  402102:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  402109:	89 bd 6c ff ff ff    	mov    %edi,-0x94(%rbp)
  40210f:	89 b5 68 ff ff ff    	mov    %esi,-0x98(%rbp)
	int number[32];
	int i=0;
  402115:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

	if(base == 16)
  40211c:	83 bd 68 ff ff ff 10 	cmpl   $0x10,-0x98(%rbp)
  402123:	75 44                	jne    402169 <print_num+0x6b>
	{
		screen[screen_ctr++] = '0';
  402125:	48 8b 05 3c 24 20 00 	mov    0x20243c(%rip),%rax        # 604568 <chdir+0x2011fe>
  40212c:	8b 00                	mov    (%rax),%eax
  40212e:	8d 48 01             	lea    0x1(%rax),%ecx
  402131:	48 8b 15 30 24 20 00 	mov    0x202430(%rip),%rdx        # 604568 <chdir+0x2011fe>
  402138:	89 0a                	mov    %ecx,(%rdx)
  40213a:	48 8b 15 2f 24 20 00 	mov    0x20242f(%rip),%rdx        # 604570 <chdir+0x201206>
  402141:	48 98                	cltq   
  402143:	c6 04 02 30          	movb   $0x30,(%rdx,%rax,1)
		screen[screen_ctr++] = 'x';
  402147:	48 8b 05 1a 24 20 00 	mov    0x20241a(%rip),%rax        # 604568 <chdir+0x2011fe>
  40214e:	8b 00                	mov    (%rax),%eax
  402150:	8d 48 01             	lea    0x1(%rax),%ecx
  402153:	48 8b 15 0e 24 20 00 	mov    0x20240e(%rip),%rdx        # 604568 <chdir+0x2011fe>
  40215a:	89 0a                	mov    %ecx,(%rdx)
  40215c:	48 8b 15 0d 24 20 00 	mov    0x20240d(%rip),%rdx        # 604570 <chdir+0x201206>
  402163:	48 98                	cltq   
  402165:	c6 04 02 78          	movb   $0x78,(%rdx,%rax,1)
	}
	do
	{
		int rem=num%base;
  402169:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
  40216f:	99                   	cltd   
  402170:	f7 bd 68 ff ff ff    	idivl  -0x98(%rbp)
  402176:	89 55 f8             	mov    %edx,-0x8(%rbp)
		if((rem) >= 10)
  402179:	83 7d f8 09          	cmpl   $0x9,-0x8(%rbp)
  40217d:	7e 06                	jle    402185 <print_num+0x87>
		{

			rem = rem-10 + 'a';
  40217f:	83 45 f8 57          	addl   $0x57,-0x8(%rbp)
  402183:	eb 04                	jmp    402189 <print_num+0x8b>
		}
		else{
			rem = rem + '0';
  402185:	83 45 f8 30          	addl   $0x30,-0x8(%rbp)
		}
		number[i]= rem;
  402189:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40218c:	48 98                	cltq   
  40218e:	8b 55 f8             	mov    -0x8(%rbp),%edx
  402191:	89 94 85 78 ff ff ff 	mov    %edx,-0x88(%rbp,%rax,4)
		i++;
  402198:	ff 45 fc             	incl   -0x4(%rbp)
	}while((num=num/base) !=0);
  40219b:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
  4021a1:	99                   	cltd   
  4021a2:	f7 bd 68 ff ff ff    	idivl  -0x98(%rbp)
  4021a8:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
  4021ae:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%rbp)
  4021b5:	75 b2                	jne    402169 <print_num+0x6b>


	while(i-- != 0)
  4021b7:	eb 2e                	jmp    4021e7 <print_num+0xe9>
	{

		screen[screen_ctr++] = number[i];
  4021b9:	48 8b 05 a8 23 20 00 	mov    0x2023a8(%rip),%rax        # 604568 <chdir+0x2011fe>
  4021c0:	8b 00                	mov    (%rax),%eax
  4021c2:	8d 48 01             	lea    0x1(%rax),%ecx
  4021c5:	48 8b 15 9c 23 20 00 	mov    0x20239c(%rip),%rdx        # 604568 <chdir+0x2011fe>
  4021cc:	89 0a                	mov    %ecx,(%rdx)
  4021ce:	8b 55 fc             	mov    -0x4(%rbp),%edx
  4021d1:	48 63 d2             	movslq %edx,%rdx
  4021d4:	8b 94 95 78 ff ff ff 	mov    -0x88(%rbp,%rdx,4),%edx
  4021db:	48 8b 0d 8e 23 20 00 	mov    0x20238e(%rip),%rcx        # 604570 <chdir+0x201206>
  4021e2:	48 98                	cltq   
  4021e4:	88 14 01             	mov    %dl,(%rcx,%rax,1)
		number[i]= rem;
		i++;
	}while((num=num/base) !=0);


	while(i-- != 0)
  4021e7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4021ea:	8d 50 ff             	lea    -0x1(%rax),%edx
  4021ed:	89 55 fc             	mov    %edx,-0x4(%rbp)
  4021f0:	85 c0                	test   %eax,%eax
  4021f2:	75 c5                	jne    4021b9 <print_num+0xbb>
	{

		screen[screen_ctr++] = number[i];
	}
}
  4021f4:	c9                   	leaveq 
  4021f5:	c3                   	retq   

00000000004021f6 <print_ptr>:



void print_ptr(long unsigned int num, long unsigned int base)
{
  4021f6:	55                   	push   %rbp
  4021f7:	48 89 e5             	mov    %rsp,%rbp
  4021fa:	48 81 ec 20 01 00 00 	sub    $0x120,%rsp
  402201:	48 89 bd e8 fe ff ff 	mov    %rdi,-0x118(%rbp)
  402208:	48 89 b5 e0 fe ff ff 	mov    %rsi,-0x120(%rbp)
	long unsigned int number[32];
	int i=0;
  40220f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

		screen[screen_ctr++] = '0';
  402216:	48 8b 05 4b 23 20 00 	mov    0x20234b(%rip),%rax        # 604568 <chdir+0x2011fe>
  40221d:	8b 00                	mov    (%rax),%eax
  40221f:	8d 48 01             	lea    0x1(%rax),%ecx
  402222:	48 8b 15 3f 23 20 00 	mov    0x20233f(%rip),%rdx        # 604568 <chdir+0x2011fe>
  402229:	89 0a                	mov    %ecx,(%rdx)
  40222b:	48 8b 15 3e 23 20 00 	mov    0x20233e(%rip),%rdx        # 604570 <chdir+0x201206>
  402232:	48 98                	cltq   
  402234:	c6 04 02 30          	movb   $0x30,(%rdx,%rax,1)
		screen[screen_ctr++] = 'x';
  402238:	48 8b 05 29 23 20 00 	mov    0x202329(%rip),%rax        # 604568 <chdir+0x2011fe>
  40223f:	8b 00                	mov    (%rax),%eax
  402241:	8d 48 01             	lea    0x1(%rax),%ecx
  402244:	48 8b 15 1d 23 20 00 	mov    0x20231d(%rip),%rdx        # 604568 <chdir+0x2011fe>
  40224b:	89 0a                	mov    %ecx,(%rdx)
  40224d:	48 8b 15 1c 23 20 00 	mov    0x20231c(%rip),%rdx        # 604570 <chdir+0x201206>
  402254:	48 98                	cltq   
  402256:	c6 04 02 78          	movb   $0x78,(%rdx,%rax,1)
	
	do
	{
		long unsigned int rem=num%base;
  40225a:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  402261:	ba 00 00 00 00       	mov    $0x0,%edx
  402266:	48 f7 b5 e0 fe ff ff 	divq   -0x120(%rbp)
  40226d:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
		if((rem) >= 10)
  402271:	48 83 7d f0 09       	cmpq   $0x9,-0x10(%rbp)
  402276:	76 07                	jbe    40227f <print_ptr+0x89>
		{
			rem = rem-10 + 'a';
  402278:	48 83 45 f0 57       	addq   $0x57,-0x10(%rbp)
  40227d:	eb 05                	jmp    402284 <print_ptr+0x8e>
		}
		else{
			rem = rem + '0';
  40227f:	48 83 45 f0 30       	addq   $0x30,-0x10(%rbp)
		}
		number[i]= rem;
  402284:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402287:	48 98                	cltq   
  402289:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  40228d:	48 89 94 c5 f0 fe ff 	mov    %rdx,-0x110(%rbp,%rax,8)
  402294:	ff 
		i++;
  402295:	ff 45 fc             	incl   -0x4(%rbp)
	}while((num=num/base) !=0);
  402298:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  40229f:	ba 00 00 00 00       	mov    $0x0,%edx
  4022a4:	48 f7 b5 e0 fe ff ff 	divq   -0x120(%rbp)
  4022ab:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
  4022b2:	48 83 bd e8 fe ff ff 	cmpq   $0x0,-0x118(%rbp)
  4022b9:	00 
  4022ba:	75 9e                	jne    40225a <print_ptr+0x64>


	while(i-- != 0)
  4022bc:	eb 2f                	jmp    4022ed <print_ptr+0xf7>
	{

		screen[screen_ctr++] = number[i];
  4022be:	48 8b 05 a3 22 20 00 	mov    0x2022a3(%rip),%rax        # 604568 <chdir+0x2011fe>
  4022c5:	8b 00                	mov    (%rax),%eax
  4022c7:	8d 48 01             	lea    0x1(%rax),%ecx
  4022ca:	48 8b 15 97 22 20 00 	mov    0x202297(%rip),%rdx        # 604568 <chdir+0x2011fe>
  4022d1:	89 0a                	mov    %ecx,(%rdx)
  4022d3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  4022d6:	48 63 d2             	movslq %edx,%rdx
  4022d9:	48 8b 94 d5 f0 fe ff 	mov    -0x110(%rbp,%rdx,8),%rdx
  4022e0:	ff 
  4022e1:	48 8b 0d 88 22 20 00 	mov    0x202288(%rip),%rcx        # 604570 <chdir+0x201206>
  4022e8:	48 98                	cltq   
  4022ea:	88 14 01             	mov    %dl,(%rcx,%rax,1)
		number[i]= rem;
		i++;
	}while((num=num/base) !=0);


	while(i-- != 0)
  4022ed:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4022f0:	8d 50 ff             	lea    -0x1(%rax),%edx
  4022f3:	89 55 fc             	mov    %edx,-0x4(%rbp)
  4022f6:	85 c0                	test   %eax,%eax
  4022f8:	75 c4                	jne    4022be <print_ptr+0xc8>
	{

		screen[screen_ctr++] = number[i];
    }
}
  4022fa:	c9                   	leaveq 
  4022fb:	c3                   	retq   

00000000004022fc <printf>:





int printf(const char *format, ...) {
  4022fc:	55                   	push   %rbp
  4022fd:	48 89 e5             	mov    %rsp,%rbp
  402300:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  402307:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  40230b:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  40230f:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  402313:	4c 89 45 f0          	mov    %r8,-0x10(%rbp)
  402317:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
  40231b:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
	va_list val;
	int printed = 0;
  402322:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%rbp)
	screen_ctr=0;
  402329:	48 8b 05 38 22 20 00 	mov    0x202238(%rip),%rax        # 604568 <chdir+0x2011fe>
  402330:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	va_start(val, format);
  402336:	c7 45 88 08 00 00 00 	movl   $0x8,-0x78(%rbp)
  40233d:	48 8d 45 10          	lea    0x10(%rbp),%rax
  402341:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  402345:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  402349:	48 89 45 98          	mov    %rax,-0x68(%rbp)

	while(*format)
  40234d:	e9 0d 03 00 00       	jmpq   40265f <printf+0x363>
	{
		if(*format == '%')
  402352:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  402359:	0f b6 00             	movzbl (%rax),%eax
  40235c:	3c 25                	cmp    $0x25,%al
  40235e:	0f 85 c6 02 00 00    	jne    40262a <printf+0x32e>
		{
			switch(*(++format))
  402364:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
  40236b:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  402372:	0f b6 00             	movzbl (%rax),%eax
  402375:	0f be c0             	movsbl %al,%eax
  402378:	83 f8 64             	cmp    $0x64,%eax
  40237b:	74 3c                	je     4023b9 <printf+0xbd>
  40237d:	83 f8 64             	cmp    $0x64,%eax
  402380:	7f 17                	jg     402399 <printf+0x9d>
  402382:	83 f8 25             	cmp    $0x25,%eax
  402385:	0f 84 73 02 00 00    	je     4025fe <printf+0x302>
  40238b:	83 f8 63             	cmp    $0x63,%eax
  40238e:	0f 84 ae 00 00 00    	je     402442 <printf+0x146>
  402394:	e9 c6 02 00 00       	jmpq   40265f <printf+0x363>
  402399:	83 f8 73             	cmp    $0x73,%eax
  40239c:	0f 84 03 01 00 00    	je     4024a5 <printf+0x1a9>
  4023a2:	83 f8 78             	cmp    $0x78,%eax
  4023a5:	0f 84 7b 01 00 00    	je     402526 <printf+0x22a>
  4023ab:	83 f8 70             	cmp    $0x70,%eax
  4023ae:	0f 84 fb 01 00 00    	je     4025af <printf+0x2b3>
  4023b4:	e9 a6 02 00 00       	jmpq   40265f <printf+0x363>
			{
			case 'd':
				printed=printed;
				int num = va_arg(val, int);
  4023b9:	8b 45 88             	mov    -0x78(%rbp),%eax
  4023bc:	83 f8 30             	cmp    $0x30,%eax
  4023bf:	73 17                	jae    4023d8 <printf+0xdc>
  4023c1:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  4023c5:	8b 45 88             	mov    -0x78(%rbp),%eax
  4023c8:	89 c0                	mov    %eax,%eax
  4023ca:	48 01 d0             	add    %rdx,%rax
  4023cd:	8b 55 88             	mov    -0x78(%rbp),%edx
  4023d0:	83 c2 08             	add    $0x8,%edx
  4023d3:	89 55 88             	mov    %edx,-0x78(%rbp)
  4023d6:	eb 0f                	jmp    4023e7 <printf+0xeb>
  4023d8:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  4023dc:	48 89 d0             	mov    %rdx,%rax
  4023df:	48 83 c2 08          	add    $0x8,%rdx
  4023e3:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
  4023e7:	8b 00                	mov    (%rax),%eax
  4023e9:	89 45 bc             	mov    %eax,-0x44(%rbp)
				if(num<0)
  4023ec:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
  4023f0:	79 35                	jns    402427 <printf+0x12b>
				{
					screen[screen_ctr++]='-';
  4023f2:	48 8b 05 6f 21 20 00 	mov    0x20216f(%rip),%rax        # 604568 <chdir+0x2011fe>
  4023f9:	8b 00                	mov    (%rax),%eax
  4023fb:	8d 48 01             	lea    0x1(%rax),%ecx
  4023fe:	48 8b 15 63 21 20 00 	mov    0x202163(%rip),%rdx        # 604568 <chdir+0x2011fe>
  402405:	89 0a                	mov    %ecx,(%rdx)
  402407:	48 8b 15 62 21 20 00 	mov    0x202162(%rip),%rdx        # 604570 <chdir+0x201206>
  40240e:	48 98                	cltq   
  402410:	c6 04 02 2d          	movb   $0x2d,(%rdx,%rax,1)
					print_num(-num,10);
  402414:	8b 45 bc             	mov    -0x44(%rbp),%eax
  402417:	f7 d8                	neg    %eax
  402419:	be 0a 00 00 00       	mov    $0xa,%esi
  40241e:	89 c7                	mov    %eax,%edi
  402420:	e8 d9 fc ff ff       	callq  4020fe <print_num>
  402425:	eb 0f                	jmp    402436 <printf+0x13a>
				}
				else
					print_num(num,10);
  402427:	8b 45 bc             	mov    -0x44(%rbp),%eax
  40242a:	be 0a 00 00 00       	mov    $0xa,%esi
  40242f:	89 c7                	mov    %eax,%edi
  402431:	e8 c8 fc ff ff       	callq  4020fe <print_num>
				format++;
  402436:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
				continue;
  40243d:	e9 1d 02 00 00       	jmpq   40265f <printf+0x363>

			case 'c':
				printed=printed;;
				int chr = va_arg(val, int);
  402442:	8b 45 88             	mov    -0x78(%rbp),%eax
  402445:	83 f8 30             	cmp    $0x30,%eax
  402448:	73 17                	jae    402461 <printf+0x165>
  40244a:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  40244e:	8b 45 88             	mov    -0x78(%rbp),%eax
  402451:	89 c0                	mov    %eax,%eax
  402453:	48 01 d0             	add    %rdx,%rax
  402456:	8b 55 88             	mov    -0x78(%rbp),%edx
  402459:	83 c2 08             	add    $0x8,%edx
  40245c:	89 55 88             	mov    %edx,-0x78(%rbp)
  40245f:	eb 0f                	jmp    402470 <printf+0x174>
  402461:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  402465:	48 89 d0             	mov    %rdx,%rax
  402468:	48 83 c2 08          	add    $0x8,%rdx
  40246c:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
  402470:	8b 00                	mov    (%rax),%eax
  402472:	89 45 b8             	mov    %eax,-0x48(%rbp)
				screen[screen_ctr++] = chr;
  402475:	48 8b 05 ec 20 20 00 	mov    0x2020ec(%rip),%rax        # 604568 <chdir+0x2011fe>
  40247c:	8b 00                	mov    (%rax),%eax
  40247e:	8d 48 01             	lea    0x1(%rax),%ecx
  402481:	48 8b 15 e0 20 20 00 	mov    0x2020e0(%rip),%rdx        # 604568 <chdir+0x2011fe>
  402488:	89 0a                	mov    %ecx,(%rdx)
  40248a:	8b 55 b8             	mov    -0x48(%rbp),%edx
  40248d:	48 8b 0d dc 20 20 00 	mov    0x2020dc(%rip),%rcx        # 604570 <chdir+0x201206>
  402494:	48 98                	cltq   
  402496:	88 14 01             	mov    %dl,(%rcx,%rax,1)
				format++;
  402499:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
				continue;
  4024a0:	e9 ba 01 00 00       	jmpq   40265f <printf+0x363>

			case 's':
				printed=printed;
				char* str = va_arg(val, char*);
  4024a5:	8b 45 88             	mov    -0x78(%rbp),%eax
  4024a8:	83 f8 30             	cmp    $0x30,%eax
  4024ab:	73 17                	jae    4024c4 <printf+0x1c8>
  4024ad:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  4024b1:	8b 45 88             	mov    -0x78(%rbp),%eax
  4024b4:	89 c0                	mov    %eax,%eax
  4024b6:	48 01 d0             	add    %rdx,%rax
  4024b9:	8b 55 88             	mov    -0x78(%rbp),%edx
  4024bc:	83 c2 08             	add    $0x8,%edx
  4024bf:	89 55 88             	mov    %edx,-0x78(%rbp)
  4024c2:	eb 0f                	jmp    4024d3 <printf+0x1d7>
  4024c4:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  4024c8:	48 89 d0             	mov    %rdx,%rax
  4024cb:	48 83 c2 08          	add    $0x8,%rdx
  4024cf:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
  4024d3:	48 8b 00             	mov    (%rax),%rax
  4024d6:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				while(*(str) != '\0')
  4024da:	eb 33                	jmp    40250f <printf+0x213>
					screen[screen_ctr++] = *str++;
  4024dc:	48 8b 05 85 20 20 00 	mov    0x202085(%rip),%rax        # 604568 <chdir+0x2011fe>
  4024e3:	8b 00                	mov    (%rax),%eax
  4024e5:	89 c2                	mov    %eax,%edx
  4024e7:	8d 4a 01             	lea    0x1(%rdx),%ecx
  4024ea:	48 8b 05 77 20 20 00 	mov    0x202077(%rip),%rax        # 604568 <chdir+0x2011fe>
  4024f1:	89 08                	mov    %ecx,(%rax)
  4024f3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  4024f7:	48 8d 48 01          	lea    0x1(%rax),%rcx
  4024fb:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  4024ff:	0f b6 00             	movzbl (%rax),%eax
  402502:	48 8b 0d 67 20 20 00 	mov    0x202067(%rip),%rcx        # 604570 <chdir+0x201206>
  402509:	48 63 d2             	movslq %edx,%rdx
  40250c:	88 04 11             	mov    %al,(%rcx,%rdx,1)
				continue;

			case 's':
				printed=printed;
				char* str = va_arg(val, char*);
				while(*(str) != '\0')
  40250f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  402513:	0f b6 00             	movzbl (%rax),%eax
  402516:	84 c0                	test   %al,%al
  402518:	75 c2                	jne    4024dc <printf+0x1e0>
					screen[screen_ctr++] = *str++;
				format++;
  40251a:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
				continue;
  402521:	e9 39 01 00 00       	jmpq   40265f <printf+0x363>

			case 'x':
				printed=printed;
				int hex = va_arg(val, int);
  402526:	8b 45 88             	mov    -0x78(%rbp),%eax
  402529:	83 f8 30             	cmp    $0x30,%eax
  40252c:	73 17                	jae    402545 <printf+0x249>
  40252e:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  402532:	8b 45 88             	mov    -0x78(%rbp),%eax
  402535:	89 c0                	mov    %eax,%eax
  402537:	48 01 d0             	add    %rdx,%rax
  40253a:	8b 55 88             	mov    -0x78(%rbp),%edx
  40253d:	83 c2 08             	add    $0x8,%edx
  402540:	89 55 88             	mov    %edx,-0x78(%rbp)
  402543:	eb 0f                	jmp    402554 <printf+0x258>
  402545:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  402549:	48 89 d0             	mov    %rdx,%rax
  40254c:	48 83 c2 08          	add    $0x8,%rdx
  402550:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
  402554:	8b 00                	mov    (%rax),%eax
  402556:	89 45 b4             	mov    %eax,-0x4c(%rbp)
				if(hex<0)
  402559:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
  40255d:	79 35                	jns    402594 <printf+0x298>
				{
					screen[screen_ctr++]='-';
  40255f:	48 8b 05 02 20 20 00 	mov    0x202002(%rip),%rax        # 604568 <chdir+0x2011fe>
  402566:	8b 00                	mov    (%rax),%eax
  402568:	8d 48 01             	lea    0x1(%rax),%ecx
  40256b:	48 8b 15 f6 1f 20 00 	mov    0x201ff6(%rip),%rdx        # 604568 <chdir+0x2011fe>
  402572:	89 0a                	mov    %ecx,(%rdx)
  402574:	48 8b 15 f5 1f 20 00 	mov    0x201ff5(%rip),%rdx        # 604570 <chdir+0x201206>
  40257b:	48 98                	cltq   
  40257d:	c6 04 02 2d          	movb   $0x2d,(%rdx,%rax,1)
					print_num(-hex,16);
  402581:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  402584:	f7 d8                	neg    %eax
  402586:	be 10 00 00 00       	mov    $0x10,%esi
  40258b:	89 c7                	mov    %eax,%edi
  40258d:	e8 6c fb ff ff       	callq  4020fe <print_num>
  402592:	eb 0f                	jmp    4025a3 <printf+0x2a7>
				}
				else
					print_num(hex,16);
  402594:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  402597:	be 10 00 00 00       	mov    $0x10,%esi
  40259c:	89 c7                	mov    %eax,%edi
  40259e:	e8 5b fb ff ff       	callq  4020fe <print_num>

				format++;
  4025a3:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
				continue;
  4025aa:	e9 b0 00 00 00       	jmpq   40265f <printf+0x363>

			case 'p':
				printed=printed;
				long unsigned int ptr =(unsigned long int) va_arg(val, long int );
  4025af:	8b 45 88             	mov    -0x78(%rbp),%eax
  4025b2:	83 f8 30             	cmp    $0x30,%eax
  4025b5:	73 17                	jae    4025ce <printf+0x2d2>
  4025b7:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  4025bb:	8b 45 88             	mov    -0x78(%rbp),%eax
  4025be:	89 c0                	mov    %eax,%eax
  4025c0:	48 01 d0             	add    %rdx,%rax
  4025c3:	8b 55 88             	mov    -0x78(%rbp),%edx
  4025c6:	83 c2 08             	add    $0x8,%edx
  4025c9:	89 55 88             	mov    %edx,-0x78(%rbp)
  4025cc:	eb 0f                	jmp    4025dd <printf+0x2e1>
  4025ce:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  4025d2:	48 89 d0             	mov    %rdx,%rax
  4025d5:	48 83 c2 08          	add    $0x8,%rdx
  4025d9:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
  4025dd:	48 8b 00             	mov    (%rax),%rax
  4025e0:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
				print_ptr(ptr,16);
  4025e4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  4025e8:	be 10 00 00 00       	mov    $0x10,%esi
  4025ed:	48 89 c7             	mov    %rax,%rdi
  4025f0:	e8 01 fc ff ff       	callq  4021f6 <print_ptr>

				format++;
  4025f5:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
				continue;
  4025fc:	eb 61                	jmp    40265f <printf+0x363>


			case '%':
				printed=printed;
				char c='%';
  4025fe:	c6 45 a7 25          	movb   $0x25,-0x59(%rbp)

				screen[screen_ctr++] = c;
  402602:	48 8b 05 5f 1f 20 00 	mov    0x201f5f(%rip),%rax        # 604568 <chdir+0x2011fe>
  402609:	8b 00                	mov    (%rax),%eax
  40260b:	8d 48 01             	lea    0x1(%rax),%ecx
  40260e:	48 8b 15 53 1f 20 00 	mov    0x201f53(%rip),%rdx        # 604568 <chdir+0x2011fe>
  402615:	89 0a                	mov    %ecx,(%rdx)
  402617:	48 8b 0d 52 1f 20 00 	mov    0x201f52(%rip),%rcx        # 604570 <chdir+0x201206>
  40261e:	48 63 d0             	movslq %eax,%rdx
  402621:	0f b6 45 a7          	movzbl -0x59(%rbp),%eax
  402625:	88 04 11             	mov    %al,(%rcx,%rdx,1)
  402628:	eb 35                	jmp    40265f <printf+0x363>
			}
		}
		else
		{

			screen[screen_ctr++] = *format;
  40262a:	48 8b 05 37 1f 20 00 	mov    0x201f37(%rip),%rax        # 604568 <chdir+0x2011fe>
  402631:	8b 00                	mov    (%rax),%eax
  402633:	8d 48 01             	lea    0x1(%rax),%ecx
  402636:	48 8b 15 2b 1f 20 00 	mov    0x201f2b(%rip),%rdx        # 604568 <chdir+0x2011fe>
  40263d:	89 0a                	mov    %ecx,(%rdx)
  40263f:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  402646:	0f b6 12             	movzbl (%rdx),%edx
  402649:	48 8b 0d 20 1f 20 00 	mov    0x201f20(%rip),%rcx        # 604570 <chdir+0x201206>
  402650:	48 98                	cltq   
  402652:	88 14 01             	mov    %dl,(%rcx,%rax,1)
			++printed;
  402655:	ff 45 cc             	incl   -0x34(%rbp)
			++format;
  402658:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
	va_list val;
	int printed = 0;
	screen_ctr=0;
	va_start(val, format);

	while(*format)
  40265f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  402666:	0f b6 00             	movzbl (%rax),%eax
  402669:	84 c0                	test   %al,%al
  40266b:	0f 85 e1 fc ff ff    	jne    402352 <printf+0x56>
			++printed;
			++format;
		}
	}

	printed = write(1,screen, screen_ctr);
  402671:	48 8b 05 f0 1e 20 00 	mov    0x201ef0(%rip),%rax        # 604568 <chdir+0x2011fe>
  402678:	8b 00                	mov    (%rax),%eax
  40267a:	48 98                	cltq   
  40267c:	48 89 c2             	mov    %rax,%rdx
  40267f:	48 8b 05 ea 1e 20 00 	mov    0x201eea(%rip),%rax        # 604570 <chdir+0x201206>
  402686:	48 89 c6             	mov    %rax,%rsi
  402689:	bf 01 00 00 00       	mov    $0x1,%edi
  40268e:	e8 52 00 00 00       	callq  4026e5 <write>
  402693:	89 45 cc             	mov    %eax,-0x34(%rbp)
	if(printed < 0)
  402696:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  40269a:	79 07                	jns    4026a3 <printf+0x3a7>
		return -1;
  40269c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4026a1:	eb 09                	jmp    4026ac <printf+0x3b0>
	return screen_ctr;
  4026a3:	48 8b 05 be 1e 20 00 	mov    0x201ebe(%rip),%rax        # 604568 <chdir+0x2011fe>
  4026aa:	8b 00                	mov    (%rax),%eax

}
  4026ac:	c9                   	leaveq 
  4026ad:	c3                   	retq   

00000000004026ae <syscall_3>:
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
}

static __inline uint64_t syscall_3(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3) {
  4026ae:	55                   	push   %rbp
  4026af:	48 89 e5             	mov    %rsp,%rbp
  4026b2:	48 83 ec 30          	sub    $0x30,%rsp
  4026b6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  4026ba:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  4026be:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  4026c2:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)

	uint64_t ret;
    
	__asm__("movq %1,%%rax;"
  4026c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4026ca:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  4026ce:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  4026d2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  4026d6:	cd 80                	int    $0x80
  4026d8:	48 89 c0             	mov    %rax,%rax
  4026db:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %3, %%rsi;"
			"movq %4, %%rdx;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2),"m"(a3));
	return ret;
  4026df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  4026e3:	c9                   	leaveq 
  4026e4:	c3                   	retq   

00000000004026e5 <write>:
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>


ssize_t write(int fd, const void *buf, size_t count){
  4026e5:	55                   	push   %rbp
  4026e6:	48 89 e5             	mov    %rsp,%rbp
  4026e9:	48 83 ec 28          	sub    $0x28,%rsp
  4026ed:	89 7d ec             	mov    %edi,-0x14(%rbp)
  4026f0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  4026f4:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	int retvalue=syscall_3(SYS_write,fd,(uint64_t)buf,(uint64_t)count);
  4026f8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  4026fc:	8b 45 ec             	mov    -0x14(%rbp),%eax
  4026ff:	48 98                	cltq   
  402701:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  402705:	48 89 c6             	mov    %rax,%rsi
  402708:	bf 01 00 00 00       	mov    $0x1,%edi
  40270d:	e8 9c ff ff ff       	callq  4026ae <syscall_3>
  402712:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(retvalue >=0){
  402715:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  402719:	78 07                	js     402722 <write+0x3d>
		return retvalue;
  40271b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40271e:	48 98                	cltq   
  402720:	eb 07                	jmp    402729 <write+0x44>
	}
	return -1;
  402722:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
}
  402729:	c9                   	leaveq 
  40272a:	c3                   	retq   

000000000040272b <syscall_2>:
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
}

static __inline uint64_t syscall_2(uint64_t n, uint64_t a1, uint64_t a2) {
  40272b:	55                   	push   %rbp
  40272c:	48 89 e5             	mov    %rsp,%rbp
  40272f:	48 83 ec 28          	sub    $0x28,%rsp
  402733:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402737:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  40273b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	uint64_t ret;
	__asm__("movq %1,%%rax;"
  40273f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402743:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402747:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  40274b:	cd 80                	int    $0x80
  40274d:	48 89 c0             	mov    %rax,%rax
  402750:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %2,%%rdi;"
			"movq %3,%%rsi;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
  402754:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  402758:	c9                   	leaveq 
  402759:	c3                   	retq   

000000000040275a <opendir>:
#include<syscall.h>
#include<string.h>


void *opendir(const char *name)
{
  40275a:	55                   	push   %rbp
  40275b:	48 89 e5             	mov    %rsp,%rbp
  40275e:	48 83 ec 20          	sub    $0x20,%rsp
  402762:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	
	uint64_t fd=0;
  402766:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  40276d:	00 

	//WARNING THIS IS A HACK MUST ALLOCATE SPACE FR FD and return it

	fd = (uint64_t)syscall_2(SYS_open, (uint64_t) name, O_DIRECTORY | O_RDONLY);
  40276e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402772:	ba 00 00 01 00       	mov    $0x10000,%edx
  402777:	48 89 c6             	mov    %rax,%rsi
  40277a:	bf 02 00 00 00       	mov    $0x2,%edi
  40277f:	e8 a7 ff ff ff       	callq  40272b <syscall_2>
  402784:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	


	if(fd == -1){
  402788:	48 83 7d f8 ff       	cmpq   $0xffffffffffffffff,-0x8(%rbp)
  40278d:	75 1a                	jne    4027a9 <opendir+0x4f>
		printf("No such file or directory\n");
  40278f:	48 8d 3d 2d 11 00 00 	lea    0x112d(%rip),%rdi        # 4038c3 <chdir+0x559>
  402796:	b8 00 00 00 00       	mov    $0x0,%eax
  40279b:	e8 5c fb ff ff       	callq  4022fc <printf>
		return (void*)-1;
  4027a0:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  4027a7:	eb 04                	jmp    4027ad <opendir+0x53>
	}

	return (void*)fd;
  4027a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  4027ad:	c9                   	leaveq 
  4027ae:	c3                   	retq   

00000000004027af <syscall_3>:

static __inline uint64_t syscall_3(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3) {
  4027af:	55                   	push   %rbp
  4027b0:	48 89 e5             	mov    %rsp,%rbp
  4027b3:	48 83 ec 30          	sub    $0x30,%rsp
  4027b7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  4027bb:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  4027bf:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  4027c3:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)

	uint64_t ret;
    
	__asm__("movq %1,%%rax;"
  4027c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4027cb:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  4027cf:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  4027d3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  4027d7:	cd 80                	int    $0x80
  4027d9:	48 89 c0             	mov    %rax,%rax
  4027dc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %3, %%rsi;"
			"movq %4, %%rdx;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2),"m"(a3));
	return ret;
  4027e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  4027e4:	c9                   	leaveq 
  4027e5:	c3                   	retq   

00000000004027e6 <read>:
#include <sys/syscall.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>

ssize_t read(int fd, void *buf, size_t count){
  4027e6:	55                   	push   %rbp
  4027e7:	48 89 e5             	mov    %rsp,%rbp
  4027ea:	48 83 ec 30          	sub    $0x30,%rsp
  4027ee:	89 7d ec             	mov    %edi,-0x14(%rbp)
  4027f1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  4027f5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	int retvalue;
	retvalue =syscall_3(SYS_read,fd,(uint64_t)buf,(uint64_t)count);
  4027f9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  4027fd:	8b 45 ec             	mov    -0x14(%rbp),%eax
  402800:	48 98                	cltq   
  402802:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  402806:	48 89 c6             	mov    %rax,%rsi
  402809:	bf 00 00 00 00       	mov    $0x0,%edi
  40280e:	e8 9c ff ff ff       	callq  4027af <syscall_3>
  402813:	89 45 fc             	mov    %eax,-0x4(%rbp)
	
	if(retvalue < 0 ){
  402816:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  40281a:	79 1a                	jns    402836 <read+0x50>
		printf("Error in reading File\n");
  40281c:	48 8d 3d bb 10 00 00 	lea    0x10bb(%rip),%rdi        # 4038de <chdir+0x574>
  402823:	b8 00 00 00 00       	mov    $0x0,%eax
  402828:	e8 cf fa ff ff       	callq  4022fc <printf>
		return -1;
  40282d:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  402834:	eb 05                	jmp    40283b <read+0x55>
	}
	
	return retvalue;
  402836:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402839:	48 98                	cltq   

}
  40283b:	c9                   	leaveq 
  40283c:	c3                   	retq   

000000000040283d <syscall_1>:
			:"=r"(ret):"m"(n));

	return ret;
}

static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
  40283d:	55                   	push   %rbp
  40283e:	48 89 e5             	mov    %rsp,%rbp
  402841:	48 83 ec 20          	sub    $0x20,%rsp
  402845:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402849:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int64_t ret;

	__asm__("movq $78,%r15");
  40284d:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
	//__asm__("movq %0,%%rax;"
	//		::"m"(n));

	//while(1);

	if(n==60){
  402854:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402858:	48 83 f8 3c          	cmp    $0x3c,%rax
  40285c:	75 0c                	jne    40286a <syscall_1+0x2d>
		__asm__("movq %0,%%rax;"
  40285e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402862:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402866:	cd 80                	int    $0x80
  402868:	eb 11                	jmp    40287b <syscall_1+0x3e>

		//while(1);
	}
	else{

		__asm__("movq %1,%%rax;"
  40286a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40286e:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402872:	cd 80                	int    $0x80
  402874:	48 89 c0             	mov    %rax,%rax
  402877:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				"movq %2,%%rdi;"
				"int $0x80;"
				"movq %%rax,%0;"
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
  40287b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  40287f:	c9                   	leaveq 
  402880:	c3                   	retq   

0000000000402881 <pipe>:
#include<sys/defs.h>
#include<sys/syscall.h>
#include<syscall.h>
#include<stdlib.h>
int pipe(int fd[2])
{
  402881:	55                   	push   %rbp
  402882:	48 89 e5             	mov    %rsp,%rbp
  402885:	48 83 ec 18          	sub    $0x18,%rsp
  402889:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int retvalue;
	retvalue = syscall_1(SYS_pipe, (uint64_t)fd);
  40288d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402891:	48 89 c6             	mov    %rax,%rsi
  402894:	bf 16 00 00 00       	mov    $0x16,%edi
  402899:	e8 9f ff ff ff       	callq  40283d <syscall_1>
  40289e:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(retvalue >=0){
  4028a1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  4028a5:	78 05                	js     4028ac <pipe+0x2b>
		return retvalue;
  4028a7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4028aa:	eb 05                	jmp    4028b1 <pipe+0x30>
	}

	return -1;
  4028ac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  4028b1:	c9                   	leaveq 
  4028b2:	c3                   	retq   

00000000004028b3 <syscall_3>:
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
}

static __inline uint64_t syscall_3(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3) {
  4028b3:	55                   	push   %rbp
  4028b4:	48 89 e5             	mov    %rsp,%rbp
  4028b7:	48 83 ec 30          	sub    $0x30,%rsp
  4028bb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  4028bf:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  4028c3:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  4028c7:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)

	uint64_t ret;
    
	__asm__("movq %1,%%rax;"
  4028cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4028cf:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  4028d3:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  4028d7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  4028db:	cd 80                	int    $0x80
  4028dd:	48 89 c0             	mov    %rax,%rax
  4028e0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %3, %%rsi;"
			"movq %4, %%rdx;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2),"m"(a3));
	return ret;
  4028e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  4028e8:	c9                   	leaveq 
  4028e9:	c3                   	retq   

00000000004028ea <execve>:
#include<sys/syscall.h>
#include<syscall.h>
#include<stdlib.h>

int execve(const char *filename, char *const argv[], char *const envp[])
{
  4028ea:	55                   	push   %rbp
  4028eb:	48 89 e5             	mov    %rsp,%rbp
  4028ee:	48 83 ec 28          	sub    $0x28,%rsp
  4028f2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  4028f6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  4028fa:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
		int retvalue;
		retvalue = syscall_3(SYS_execve, (uint64_t)filename, (uint64_t)argv, (uint64_t)envp);
  4028fe:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  402902:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  402906:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40290a:	48 89 c6             	mov    %rax,%rsi
  40290d:	bf 3b 00 00 00       	mov    $0x3b,%edi
  402912:	e8 9c ff ff ff       	callq  4028b3 <syscall_3>
  402917:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if(retvalue >=0){
  40291a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  40291e:	78 05                	js     402925 <execve+0x3b>
			return retvalue;
  402920:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402923:	eb 05                	jmp    40292a <execve+0x40>
		}
		return -1;
  402925:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
  40292a:	c9                   	leaveq 
  40292b:	c3                   	retq   

000000000040292c <syscall_0>:
#define _SYSCALL_H

#include <sys/defs.h>
#include <sys/syscall.h>

static __inline uint64_t syscall_0(uint64_t n) {
  40292c:	55                   	push   %rbp
  40292d:	48 89 e5             	mov    %rsp,%rbp
  402930:	48 83 ec 18          	sub    $0x18,%rsp
  402934:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	uint64_t ret;
	__asm__("movq %1,%%rax;"
  402938:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40293c:	cd 80                	int    $0x80
  40293e:	48 89 c0             	mov    %rax,%rax
  402941:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n));

	return ret;
  402945:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  402949:	c9                   	leaveq 
  40294a:	c3                   	retq   

000000000040294b <fork>:
#include <stdio.h>
#include <errno.h>


pid_t fork()
{
  40294b:	55                   	push   %rbp
  40294c:	48 89 e5             	mov    %rsp,%rbp
  40294f:	48 83 ec 10          	sub    $0x10,%rsp
	int retvalue;

	retvalue = syscall_0(SYS_fork);
  402953:	bf 39 00 00 00       	mov    $0x39,%edi
  402958:	e8 cf ff ff ff       	callq  40292c <syscall_0>
  40295d:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(retvalue >=0){
  402960:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  402964:	78 05                	js     40296b <fork+0x20>
		return retvalue;
  402966:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402969:	eb 05                	jmp    402970 <fork+0x25>
	}
	return -1;
  40296b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
  402970:	c9                   	leaveq 
  402971:	c3                   	retq   

0000000000402972 <syscall_1>:

static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
  402972:	55                   	push   %rbp
  402973:	48 89 e5             	mov    %rsp,%rbp
  402976:	48 83 ec 20          	sub    $0x20,%rsp
  40297a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  40297e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int64_t ret;

	__asm__("movq $78,%r15");
  402982:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
	//__asm__("movq %0,%%rax;"
	//		::"m"(n));

	//while(1);

	if(n==60){
  402989:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40298d:	48 83 f8 3c          	cmp    $0x3c,%rax
  402991:	75 0c                	jne    40299f <syscall_1+0x2d>
		__asm__("movq %0,%%rax;"
  402993:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402997:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  40299b:	cd 80                	int    $0x80
  40299d:	eb 11                	jmp    4029b0 <syscall_1+0x3e>

		//while(1);
	}
	else{

		__asm__("movq %1,%%rax;"
  40299f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4029a3:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  4029a7:	cd 80                	int    $0x80
  4029a9:	48 89 c0             	mov    %rax,%rax
  4029ac:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				"movq %2,%%rdi;"
				"int $0x80;"
				"movq %%rax,%0;"
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
  4029b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  4029b4:	c9                   	leaveq 
  4029b5:	c3                   	retq   

00000000004029b6 <exit>:
#include <sys/defs.h>
#include <syscall.h>
#include <stdlib.h>
#include <sys/syscall.h>

void exit(int status){
  4029b6:	55                   	push   %rbp
  4029b7:	48 89 e5             	mov    %rsp,%rbp
  4029ba:	48 83 ec 08          	sub    $0x8,%rsp
  4029be:	89 7d fc             	mov    %edi,-0x4(%rbp)

	syscall_1(SYS_exit,44);
  4029c1:	be 2c 00 00 00       	mov    $0x2c,%esi
  4029c6:	bf 3c 00 00 00       	mov    $0x3c,%edi
  4029cb:	e8 a2 ff ff ff       	callq  402972 <syscall_1>


}
  4029d0:	c9                   	leaveq 
  4029d1:	c3                   	retq   

00000000004029d2 <strlen>:
#include <errno.h>



int strlen(const char *str)
{
  4029d2:	55                   	push   %rbp
  4029d3:	48 89 e5             	mov    %rsp,%rbp
  4029d6:	48 83 ec 18          	sub    $0x18,%rsp
  4029da:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	const char *ptr=str;
  4029de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4029e2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for(;*ptr != '\0'; ptr++);
  4029e6:	eb 04                	jmp    4029ec <strlen+0x1a>
  4029e8:	48 ff 45 f8          	incq   -0x8(%rbp)
  4029ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4029f0:	0f b6 00             	movzbl (%rax),%eax
  4029f3:	84 c0                	test   %al,%al
  4029f5:	75 f1                	jne    4029e8 <strlen+0x16>

	return ptr-str;
  4029f7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  4029fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4029ff:	48 29 c2             	sub    %rax,%rdx
  402a02:	48 89 d0             	mov    %rdx,%rax
}
  402a05:	c9                   	leaveq 
  402a06:	c3                   	retq   

0000000000402a07 <strcpy>:

char* strcpy(char* dst, const char* src)
{
  402a07:	55                   	push   %rbp
  402a08:	48 89 e5             	mov    %rsp,%rbp
  402a0b:	48 83 ec 30          	sub    $0x30,%rsp
  402a0f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  402a13:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	////printf("In strcpy\n");
	int i, len=strlen(src);
  402a17:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  402a1b:	48 89 c7             	mov    %rax,%rdi
  402a1e:	e8 af ff ff ff       	callq  4029d2 <strlen>
  402a23:	89 45 ec             	mov    %eax,-0x14(%rbp)
	//printf("In strlen.... length of src %d\n",len);
	char* ptr=dst;
  402a26:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402a2a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	for(i=0; i<=len; i++)
  402a2e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  402a35:	eb 21                	jmp    402a58 <strcpy+0x51>
	{
		*ptr++ = src[i];
  402a37:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402a3b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  402a3f:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  402a43:	8b 55 fc             	mov    -0x4(%rbp),%edx
  402a46:	48 63 ca             	movslq %edx,%rcx
  402a49:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  402a4d:	48 01 ca             	add    %rcx,%rdx
  402a50:	0f b6 12             	movzbl (%rdx),%edx
  402a53:	88 10                	mov    %dl,(%rax)
	////printf("In strcpy\n");
	int i, len=strlen(src);
	//printf("In strlen.... length of src %d\n",len);
	char* ptr=dst;

	for(i=0; i<=len; i++)
  402a55:	ff 45 fc             	incl   -0x4(%rbp)
  402a58:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402a5b:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  402a5e:	7e d7                	jle    402a37 <strcpy+0x30>
	{
		*ptr++ = src[i];
	}
	return dst;
  402a60:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
}
  402a64:	c9                   	leaveq 
  402a65:	c3                   	retq   

0000000000402a66 <strcmp>:


int strcmp(const char *str1, const char *str2)
{
  402a66:	55                   	push   %rbp
  402a67:	48 89 e5             	mov    %rsp,%rbp
  402a6a:	48 83 ec 10          	sub    $0x10,%rsp
  402a6e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  402a72:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)

	while(1)
	{
		////printf("In strcmp\n");

		if(*str1 != *str2)
  402a76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402a7a:	0f b6 10             	movzbl (%rax),%edx
  402a7d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402a81:	0f b6 00             	movzbl (%rax),%eax
  402a84:	38 c2                	cmp    %al,%dl
  402a86:	74 1a                	je     402aa2 <strcmp+0x3c>
			return (*str1 - *str2);
  402a88:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402a8c:	0f b6 00             	movzbl (%rax),%eax
  402a8f:	0f be d0             	movsbl %al,%edx
  402a92:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402a96:	0f b6 00             	movzbl (%rax),%eax
  402a99:	0f be c0             	movsbl %al,%eax
  402a9c:	29 c2                	sub    %eax,%edx
  402a9e:	89 d0                	mov    %edx,%eax
  402aa0:	eb 49                	jmp    402aeb <strcmp+0x85>

		else if((*str1 == *str2) && (*(str1+1) == *(str2 + 1)) && (*(str1 + 1) == '\0'))
  402aa2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402aa6:	0f b6 10             	movzbl (%rax),%edx
  402aa9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402aad:	0f b6 00             	movzbl (%rax),%eax
  402ab0:	38 c2                	cmp    %al,%dl
  402ab2:	75 2d                	jne    402ae1 <strcmp+0x7b>
  402ab4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402ab8:	48 ff c0             	inc    %rax
  402abb:	0f b6 10             	movzbl (%rax),%edx
  402abe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402ac2:	48 ff c0             	inc    %rax
  402ac5:	0f b6 00             	movzbl (%rax),%eax
  402ac8:	38 c2                	cmp    %al,%dl
  402aca:	75 15                	jne    402ae1 <strcmp+0x7b>
  402acc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402ad0:	48 ff c0             	inc    %rax
  402ad3:	0f b6 00             	movzbl (%rax),%eax
  402ad6:	84 c0                	test   %al,%al
  402ad8:	75 07                	jne    402ae1 <strcmp+0x7b>
			return 0;
  402ada:	b8 00 00 00 00       	mov    $0x0,%eax
  402adf:	eb 0a                	jmp    402aeb <strcmp+0x85>


		str1++;
  402ae1:	48 ff 45 f8          	incq   -0x8(%rbp)
		str2++;
  402ae5:	48 ff 45 f0          	incq   -0x10(%rbp)

	}
  402ae9:	eb 8b                	jmp    402a76 <strcmp+0x10>

	return 0;
}
  402aeb:	c9                   	leaveq 
  402aec:	c3                   	retq   

0000000000402aed <strstr>:

const char *strstr(const char *haystack, const char *needle)
{
  402aed:	55                   	push   %rbp
  402aee:	48 89 e5             	mov    %rsp,%rbp
  402af1:	48 83 ec 20          	sub    $0x20,%rsp
  402af5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402af9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	//printf("In strstrt\n %s %s\n\n", haystack,  needle);
	int len = strlen(haystack), i, j;
  402afd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402b01:	48 89 c7             	mov    %rax,%rdi
  402b04:	e8 c9 fe ff ff       	callq  4029d2 <strlen>
  402b09:	89 45 f4             	mov    %eax,-0xc(%rbp)
	for(i=0; i< len; i++)
  402b0c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  402b13:	e9 a0 00 00 00       	jmpq   402bb8 <strstr+0xcb>
	{
		for(j = i; j< strlen(needle); j++)
  402b18:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402b1b:	89 45 f8             	mov    %eax,-0x8(%rbp)
  402b1e:	eb 31                	jmp    402b51 <strstr+0x64>
		{
			if(*(haystack+i+j) != *(needle+j))
  402b20:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402b23:	48 63 d0             	movslq %eax,%rdx
  402b26:	8b 45 f8             	mov    -0x8(%rbp),%eax
  402b29:	48 98                	cltq   
  402b2b:	48 01 c2             	add    %rax,%rdx
  402b2e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402b32:	48 01 d0             	add    %rdx,%rax
  402b35:	0f b6 10             	movzbl (%rax),%edx
  402b38:	8b 45 f8             	mov    -0x8(%rbp),%eax
  402b3b:	48 63 c8             	movslq %eax,%rcx
  402b3e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402b42:	48 01 c8             	add    %rcx,%rax
  402b45:	0f b6 00             	movzbl (%rax),%eax
  402b48:	38 c2                	cmp    %al,%dl
  402b4a:	74 02                	je     402b4e <strstr+0x61>
				break;
  402b4c:	eb 14                	jmp    402b62 <strstr+0x75>

	//printf("In strstrt\n %s %s\n\n", haystack,  needle);
	int len = strlen(haystack), i, j;
	for(i=0; i< len; i++)
	{
		for(j = i; j< strlen(needle); j++)
  402b4e:	ff 45 f8             	incl   -0x8(%rbp)
  402b51:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402b55:	48 89 c7             	mov    %rax,%rdi
  402b58:	e8 75 fe ff ff       	callq  4029d2 <strlen>
  402b5d:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  402b60:	7f be                	jg     402b20 <strstr+0x33>
		{
			if(*(haystack+i+j) != *(needle+j))
				break;
		}	

		if( (j == strlen(needle) ) && (*(haystack+i+j-1) == *(needle+j-1)))
  402b62:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402b66:	48 89 c7             	mov    %rax,%rdi
  402b69:	e8 64 fe ff ff       	callq  4029d2 <strlen>
  402b6e:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  402b71:	75 42                	jne    402bb5 <strstr+0xc8>
  402b73:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402b76:	48 63 d0             	movslq %eax,%rdx
  402b79:	8b 45 f8             	mov    -0x8(%rbp),%eax
  402b7c:	48 98                	cltq   
  402b7e:	48 01 d0             	add    %rdx,%rax
  402b81:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  402b85:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402b89:	48 01 d0             	add    %rdx,%rax
  402b8c:	0f b6 10             	movzbl (%rax),%edx
  402b8f:	8b 45 f8             	mov    -0x8(%rbp),%eax
  402b92:	48 98                	cltq   
  402b94:	48 8d 48 ff          	lea    -0x1(%rax),%rcx
  402b98:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402b9c:	48 01 c8             	add    %rcx,%rax
  402b9f:	0f b6 00             	movzbl (%rax),%eax
  402ba2:	38 c2                	cmp    %al,%dl
  402ba4:	75 0f                	jne    402bb5 <strstr+0xc8>
		{
			return (haystack + i);
  402ba6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402ba9:	48 63 d0             	movslq %eax,%rdx
  402bac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402bb0:	48 01 d0             	add    %rdx,%rax
  402bb3:	eb 14                	jmp    402bc9 <strstr+0xdc>
const char *strstr(const char *haystack, const char *needle)
{

	//printf("In strstrt\n %s %s\n\n", haystack,  needle);
	int len = strlen(haystack), i, j;
	for(i=0; i< len; i++)
  402bb5:	ff 45 fc             	incl   -0x4(%rbp)
  402bb8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402bbb:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  402bbe:	0f 8c 54 ff ff ff    	jl     402b18 <strstr+0x2b>
		{
			return (haystack + i);
		}
	}

	return NULL;
  402bc4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  402bc9:	c9                   	leaveq 
  402bca:	c3                   	retq   

0000000000402bcb <strcat>:

char *strcat(char *dst, const char *src)
{
  402bcb:	55                   	push   %rbp
  402bcc:	48 89 e5             	mov    %rsp,%rbp
  402bcf:	48 83 ec 10          	sub    $0x10,%rsp
  402bd3:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  402bd7:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	strcpy(&dst[strlen(dst)],src);
  402bdb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402bdf:	48 89 c7             	mov    %rax,%rdi
  402be2:	e8 eb fd ff ff       	callq  4029d2 <strlen>
  402be7:	48 63 d0             	movslq %eax,%rdx
  402bea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402bee:	48 01 c2             	add    %rax,%rdx
  402bf1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402bf5:	48 89 c6             	mov    %rax,%rsi
  402bf8:	48 89 d7             	mov    %rdx,%rdi
  402bfb:	e8 07 fe ff ff       	callq  402a07 <strcpy>
	//printf("after cat: %s\n\n\n",dst);
	return dst;
  402c00:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  402c04:	c9                   	leaveq 
  402c05:	c3                   	retq   

0000000000402c06 <strerror>:

uint64_t strerror(int err)
{
  402c06:	55                   	push   %rbp
  402c07:	48 89 e5             	mov    %rsp,%rbp
  402c0a:	48 83 ec 10          	sub    $0x10,%rsp
  402c0e:	89 7d fc             	mov    %edi,-0x4(%rbp)

	switch(err)
  402c11:	83 7d fc 24          	cmpl   $0x24,-0x4(%rbp)
  402c15:	0f 87 5a 03 00 00    	ja     402f75 <strerror+0x36f>
  402c1b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402c1e:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  402c25:	00 
  402c26:	48 8d 05 af 0f 00 00 	lea    0xfaf(%rip),%rax        # 403bdc <chdir+0x872>
  402c2d:	8b 04 02             	mov    (%rdx,%rax,1),%eax
  402c30:	48 63 d0             	movslq %eax,%rdx
  402c33:	48 8d 05 a2 0f 00 00 	lea    0xfa2(%rip),%rax        # 403bdc <chdir+0x872>
  402c3a:	48 01 d0             	add    %rdx,%rax
  402c3d:	ff e0                	jmpq   *%rax
	{

	case EPERM    : {return  printf("Operation not permitted \n");break;}
  402c3f:	48 8d 3d b2 0c 00 00 	lea    0xcb2(%rip),%rdi        # 4038f8 <chdir+0x58e>
  402c46:	b8 00 00 00 00       	mov    $0x0,%eax
  402c4b:	e8 ac f6 ff ff       	callq  4022fc <printf>
  402c50:	48 98                	cltq   
  402c52:	e9 23 03 00 00       	jmpq   402f7a <strerror+0x374>
	case ENOENT   : {return  printf("No such file or directory \n");break;}
  402c57:	48 8d 3d b4 0c 00 00 	lea    0xcb4(%rip),%rdi        # 403912 <chdir+0x5a8>
  402c5e:	b8 00 00 00 00       	mov    $0x0,%eax
  402c63:	e8 94 f6 ff ff       	callq  4022fc <printf>
  402c68:	48 98                	cltq   
  402c6a:	e9 0b 03 00 00       	jmpq   402f7a <strerror+0x374>
	case ESRCH    : {return  printf("No such process \n");;break;}
  402c6f:	48 8d 3d b8 0c 00 00 	lea    0xcb8(%rip),%rdi        # 40392e <chdir+0x5c4>
  402c76:	b8 00 00 00 00       	mov    $0x0,%eax
  402c7b:	e8 7c f6 ff ff       	callq  4022fc <printf>
  402c80:	48 98                	cltq   
  402c82:	e9 f3 02 00 00       	jmpq   402f7a <strerror+0x374>
	case EINTR    : {return  printf("Interrupted system call \n");break;}
  402c87:	48 8d 3d b2 0c 00 00 	lea    0xcb2(%rip),%rdi        # 403940 <chdir+0x5d6>
  402c8e:	b8 00 00 00 00       	mov    $0x0,%eax
  402c93:	e8 64 f6 ff ff       	callq  4022fc <printf>
  402c98:	48 98                	cltq   
  402c9a:	e9 db 02 00 00       	jmpq   402f7a <strerror+0x374>
	case EIO      : {return  printf("error \n");;break;}
  402c9f:	48 8d 3d b4 0c 00 00 	lea    0xcb4(%rip),%rdi        # 40395a <chdir+0x5f0>
  402ca6:	b8 00 00 00 00       	mov    $0x0,%eax
  402cab:	e8 4c f6 ff ff       	callq  4022fc <printf>
  402cb0:	48 98                	cltq   
  402cb2:	e9 c3 02 00 00       	jmpq   402f7a <strerror+0x374>
	case ENXIO    : {return  printf("No such device or address \n");break;}
  402cb7:	48 8d 3d a4 0c 00 00 	lea    0xca4(%rip),%rdi        # 403962 <chdir+0x5f8>
  402cbe:	b8 00 00 00 00       	mov    $0x0,%eax
  402cc3:	e8 34 f6 ff ff       	callq  4022fc <printf>
  402cc8:	48 98                	cltq   
  402cca:	e9 ab 02 00 00       	jmpq   402f7a <strerror+0x374>
	case E2BIG    : {return  printf("Argument list too long \n");break;}
  402ccf:	48 8d 3d a8 0c 00 00 	lea    0xca8(%rip),%rdi        # 40397e <chdir+0x614>
  402cd6:	b8 00 00 00 00       	mov    $0x0,%eax
  402cdb:	e8 1c f6 ff ff       	callq  4022fc <printf>
  402ce0:	48 98                	cltq   
  402ce2:	e9 93 02 00 00       	jmpq   402f7a <strerror+0x374>
	case ENOEXEC  : {return  printf("Exec format error \n");break;}
  402ce7:	48 8d 3d a9 0c 00 00 	lea    0xca9(%rip),%rdi        # 403997 <chdir+0x62d>
  402cee:	b8 00 00 00 00       	mov    $0x0,%eax
  402cf3:	e8 04 f6 ff ff       	callq  4022fc <printf>
  402cf8:	48 98                	cltq   
  402cfa:	e9 7b 02 00 00       	jmpq   402f7a <strerror+0x374>
	case EBADF    : {return  printf("Bad file number \n");break;}
  402cff:	48 8d 3d a5 0c 00 00 	lea    0xca5(%rip),%rdi        # 4039ab <chdir+0x641>
  402d06:	b8 00 00 00 00       	mov    $0x0,%eax
  402d0b:	e8 ec f5 ff ff       	callq  4022fc <printf>
  402d10:	48 98                	cltq   
  402d12:	e9 63 02 00 00       	jmpq   402f7a <strerror+0x374>
	case ECHILD   : {return  printf("No child processes \n");break;}
  402d17:	48 8d 3d 9f 0c 00 00 	lea    0xc9f(%rip),%rdi        # 4039bd <chdir+0x653>
  402d1e:	b8 00 00 00 00       	mov    $0x0,%eax
  402d23:	e8 d4 f5 ff ff       	callq  4022fc <printf>
  402d28:	48 98                	cltq   
  402d2a:	e9 4b 02 00 00       	jmpq   402f7a <strerror+0x374>
	case EAGAIN   : {return  printf("Try again \n");;break;}
  402d2f:	48 8d 3d 9c 0c 00 00 	lea    0xc9c(%rip),%rdi        # 4039d2 <chdir+0x668>
  402d36:	b8 00 00 00 00       	mov    $0x0,%eax
  402d3b:	e8 bc f5 ff ff       	callq  4022fc <printf>
  402d40:	48 98                	cltq   
  402d42:	e9 33 02 00 00       	jmpq   402f7a <strerror+0x374>
	case ENOMEM   : {return  printf("Out of memory \n");;break;}
  402d47:	48 8d 3d 90 0c 00 00 	lea    0xc90(%rip),%rdi        # 4039de <chdir+0x674>
  402d4e:	b8 00 00 00 00       	mov    $0x0,%eax
  402d53:	e8 a4 f5 ff ff       	callq  4022fc <printf>
  402d58:	48 98                	cltq   
  402d5a:	e9 1b 02 00 00       	jmpq   402f7a <strerror+0x374>
	case EACCES   : {return  printf("Permission denied \n");break;}
  402d5f:	48 8d 3d 88 0c 00 00 	lea    0xc88(%rip),%rdi        # 4039ee <chdir+0x684>
  402d66:	b8 00 00 00 00       	mov    $0x0,%eax
  402d6b:	e8 8c f5 ff ff       	callq  4022fc <printf>
  402d70:	48 98                	cltq   
  402d72:	e9 03 02 00 00       	jmpq   402f7a <strerror+0x374>
	case EFAULT   : {return  printf("Bad address \n");;break;}
  402d77:	48 8d 3d 84 0c 00 00 	lea    0xc84(%rip),%rdi        # 403a02 <chdir+0x698>
  402d7e:	b8 00 00 00 00       	mov    $0x0,%eax
  402d83:	e8 74 f5 ff ff       	callq  4022fc <printf>
  402d88:	48 98                	cltq   
  402d8a:	e9 eb 01 00 00       	jmpq   402f7a <strerror+0x374>
	case ENOTBLK  : {return  printf("Block device required \n");break;}
  402d8f:	48 8d 3d 7a 0c 00 00 	lea    0xc7a(%rip),%rdi        # 403a10 <chdir+0x6a6>
  402d96:	b8 00 00 00 00       	mov    $0x0,%eax
  402d9b:	e8 5c f5 ff ff       	callq  4022fc <printf>
  402da0:	48 98                	cltq   
  402da2:	e9 d3 01 00 00       	jmpq   402f7a <strerror+0x374>
	case EBUSY    : {return  printf("Device or resource busy \n");break;}
  402da7:	48 8d 3d 7a 0c 00 00 	lea    0xc7a(%rip),%rdi        # 403a28 <chdir+0x6be>
  402dae:	b8 00 00 00 00       	mov    $0x0,%eax
  402db3:	e8 44 f5 ff ff       	callq  4022fc <printf>
  402db8:	48 98                	cltq   
  402dba:	e9 bb 01 00 00       	jmpq   402f7a <strerror+0x374>
	case EEXIST   : {return  printf("File exists \n");;break;}
  402dbf:	48 8d 3d 7c 0c 00 00 	lea    0xc7c(%rip),%rdi        # 403a42 <chdir+0x6d8>
  402dc6:	b8 00 00 00 00       	mov    $0x0,%eax
  402dcb:	e8 2c f5 ff ff       	callq  4022fc <printf>
  402dd0:	48 98                	cltq   
  402dd2:	e9 a3 01 00 00       	jmpq   402f7a <strerror+0x374>
	case EXDEV    : {return  printf("Cross-device link \n");break;}
  402dd7:	48 8d 3d 72 0c 00 00 	lea    0xc72(%rip),%rdi        # 403a50 <chdir+0x6e6>
  402dde:	b8 00 00 00 00       	mov    $0x0,%eax
  402de3:	e8 14 f5 ff ff       	callq  4022fc <printf>
  402de8:	48 98                	cltq   
  402dea:	e9 8b 01 00 00       	jmpq   402f7a <strerror+0x374>
	case ENODEV   : {return  printf("No such device \n");break;}
  402def:	48 8d 3d 6e 0c 00 00 	lea    0xc6e(%rip),%rdi        # 403a64 <chdir+0x6fa>
  402df6:	b8 00 00 00 00       	mov    $0x0,%eax
  402dfb:	e8 fc f4 ff ff       	callq  4022fc <printf>
  402e00:	48 98                	cltq   
  402e02:	e9 73 01 00 00       	jmpq   402f7a <strerror+0x374>
	case ENOTDIR  : {return  printf("Not a directory \n");break;}
  402e07:	48 8d 3d 67 0c 00 00 	lea    0xc67(%rip),%rdi        # 403a75 <chdir+0x70b>
  402e0e:	b8 00 00 00 00       	mov    $0x0,%eax
  402e13:	e8 e4 f4 ff ff       	callq  4022fc <printf>
  402e18:	48 98                	cltq   
  402e1a:	e9 5b 01 00 00       	jmpq   402f7a <strerror+0x374>
	case EISDIR   : {return  printf("Is a directory \n");break;}
  402e1f:	48 8d 3d 61 0c 00 00 	lea    0xc61(%rip),%rdi        # 403a87 <chdir+0x71d>
  402e26:	b8 00 00 00 00       	mov    $0x0,%eax
  402e2b:	e8 cc f4 ff ff       	callq  4022fc <printf>
  402e30:	48 98                	cltq   
  402e32:	e9 43 01 00 00       	jmpq   402f7a <strerror+0x374>
	case EINVAL   : {return  printf("Invalid argument \n");break;}
  402e37:	48 8d 3d 5a 0c 00 00 	lea    0xc5a(%rip),%rdi        # 403a98 <chdir+0x72e>
  402e3e:	b8 00 00 00 00       	mov    $0x0,%eax
  402e43:	e8 b4 f4 ff ff       	callq  4022fc <printf>
  402e48:	48 98                	cltq   
  402e4a:	e9 2b 01 00 00       	jmpq   402f7a <strerror+0x374>
	case ENFILE   : {return  printf("File table overflow \n");break;}
  402e4f:	48 8d 3d 55 0c 00 00 	lea    0xc55(%rip),%rdi        # 403aab <chdir+0x741>
  402e56:	b8 00 00 00 00       	mov    $0x0,%eax
  402e5b:	e8 9c f4 ff ff       	callq  4022fc <printf>
  402e60:	48 98                	cltq   
  402e62:	e9 13 01 00 00       	jmpq   402f7a <strerror+0x374>
	case EMFILE   : {return  printf("Too many open files \n");break;}
  402e67:	48 8d 3d 53 0c 00 00 	lea    0xc53(%rip),%rdi        # 403ac1 <chdir+0x757>
  402e6e:	b8 00 00 00 00       	mov    $0x0,%eax
  402e73:	e8 84 f4 ff ff       	callq  4022fc <printf>
  402e78:	48 98                	cltq   
  402e7a:	e9 fb 00 00 00       	jmpq   402f7a <strerror+0x374>
	case ENOTTY   : {return  printf("Not a typewriter \n");break;}
  402e7f:	48 8d 3d 51 0c 00 00 	lea    0xc51(%rip),%rdi        # 403ad7 <chdir+0x76d>
  402e86:	b8 00 00 00 00       	mov    $0x0,%eax
  402e8b:	e8 6c f4 ff ff       	callq  4022fc <printf>
  402e90:	48 98                	cltq   
  402e92:	e9 e3 00 00 00       	jmpq   402f7a <strerror+0x374>
	case ETXTBSY  : {return  printf("Text file busy \n");break;}
  402e97:	48 8d 3d 4c 0c 00 00 	lea    0xc4c(%rip),%rdi        # 403aea <chdir+0x780>
  402e9e:	b8 00 00 00 00       	mov    $0x0,%eax
  402ea3:	e8 54 f4 ff ff       	callq  4022fc <printf>
  402ea8:	48 98                	cltq   
  402eaa:	e9 cb 00 00 00       	jmpq   402f7a <strerror+0x374>
	case EFBIG    : {return  printf("File too large \n");break;}
  402eaf:	48 8d 3d 45 0c 00 00 	lea    0xc45(%rip),%rdi        # 403afb <chdir+0x791>
  402eb6:	b8 00 00 00 00       	mov    $0x0,%eax
  402ebb:	e8 3c f4 ff ff       	callq  4022fc <printf>
  402ec0:	48 98                	cltq   
  402ec2:	e9 b3 00 00 00       	jmpq   402f7a <strerror+0x374>
	case ENOSPC   : {return  printf("No space left on device \n");break;}
  402ec7:	48 8d 3d 3e 0c 00 00 	lea    0xc3e(%rip),%rdi        # 403b0c <chdir+0x7a2>
  402ece:	b8 00 00 00 00       	mov    $0x0,%eax
  402ed3:	e8 24 f4 ff ff       	callq  4022fc <printf>
  402ed8:	48 98                	cltq   
  402eda:	e9 9b 00 00 00       	jmpq   402f7a <strerror+0x374>
	case ESPIPE   : {return  printf("Illegal seek \n");break;}
  402edf:	48 8d 3d 40 0c 00 00 	lea    0xc40(%rip),%rdi        # 403b26 <chdir+0x7bc>
  402ee6:	b8 00 00 00 00       	mov    $0x0,%eax
  402eeb:	e8 0c f4 ff ff       	callq  4022fc <printf>
  402ef0:	48 98                	cltq   
  402ef2:	e9 83 00 00 00       	jmpq   402f7a <strerror+0x374>
	case EROFS    : {return  printf("Read-only file system \n");break;}
  402ef7:	48 8d 3d 37 0c 00 00 	lea    0xc37(%rip),%rdi        # 403b35 <chdir+0x7cb>
  402efe:	b8 00 00 00 00       	mov    $0x0,%eax
  402f03:	e8 f4 f3 ff ff       	callq  4022fc <printf>
  402f08:	48 98                	cltq   
  402f0a:	eb 6e                	jmp    402f7a <strerror+0x374>
	case EMLINK   : {return  printf("Too many links \n");break;}
  402f0c:	48 8d 3d 3a 0c 00 00 	lea    0xc3a(%rip),%rdi        # 403b4d <chdir+0x7e3>
  402f13:	b8 00 00 00 00       	mov    $0x0,%eax
  402f18:	e8 df f3 ff ff       	callq  4022fc <printf>
  402f1d:	48 98                	cltq   
  402f1f:	eb 59                	jmp    402f7a <strerror+0x374>
	case EPIPE    : {return  printf("Broken pipe \n");break;}
  402f21:	48 8d 3d 36 0c 00 00 	lea    0xc36(%rip),%rdi        # 403b5e <chdir+0x7f4>
  402f28:	b8 00 00 00 00       	mov    $0x0,%eax
  402f2d:	e8 ca f3 ff ff       	callq  4022fc <printf>
  402f32:	48 98                	cltq   
  402f34:	eb 44                	jmp    402f7a <strerror+0x374>
	case EDOM     : {return  printf("Math argument out of domain of func \n");break;}
  402f36:	48 8d 3d 33 0c 00 00 	lea    0xc33(%rip),%rdi        # 403b70 <chdir+0x806>
  402f3d:	b8 00 00 00 00       	mov    $0x0,%eax
  402f42:	e8 b5 f3 ff ff       	callq  4022fc <printf>
  402f47:	48 98                	cltq   
  402f49:	eb 2f                	jmp    402f7a <strerror+0x374>
	case ERANGE   : {return  printf("Math result not representable \n");break;}
  402f4b:	48 8d 3d 46 0c 00 00 	lea    0xc46(%rip),%rdi        # 403b98 <chdir+0x82e>
  402f52:	b8 00 00 00 00       	mov    $0x0,%eax
  402f57:	e8 a0 f3 ff ff       	callq  4022fc <printf>
  402f5c:	48 98                	cltq   
  402f5e:	eb 1a                	jmp    402f7a <strerror+0x374>
	case ENAMETOOLONG:	{return printf(" The path is too long to search \n");break;}
  402f60:	48 8d 3d 51 0c 00 00 	lea    0xc51(%rip),%rdi        # 403bb8 <chdir+0x84e>
  402f67:	b8 00 00 00 00       	mov    $0x0,%eax
  402f6c:	e8 8b f3 ff ff       	callq  4022fc <printf>
  402f71:	48 98                	cltq   
  402f73:	eb 05                	jmp    402f7a <strerror+0x374>
	
	//return printf("error occured.\n");
	}
return 0;
  402f75:	b8 00 00 00 00       	mov    $0x0,%eax
  402f7a:	c9                   	leaveq 
  402f7b:	c3                   	retq   

0000000000402f7c <syscall_1>:
			:"=r"(ret):"m"(n));

	return ret;
}

static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
  402f7c:	55                   	push   %rbp
  402f7d:	48 89 e5             	mov    %rsp,%rbp
  402f80:	48 83 ec 20          	sub    $0x20,%rsp
  402f84:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402f88:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int64_t ret;

	__asm__("movq $78,%r15");
  402f8c:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
	//__asm__("movq %0,%%rax;"
	//		::"m"(n));

	//while(1);

	if(n==60){
  402f93:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402f97:	48 83 f8 3c          	cmp    $0x3c,%rax
  402f9b:	75 0c                	jne    402fa9 <syscall_1+0x2d>
		__asm__("movq %0,%%rax;"
  402f9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402fa1:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402fa5:	cd 80                	int    $0x80
  402fa7:	eb 11                	jmp    402fba <syscall_1+0x3e>

		//while(1);
	}
	else{

		__asm__("movq %1,%%rax;"
  402fa9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402fad:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402fb1:	cd 80                	int    $0x80
  402fb3:	48 89 c0             	mov    %rax,%rax
  402fb6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				"movq %2,%%rdi;"
				"int $0x80;"
				"movq %%rax,%0;"
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
  402fba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  402fbe:	c9                   	leaveq 
  402fbf:	c3                   	retq   

0000000000402fc0 <make_head>:

enum {NEW_MCB, NO_MCB, REUSE_MCB};
enum {FREE, IN_USE};

void make_head(char *addr, int size) 
{
  402fc0:	55                   	push   %rbp
  402fc1:	48 89 e5             	mov    %rsp,%rbp
  402fc4:	48 83 ec 1c          	sub    $0x1c,%rsp
  402fc8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402fcc:	89 75 e4             	mov    %esi,-0x1c(%rbp)
    MCB_P head         = (MCB_P)addr;
  402fcf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402fd3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    head->is_available = FREE;
  402fd7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402fdb:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
    head->size         = size;
  402fe1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402fe5:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  402fe8:	89 50 04             	mov    %edx,0x4(%rax)
}
  402feb:	c9                   	leaveq 
  402fec:	c3                   	retq   

0000000000402fed <alloc_new>:

void *alloc_new(int aligned_size)
{
  402fed:	55                   	push   %rbp
  402fee:	48 89 e5             	mov    %rsp,%rbp
  402ff1:	48 83 ec 30          	sub    $0x30,%rsp
  402ff5:	89 7d dc             	mov    %edi,-0x24(%rbp)
    char *add;
    uint64_t no_of_pages = 0, sz;    
  402ff8:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  402fff:	00 
    MCB_P p_mcb;
    
    sz          = sizeof(MCB_t);
  403000:	48 c7 45 f0 08 00 00 	movq   $0x8,-0x10(%rbp)
  403007:	00 
    no_of_pages = (aligned_size + sz) /(PAGESIZE + 1) + 1;
  403008:	8b 45 dc             	mov    -0x24(%rbp),%eax
  40300b:	48 63 d0             	movslq %eax,%rdx
  40300e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  403012:	48 01 d0             	add    %rdx,%rax
  403015:	48 ba f1 ff 00 f0 ff 	movabs $0xfff000fff000fff1,%rdx
  40301c:	00 f0 ff 
  40301f:	48 f7 e2             	mul    %rdx
  403022:	48 89 d0             	mov    %rdx,%rax
  403025:	48 c1 e8 0c          	shr    $0xc,%rax
  403029:	48 ff c0             	inc    %rax
  40302c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    add = (char*)syscall_1(SYS_brk, (uint64_t)no_of_pages*4096);    
  403030:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  403034:	48 c1 e0 0c          	shl    $0xc,%rax
  403038:	48 89 c6             	mov    %rax,%rsi
  40303b:	bf 0c 00 00 00       	mov    $0xc,%edi
  403040:	e8 37 ff ff ff       	callq  402f7c <syscall_1>
  403045:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    printf("add=%p",add);
  403049:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40304d:	48 89 c6             	mov    %rax,%rsi
  403050:	48 8d 3d 19 0c 00 00 	lea    0xc19(%rip),%rdi        # 403c70 <chdir+0x906>
  403057:	b8 00 00 00 00       	mov    $0x0,%eax
  40305c:	e8 9b f2 ff ff       	callq  4022fc <printf>
    if (heap_end == 0) {
  403061:	48 8b 05 28 16 20 00 	mov    0x201628(%rip),%rax        # 604690 <heap_end>
  403068:	48 85 c0             	test   %rax,%rax
  40306b:	75 2a                	jne    403097 <alloc_new+0xaa>
        mem_start_p   = add;
  40306d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403071:	48 89 05 10 16 20 00 	mov    %rax,0x201610(%rip)        # 604688 <mem_start_p>
        mcb_count     = 0;
  403078:	c7 05 1e 16 20 00 00 	movl   $0x0,0x20161e(%rip)        # 6046a0 <mcb_count>
  40307f:	00 00 00 
        allocated_mem = 0;
  403082:	c7 05 10 16 20 00 00 	movl   $0x0,0x201610(%rip)        # 60469c <allocated_mem>
  403089:	00 00 00 
        heap_end = add; 
  40308c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403090:	48 89 05 f9 15 20 00 	mov    %rax,0x2015f9(%rip)        # 604690 <heap_end>
    }
    
    heap_end = (char*)((uint64_t)add + (uint64_t)(PAGESIZE * no_of_pages));
  403097:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40309b:	48 c1 e0 0c          	shl    $0xc,%rax
  40309f:	48 89 c2             	mov    %rax,%rdx
  4030a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4030a6:	48 01 d0             	add    %rdx,%rax
  4030a9:	48 89 05 e0 15 20 00 	mov    %rax,0x2015e0(%rip)        # 604690 <heap_end>
    max_mem += PAGESIZE * no_of_pages; 
  4030b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4030b4:	c1 e0 0c             	shl    $0xc,%eax
  4030b7:	89 c2                	mov    %eax,%edx
  4030b9:	8b 05 d9 15 20 00    	mov    0x2015d9(%rip),%eax        # 604698 <max_mem>
  4030bf:	01 d0                	add    %edx,%eax
  4030c1:	89 05 d1 15 20 00    	mov    %eax,0x2015d1(%rip)        # 604698 <max_mem>
    
    p_mcb               = (MCB_P)add; 
  4030c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4030cb:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    p_mcb->is_available = IN_USE;
  4030cf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4030d3:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    p_mcb->size         = aligned_size + sz; 
  4030d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4030dd:	89 c2                	mov    %eax,%edx
  4030df:	8b 45 dc             	mov    -0x24(%rbp),%eax
  4030e2:	01 d0                	add    %edx,%eax
  4030e4:	89 c2                	mov    %eax,%edx
  4030e6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4030ea:	89 50 04             	mov    %edx,0x4(%rax)
    mcb_count++;    
  4030ed:	8b 05 ad 15 20 00    	mov    0x2015ad(%rip),%eax        # 6046a0 <mcb_count>
  4030f3:	ff c0                	inc    %eax
  4030f5:	89 05 a5 15 20 00    	mov    %eax,0x2015a5(%rip)        # 6046a0 <mcb_count>

    if (PAGESIZE * no_of_pages > aligned_size + sz) {
  4030fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4030ff:	48 c1 e0 0c          	shl    $0xc,%rax
  403103:	48 89 c1             	mov    %rax,%rcx
  403106:	8b 45 dc             	mov    -0x24(%rbp),%eax
  403109:	48 63 d0             	movslq %eax,%rdx
  40310c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  403110:	48 01 d0             	add    %rdx,%rax
  403113:	48 39 c1             	cmp    %rax,%rcx
  403116:	76 34                	jbe    40314c <alloc_new+0x15f>
        make_head(((char *)p_mcb + aligned_size + sz), (PAGESIZE * no_of_pages - aligned_size - sz));
  403118:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40311c:	c1 e0 0c             	shl    $0xc,%eax
  40311f:	89 c2                	mov    %eax,%edx
  403121:	8b 45 dc             	mov    -0x24(%rbp),%eax
  403124:	29 c2                	sub    %eax,%edx
  403126:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40312a:	29 c2                	sub    %eax,%edx
  40312c:	89 d0                	mov    %edx,%eax
  40312e:	8b 55 dc             	mov    -0x24(%rbp),%edx
  403131:	48 63 ca             	movslq %edx,%rcx
  403134:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  403138:	48 01 d1             	add    %rdx,%rcx
  40313b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  40313f:	48 01 ca             	add    %rcx,%rdx
  403142:	89 c6                	mov    %eax,%esi
  403144:	48 89 d7             	mov    %rdx,%rdi
  403147:	e8 74 fe ff ff       	callq  402fc0 <make_head>
    }

    allocated_mem += aligned_size; 
  40314c:	8b 15 4a 15 20 00    	mov    0x20154a(%rip),%edx        # 60469c <allocated_mem>
  403152:	8b 45 dc             	mov    -0x24(%rbp),%eax
  403155:	01 d0                	add    %edx,%eax
  403157:	89 05 3f 15 20 00    	mov    %eax,0x20153f(%rip)        # 60469c <allocated_mem>
    
    return ((void *) p_mcb + sz);
  40315d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  403161:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  403165:	48 01 d0             	add    %rdx,%rax
}
  403168:	c9                   	leaveq 
  403169:	c3                   	retq   

000000000040316a <malloc>:

void* malloc(size_t elem_size)
{
  40316a:	55                   	push   %rbp
  40316b:	48 89 e5             	mov    %rsp,%rbp
  40316e:	48 83 ec 30          	sub    $0x30,%rsp
  403172:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    MCB_P p_mcb;
    int flag, sz, temp = 0, aligned_size;
  403176:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)

    // Align elem_size to header size
    aligned_size = ((((elem_size - 1) >> 3) + 1) << 3);
  40317d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  403181:	48 ff c8             	dec    %rax
  403184:	48 c1 e8 03          	shr    $0x3,%rax
  403188:	48 ff c0             	inc    %rax
  40318b:	48 c1 e0 03          	shl    $0x3,%rax
  40318f:	89 45 ec             	mov    %eax,-0x14(%rbp)
    heap_end=heap_end;
  403192:	48 8b 05 f7 14 20 00 	mov    0x2014f7(%rip),%rax        # 604690 <heap_end>
  403199:	48 89 05 f0 14 20 00 	mov    %rax,0x2014f0(%rip)        # 604690 <heap_end>
    if (heap_end == 0) {
  4031a0:	48 8b 05 e9 14 20 00 	mov    0x2014e9(%rip),%rax        # 604690 <heap_end>
  4031a7:	48 85 c0             	test   %rax,%rax
  4031aa:	75 0f                	jne    4031bb <malloc+0x51>
        /*no heap has been assigned yet*/
        return alloc_new(aligned_size);
  4031ac:	8b 45 ec             	mov    -0x14(%rbp),%eax
  4031af:	89 c7                	mov    %eax,%edi
  4031b1:	e8 37 fe ff ff       	callq  402fed <alloc_new>
  4031b6:	e9 1a 01 00 00       	jmpq   4032d5 <malloc+0x16b>
    } else {

        flag  = NO_MCB;
  4031bb:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
        p_mcb = (MCB_P)mem_start_p;
  4031c2:	48 8b 05 bf 14 20 00 	mov    0x2014bf(%rip),%rax        # 604688 <mem_start_p>
  4031c9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        sz    = sizeof(MCB_t);
  4031cd:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%rbp)

        //printf("\nheap_end : %p\treqd size: %p",heap_end, ((char *)p_mcb + aligned_size + sz));
        while (heap_end >= ((char *)p_mcb + aligned_size + sz)) {
  4031d4:	eb 33                	jmp    403209 <malloc+0x9f>
            if (p_mcb->is_available == FREE) {
  4031d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4031da:	8b 00                	mov    (%rax),%eax
  4031dc:	85 c0                	test   %eax,%eax
  4031de:	75 1c                	jne    4031fc <malloc+0x92>
                if (p_mcb->size >= (aligned_size + sz)) {
  4031e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4031e4:	8b 40 04             	mov    0x4(%rax),%eax
  4031e7:	8b 55 e8             	mov    -0x18(%rbp),%edx
  4031ea:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  4031ed:	01 ca                	add    %ecx,%edx
  4031ef:	39 d0                	cmp    %edx,%eax
  4031f1:	7c 09                	jl     4031fc <malloc+0x92>
                    flag = REUSE_MCB;
  4031f3:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%rbp)
                    break;
  4031fa:	eb 2e                	jmp    40322a <malloc+0xc0>
                }
            }
            p_mcb = (MCB_P) ((char *)p_mcb + p_mcb->size);
  4031fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  403200:	8b 40 04             	mov    0x4(%rax),%eax
  403203:	48 98                	cltq   
  403205:	48 01 45 f8          	add    %rax,-0x8(%rbp)
        flag  = NO_MCB;
        p_mcb = (MCB_P)mem_start_p;
        sz    = sizeof(MCB_t);

        //printf("\nheap_end : %p\treqd size: %p",heap_end, ((char *)p_mcb + aligned_size + sz));
        while (heap_end >= ((char *)p_mcb + aligned_size + sz)) {
  403209:	8b 45 ec             	mov    -0x14(%rbp),%eax
  40320c:	48 63 d0             	movslq %eax,%rdx
  40320f:	8b 45 e8             	mov    -0x18(%rbp),%eax
  403212:	48 98                	cltq   
  403214:	48 01 c2             	add    %rax,%rdx
  403217:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40321b:	48 01 c2             	add    %rax,%rdx
  40321e:	48 8b 05 6b 14 20 00 	mov    0x20146b(%rip),%rax        # 604690 <heap_end>
  403225:	48 39 c2             	cmp    %rax,%rdx
  403228:	76 ac                	jbe    4031d6 <malloc+0x6c>
                }
            }
            p_mcb = (MCB_P) ((char *)p_mcb + p_mcb->size);
        }

        if (flag != NO_MCB) {
  40322a:	83 7d f4 01          	cmpl   $0x1,-0xc(%rbp)
  40322e:	0f 84 97 00 00 00    	je     4032cb <malloc+0x161>
            p_mcb->is_available = IN_USE;
  403234:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  403238:	c7 00 01 00 00 00    	movl   $0x1,(%rax)

            if (flag == REUSE_MCB) {
  40323e:	83 7d f4 02          	cmpl   $0x2,-0xc(%rbp)
  403242:	75 67                	jne    4032ab <malloc+0x141>
                if (p_mcb->size > aligned_size + sz) {
  403244:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  403248:	8b 40 04             	mov    0x4(%rax),%eax
  40324b:	8b 55 e8             	mov    -0x18(%rbp),%edx
  40324e:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  403251:	01 ca                	add    %ecx,%edx
  403253:	39 d0                	cmp    %edx,%eax
  403255:	7e 46                	jle    40329d <malloc+0x133>
                    temp        = p_mcb->size; 
  403257:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40325b:	8b 40 04             	mov    0x4(%rax),%eax
  40325e:	89 45 f0             	mov    %eax,-0x10(%rbp)
                    p_mcb->size = aligned_size + sz;
  403261:	8b 45 e8             	mov    -0x18(%rbp),%eax
  403264:	8b 55 ec             	mov    -0x14(%rbp),%edx
  403267:	01 c2                	add    %eax,%edx
  403269:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40326d:	89 50 04             	mov    %edx,0x4(%rax)

                    make_head(((char *)p_mcb + aligned_size + sz),(temp - aligned_size - sz));
  403270:	8b 45 ec             	mov    -0x14(%rbp),%eax
  403273:	8b 55 f0             	mov    -0x10(%rbp),%edx
  403276:	29 c2                	sub    %eax,%edx
  403278:	89 d0                	mov    %edx,%eax
  40327a:	2b 45 e8             	sub    -0x18(%rbp),%eax
  40327d:	8b 55 ec             	mov    -0x14(%rbp),%edx
  403280:	48 63 ca             	movslq %edx,%rcx
  403283:	8b 55 e8             	mov    -0x18(%rbp),%edx
  403286:	48 63 d2             	movslq %edx,%rdx
  403289:	48 01 d1             	add    %rdx,%rcx
  40328c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  403290:	48 01 ca             	add    %rcx,%rdx
  403293:	89 c6                	mov    %eax,%esi
  403295:	48 89 d7             	mov    %rdx,%rdi
  403298:	e8 23 fd ff ff       	callq  402fc0 <make_head>
                }        
                mcb_count++;
  40329d:	8b 05 fd 13 20 00    	mov    0x2013fd(%rip),%eax        # 6046a0 <mcb_count>
  4032a3:	ff c0                	inc    %eax
  4032a5:	89 05 f5 13 20 00    	mov    %eax,0x2013f5(%rip)        # 6046a0 <mcb_count>
            }
            allocated_mem += aligned_size;
  4032ab:	8b 15 eb 13 20 00    	mov    0x2013eb(%rip),%edx        # 60469c <allocated_mem>
  4032b1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  4032b4:	01 d0                	add    %edx,%eax
  4032b6:	89 05 e0 13 20 00    	mov    %eax,0x2013e0(%rip)        # 60469c <allocated_mem>
            return ((char *) p_mcb + sz);
  4032bc:	8b 45 e8             	mov    -0x18(%rbp),%eax
  4032bf:	48 63 d0             	movslq %eax,%rdx
  4032c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4032c6:	48 01 d0             	add    %rdx,%rax
  4032c9:	eb 0a                	jmp    4032d5 <malloc+0x16b>
        }

        /*when no hole is found to match the request*/
        return alloc_new(aligned_size); 
  4032cb:	8b 45 ec             	mov    -0x14(%rbp),%eax
  4032ce:	89 c7                	mov    %eax,%edi
  4032d0:	e8 18 fd ff ff       	callq  402fed <alloc_new>
    }

}
  4032d5:	c9                   	leaveq 
  4032d6:	c3                   	retq   

00000000004032d7 <free>:

void free(void *p)
{
  4032d7:	55                   	push   %rbp
  4032d8:	48 89 e5             	mov    %rsp,%rbp
  4032db:	48 83 ec 18          	sub    $0x18,%rsp
  4032df:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    MCB_P ptr = (MCB_P)p;
  4032e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4032e7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    ptr--;
  4032eb:	48 83 6d f8 08       	subq   $0x8,-0x8(%rbp)

    mcb_count--;
  4032f0:	8b 05 aa 13 20 00    	mov    0x2013aa(%rip),%eax        # 6046a0 <mcb_count>
  4032f6:	ff c8                	dec    %eax
  4032f8:	89 05 a2 13 20 00    	mov    %eax,0x2013a2(%rip)        # 6046a0 <mcb_count>
    ptr->is_available = FREE;
  4032fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  403302:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
    allocated_mem    -= (ptr->size - sizeof(MCB_t));
  403308:	8b 05 8e 13 20 00    	mov    0x20138e(%rip),%eax        # 60469c <allocated_mem>
  40330e:	89 c2                	mov    %eax,%edx
  403310:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  403314:	8b 40 04             	mov    0x4(%rax),%eax
  403317:	29 c2                	sub    %eax,%edx
  403319:	89 d0                	mov    %edx,%eax
  40331b:	83 c0 08             	add    $0x8,%eax
  40331e:	89 05 78 13 20 00    	mov    %eax,0x201378(%rip)        # 60469c <allocated_mem>

}
  403324:	c9                   	leaveq 
  403325:	c3                   	retq   

0000000000403326 <syscall_1>:
			:"=r"(ret):"m"(n));

	return ret;
}

static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
  403326:	55                   	push   %rbp
  403327:	48 89 e5             	mov    %rsp,%rbp
  40332a:	48 83 ec 20          	sub    $0x20,%rsp
  40332e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  403332:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int64_t ret;

	__asm__("movq $78,%r15");
  403336:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
	//__asm__("movq %0,%%rax;"
	//		::"m"(n));

	//while(1);

	if(n==60){
  40333d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403341:	48 83 f8 3c          	cmp    $0x3c,%rax
  403345:	75 0c                	jne    403353 <syscall_1+0x2d>
		__asm__("movq %0,%%rax;"
  403347:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40334b:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  40334f:	cd 80                	int    $0x80
  403351:	eb 11                	jmp    403364 <syscall_1+0x3e>

		//while(1);
	}
	else{

		__asm__("movq %1,%%rax;"
  403353:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403357:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  40335b:	cd 80                	int    $0x80
  40335d:	48 89 c0             	mov    %rax,%rax
  403360:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				"movq %2,%%rdi;"
				"int $0x80;"
				"movq %%rax,%0;"
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
  403364:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  403368:	c9                   	leaveq 
  403369:	c3                   	retq   

000000000040336a <chdir>:
#include <sys/syscall.h>
#include <syscall.h>
#include <errno.h>
#include <stdlib.h>

int chdir(const char *path){
  40336a:	55                   	push   %rbp
  40336b:	48 89 e5             	mov    %rsp,%rbp
  40336e:	48 83 ec 18          	sub    $0x18,%rsp
  403372:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	int retvalue;
	retvalue=syscall_1(SYS_chdir,(uint64_t)path);
  403376:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40337a:	48 89 c6             	mov    %rax,%rsi
  40337d:	bf 50 00 00 00       	mov    $0x50,%edi
  403382:	e8 9f ff ff ff       	callq  403326 <syscall_1>
  403387:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(retvalue >=0){
  40338a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  40338e:	78 05                	js     403395 <chdir+0x2b>
		return retvalue;
  403390:	8b 45 fc             	mov    -0x4(%rbp),%eax
  403393:	eb 05                	jmp    40339a <chdir+0x30>
	}
	return -1;
  403395:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
  40339a:	c9                   	leaveq 
  40339b:	c3                   	retq   
