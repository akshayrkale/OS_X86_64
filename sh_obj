
rootfs/bin/sh:     file format elf64-x86-64


Disassembly of section .text:

00000000004000e8 <_start>:
#include <stdlib.h>
#include <stdio.h>
int main(int argc, char* argv[], char* envp[]);

void _start(void) {
  4000e8:	55                   	push   %rbp
  4000e9:	48 89 e5             	mov    %rsp,%rbp
  4000ec:	48 83 ec 10          	sub    $0x10,%rsp
//	int argc = 1;
//	char* argv[0];
//	char* envp[0];
	int res;
//	res = main(0, NULL, NULL);
 volatile int x=89;
  4000f0:	c7 45 f8 59 00 00 00 	movl   $0x59,-0x8(%rbp)
  res=  main(*((uint64_t*)(&x+0x3UL)),(char**)(uint64_t*)(&x+0x5UL), (char **)((&x+5) +  (2*(*(&x+3)+ 1))));
  4000f7:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  4000fb:	48 83 c0 0c          	add    $0xc,%rax
  4000ff:	8b 00                	mov    (%rax),%eax
  400101:	ff c0                	inc    %eax
  400103:	48 98                	cltq   
  400105:	48 c1 e0 03          	shl    $0x3,%rax
  400109:	48 8d 50 14          	lea    0x14(%rax),%rdx
  40010d:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  400111:	48 01 c2             	add    %rax,%rdx
  400114:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  400118:	48 83 c0 0c          	add    $0xc,%rax
  40011c:	48 8b 00             	mov    (%rax),%rax
  40011f:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  400123:	48 83 c1 14          	add    $0x14,%rcx
  400127:	48 89 ce             	mov    %rcx,%rsi
  40012a:	89 c7                	mov    %eax,%edi
  40012c:	e8 d0 15 00 00       	callq  401701 <main>
  400131:	89 45 fc             	mov    %eax,-0x4(%rbp)

    exit(res);
  400134:	8b 45 fc             	mov    -0x4(%rbp),%eax
  400137:	89 c7                	mov    %eax,%edi
  400139:	e8 66 28 00 00       	callq  4029a4 <exit>
  }
  40013e:	c9                   	leaveq 
  40013f:	c3                   	retq   

0000000000400140 <changedir>:
#include <errno.h>
#include <string.h>
#include <shell.h>


void changedir(char* path){
  400140:	55                   	push   %rbp
  400141:	48 89 e5             	mov    %rsp,%rbp
  400144:	48 81 ec 40 02 00 00 	sub    $0x240,%rsp
  40014b:	48 89 bd c8 fd ff ff 	mov    %rdi,-0x238(%rbp)

int pathLen = strlen(path);
  400152:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  400159:	48 89 c7             	mov    %rax,%rdi
  40015c:	e8 5f 28 00 00       	callq  4029c0 <strlen>
  400161:	89 45 ec             	mov    %eax,-0x14(%rbp)

    int forward=0;
  400164:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    int back = 0;
  40016b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
    char temp[20];
    int i=0;
  400172:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    int x=0;
  400179:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
    int numOfComponents = 0;
  400180:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)

    char components[10][20];

    for(forward=0;forward<pathLen;){
  400187:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  40018e:	e9 1a 01 00 00       	jmpq   4002ad <changedir+0x16d>
        
        if(forward == 0 && path[forward] == '/'){
  400193:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  400197:	75 3b                	jne    4001d4 <changedir+0x94>
  400199:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40019c:	48 63 d0             	movslq %eax,%rdx
  40019f:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  4001a6:	48 01 d0             	add    %rdx,%rax
  4001a9:	0f b6 00             	movzbl (%rax),%eax
  4001ac:	3c 2f                	cmp    $0x2f,%al
  4001ae:	75 24                	jne    4001d4 <changedir+0x94>
            strcpy(components[0],"/");
  4001b0:	48 8d 85 08 ff ff ff 	lea    -0xf8(%rbp),%rax
  4001b7:	48 8d 35 d2 31 00 00 	lea    0x31d2(%rip),%rsi        # 403390 <chdir+0x38>
  4001be:	48 89 c7             	mov    %rax,%rdi
  4001c1:	e8 2f 28 00 00       	callq  4029f5 <strcpy>
            back++;
  4001c6:	ff 45 f8             	incl   -0x8(%rbp)
            forward++;
  4001c9:	ff 45 fc             	incl   -0x4(%rbp)
            numOfComponents++;
  4001cc:	ff 45 f0             	incl   -0x10(%rbp)
            continue;
  4001cf:	e9 d9 00 00 00       	jmpq   4002ad <changedir+0x16d>
        }

        if(path[forward] == '/'){
  4001d4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4001d7:	48 63 d0             	movslq %eax,%rdx
  4001da:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  4001e1:	48 01 d0             	add    %rdx,%rax
  4001e4:	0f b6 00             	movzbl (%rax),%eax
  4001e7:	3c 2f                	cmp    $0x2f,%al
  4001e9:	0f 85 bb 00 00 00    	jne    4002aa <changedir+0x16a>

            if(path[forward-1] == '/'){
  4001ef:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4001f2:	48 98                	cltq   
  4001f4:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  4001f8:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  4001ff:	48 01 d0             	add    %rdx,%rax
  400202:	0f b6 00             	movzbl (%rax),%eax
  400205:	3c 2f                	cmp    $0x2f,%al
  400207:	75 16                	jne    40021f <changedir+0xdf>
                printf("Malformed path\n");
  400209:	48 8d 3d 82 31 00 00 	lea    0x3182(%rip),%rdi        # 403392 <chdir+0x3a>
  400210:	b8 00 00 00 00       	mov    $0x0,%eax
  400215:	e8 d0 20 00 00       	callq  4022ea <printf>
  40021a:	e9 4d 03 00 00       	jmpq   40056c <changedir+0x42c>
                return;
            }

            //copy from back till forward-1
            i=0;
  40021f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
            
            x = (forward-back);
  400226:	8b 45 f8             	mov    -0x8(%rbp),%eax
  400229:	8b 55 fc             	mov    -0x4(%rbp),%edx
  40022c:	29 c2                	sub    %eax,%edx
  40022e:	89 d0                	mov    %edx,%eax
  400230:	89 45 e8             	mov    %eax,-0x18(%rbp)
            while(i< x){
  400233:	eb 28                	jmp    40025d <changedir+0x11d>

                temp[i++] = path[back++];
  400235:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400238:	8d 50 01             	lea    0x1(%rax),%edx
  40023b:	89 55 f4             	mov    %edx,-0xc(%rbp)
  40023e:	8b 55 f8             	mov    -0x8(%rbp),%edx
  400241:	8d 4a 01             	lea    0x1(%rdx),%ecx
  400244:	89 4d f8             	mov    %ecx,-0x8(%rbp)
  400247:	48 63 ca             	movslq %edx,%rcx
  40024a:	48 8b 95 c8 fd ff ff 	mov    -0x238(%rbp),%rdx
  400251:	48 01 ca             	add    %rcx,%rdx
  400254:	0f b6 12             	movzbl (%rdx),%edx
  400257:	48 98                	cltq   
  400259:	88 54 05 d0          	mov    %dl,-0x30(%rbp,%rax,1)

            //copy from back till forward-1
            i=0;
            
            x = (forward-back);
            while(i< x){
  40025d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400260:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  400263:	7c d0                	jl     400235 <changedir+0xf5>

                temp[i++] = path[back++];
              
            }
            temp[i]= '\0';
  400265:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400268:	48 98                	cltq   
  40026a:	c6 44 05 d0 00       	movb   $0x0,-0x30(%rbp,%rax,1)
            //printf("%s\n", temp );
            
            strcpy(components[numOfComponents],temp);
  40026f:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
  400276:	8b 45 f0             	mov    -0x10(%rbp),%eax
  400279:	48 98                	cltq   
  40027b:	48 c1 e0 02          	shl    $0x2,%rax
  40027f:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  400286:	00 
  400287:	48 01 c8             	add    %rcx,%rax
  40028a:	48 01 c2             	add    %rax,%rdx
  40028d:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  400291:	48 89 c6             	mov    %rax,%rsi
  400294:	48 89 d7             	mov    %rdx,%rdi
  400297:	e8 59 27 00 00       	callq  4029f5 <strcpy>
            //printf("%s\n", &components[0] );
            forward++;
  40029c:	ff 45 fc             	incl   -0x4(%rbp)
            back = forward;
  40029f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4002a2:	89 45 f8             	mov    %eax,-0x8(%rbp)
            numOfComponents++;
  4002a5:	ff 45 f0             	incl   -0x10(%rbp)
            continue;
  4002a8:	eb 03                	jmp    4002ad <changedir+0x16d>

        }

        forward++;
  4002aa:	ff 45 fc             	incl   -0x4(%rbp)
    int x=0;
    int numOfComponents = 0;

    char components[10][20];

    for(forward=0;forward<pathLen;){
  4002ad:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4002b0:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  4002b3:	0f 8c da fe ff ff    	jl     400193 <changedir+0x53>

        forward++;

    } //End of for

    if(path[forward-1] != '/'){
  4002b9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4002bc:	48 98                	cltq   
  4002be:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  4002c2:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  4002c9:	48 01 d0             	add    %rdx,%rax
  4002cc:	0f b6 00             	movzbl (%rax),%eax
  4002cf:	3c 2f                	cmp    $0x2f,%al
  4002d1:	0f 84 83 00 00 00    	je     40035a <changedir+0x21a>

        i=0;
  4002d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
        x = forward-back;
  4002de:	8b 45 f8             	mov    -0x8(%rbp),%eax
  4002e1:	8b 55 fc             	mov    -0x4(%rbp),%edx
  4002e4:	29 c2                	sub    %eax,%edx
  4002e6:	89 d0                	mov    %edx,%eax
  4002e8:	89 45 e8             	mov    %eax,-0x18(%rbp)
        while(i<x){
  4002eb:	eb 28                	jmp    400315 <changedir+0x1d5>
            temp[i++]=path[back++];
  4002ed:	8b 45 f4             	mov    -0xc(%rbp),%eax
  4002f0:	8d 50 01             	lea    0x1(%rax),%edx
  4002f3:	89 55 f4             	mov    %edx,-0xc(%rbp)
  4002f6:	8b 55 f8             	mov    -0x8(%rbp),%edx
  4002f9:	8d 4a 01             	lea    0x1(%rdx),%ecx
  4002fc:	89 4d f8             	mov    %ecx,-0x8(%rbp)
  4002ff:	48 63 ca             	movslq %edx,%rcx
  400302:	48 8b 95 c8 fd ff ff 	mov    -0x238(%rbp),%rdx
  400309:	48 01 ca             	add    %rcx,%rdx
  40030c:	0f b6 12             	movzbl (%rdx),%edx
  40030f:	48 98                	cltq   
  400311:	88 54 05 d0          	mov    %dl,-0x30(%rbp,%rax,1)

    if(path[forward-1] != '/'){

        i=0;
        x = forward-back;
        while(i<x){
  400315:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400318:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  40031b:	7c d0                	jl     4002ed <changedir+0x1ad>
            temp[i++]=path[back++];
        }
        temp[i] = '\0';
  40031d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400320:	48 98                	cltq   
  400322:	c6 44 05 d0 00       	movb   $0x0,-0x30(%rbp,%rax,1)
        strcpy(components[numOfComponents++],temp);
  400327:	8b 45 f0             	mov    -0x10(%rbp),%eax
  40032a:	8d 50 01             	lea    0x1(%rax),%edx
  40032d:	89 55 f0             	mov    %edx,-0x10(%rbp)
  400330:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
  400337:	48 98                	cltq   
  400339:	48 c1 e0 02          	shl    $0x2,%rax
  40033d:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  400344:	00 
  400345:	48 01 c8             	add    %rcx,%rax
  400348:	48 01 c2             	add    %rax,%rdx
  40034b:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  40034f:	48 89 c6             	mov    %rax,%rsi
  400352:	48 89 d7             	mov    %rdx,%rdi
  400355:	e8 9b 26 00 00       	callq  4029f5 <strcpy>

    char buff[100];
    char originalWorkingDirectory[100];
    char toSend[100];

    getcwd(originalWorkingDirectory,100);
  40035a:	48 8d 85 40 fe ff ff 	lea    -0x1c0(%rbp),%rax
  400361:	be 64 00 00 00       	mov    $0x64,%esi
  400366:	48 89 c7             	mov    %rax,%rdi
  400369:	e8 55 1b 00 00       	callq  401ec3 <getcwd>

   
    i=0;
  40036e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

    
    while(i < numOfComponents){
  400375:	e9 e4 01 00 00       	jmpq   40055e <changedir+0x41e>

        if(i == numOfComponents){
  40037a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  40037d:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  400380:	75 05                	jne    400387 <changedir+0x247>
            break;
  400382:	e9 e5 01 00 00       	jmpq   40056c <changedir+0x42c>
        }

        if(i==0){
  400387:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  40038b:	75 5c                	jne    4003e9 <changedir+0x2a9>
            strcpy(toSend,components[i]);
  40038d:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
  400394:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400397:	48 98                	cltq   
  400399:	48 c1 e0 02          	shl    $0x2,%rax
  40039d:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  4003a4:	00 
  4003a5:	48 01 c8             	add    %rcx,%rax
  4003a8:	48 01 c2             	add    %rax,%rdx
  4003ab:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  4003b2:	48 89 d6             	mov    %rdx,%rsi
  4003b5:	48 89 c7             	mov    %rax,%rdi
  4003b8:	e8 38 26 00 00       	callq  4029f5 <strcpy>
            
            if(chdir(toSend) == -1){
  4003bd:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  4003c4:	48 89 c7             	mov    %rax,%rdi
  4003c7:	e8 8c 2f 00 00       	callq  403358 <chdir>
  4003cc:	83 f8 ff             	cmp    $0xffffffff,%eax
  4003cf:	0f 85 7c 01 00 00    	jne    400551 <changedir+0x411>
            chdir(originalWorkingDirectory);
  4003d5:	48 8d 85 40 fe ff ff 	lea    -0x1c0(%rbp),%rax
  4003dc:	48 89 c7             	mov    %rax,%rdi
  4003df:	e8 74 2f 00 00       	callq  403358 <chdir>
            break;
  4003e4:	e9 83 01 00 00       	jmpq   40056c <changedir+0x42c>
            }
        }

        else if(strcmp(components[i],".")==0){
  4003e9:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
  4003f0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  4003f3:	48 98                	cltq   
  4003f5:	48 c1 e0 02          	shl    $0x2,%rax
  4003f9:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  400400:	00 
  400401:	48 01 c8             	add    %rcx,%rax
  400404:	48 01 d0             	add    %rdx,%rax
  400407:	48 8d 35 94 2f 00 00 	lea    0x2f94(%rip),%rsi        # 4033a2 <chdir+0x4a>
  40040e:	48 89 c7             	mov    %rax,%rdi
  400411:	e8 3e 26 00 00       	callq  402a54 <strcmp>
  400416:	85 c0                	test   %eax,%eax
  400418:	75 08                	jne    400422 <changedir+0x2e2>

        	//nothing to do
        	i++;
  40041a:	ff 45 f4             	incl   -0xc(%rbp)
        	continue;
  40041d:	e9 3c 01 00 00       	jmpq   40055e <changedir+0x41e>

        }

        else if(strcmp(components[i],"..")==0){
  400422:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
  400429:	8b 45 f4             	mov    -0xc(%rbp),%eax
  40042c:	48 98                	cltq   
  40042e:	48 c1 e0 02          	shl    $0x2,%rax
  400432:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  400439:	00 
  40043a:	48 01 c8             	add    %rcx,%rax
  40043d:	48 01 d0             	add    %rdx,%rax
  400440:	48 8d 35 5d 2f 00 00 	lea    0x2f5d(%rip),%rsi        # 4033a4 <chdir+0x4c>
  400447:	48 89 c7             	mov    %rax,%rdi
  40044a:	e8 05 26 00 00       	callq  402a54 <strcmp>
  40044f:	85 c0                	test   %eax,%eax
  400451:	75 4b                	jne    40049e <changedir+0x35e>

            if(i == numOfComponents){
  400453:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400456:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  400459:	75 05                	jne    400460 <changedir+0x320>
                break;
  40045b:	e9 0c 01 00 00       	jmpq   40056c <changedir+0x42c>
            }

            chdir("..");
  400460:	48 8d 3d 3d 2f 00 00 	lea    0x2f3d(%rip),%rdi        # 4033a4 <chdir+0x4c>
  400467:	e8 ec 2e 00 00       	callq  403358 <chdir>
            getcwd(buff,100);
  40046c:	48 8d 85 a4 fe ff ff 	lea    -0x15c(%rbp),%rax
  400473:	be 64 00 00 00       	mov    $0x64,%esi
  400478:	48 89 c7             	mov    %rax,%rdi
  40047b:	e8 43 1a 00 00       	callq  401ec3 <getcwd>
            strcpy(toSend,buff);
  400480:	48 8d 95 a4 fe ff ff 	lea    -0x15c(%rbp),%rdx
  400487:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  40048e:	48 89 d6             	mov    %rdx,%rsi
  400491:	48 89 c7             	mov    %rax,%rdi
  400494:	e8 5c 25 00 00       	callq  4029f5 <strcpy>
  400499:	e9 b3 00 00 00       	jmpq   400551 <changedir+0x411>
        }


        else{

            if(i == numOfComponents){
  40049e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  4004a1:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  4004a4:	75 05                	jne    4004ab <changedir+0x36b>
                break;
  4004a6:	e9 c1 00 00 00       	jmpq   40056c <changedir+0x42c>
            }


            if(toSend[strlen(toSend)-1] != '/'){
  4004ab:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  4004b2:	48 89 c7             	mov    %rax,%rdi
  4004b5:	e8 06 25 00 00       	callq  4029c0 <strlen>
  4004ba:	ff c8                	dec    %eax
  4004bc:	48 98                	cltq   
  4004be:	0f b6 84 05 dc fd ff 	movzbl -0x224(%rbp,%rax,1),%eax
  4004c5:	ff 
  4004c6:	3c 2f                	cmp    $0x2f,%al
  4004c8:	74 16                	je     4004e0 <changedir+0x3a0>
                
                strcat(toSend,"/");
  4004ca:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  4004d1:	48 8d 35 b8 2e 00 00 	lea    0x2eb8(%rip),%rsi        # 403390 <chdir+0x38>
  4004d8:	48 89 c7             	mov    %rax,%rdi
  4004db:	e8 d9 26 00 00       	callq  402bb9 <strcat>
            }
            
            strcat(toSend,components[i]);
  4004e0:	48 8d 95 08 ff ff ff 	lea    -0xf8(%rbp),%rdx
  4004e7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  4004ea:	48 98                	cltq   
  4004ec:	48 c1 e0 02          	shl    $0x2,%rax
  4004f0:	48 8d 0c 85 00 00 00 	lea    0x0(,%rax,4),%rcx
  4004f7:	00 
  4004f8:	48 01 c8             	add    %rcx,%rax
  4004fb:	48 01 c2             	add    %rax,%rdx
  4004fe:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  400505:	48 89 d6             	mov    %rdx,%rsi
  400508:	48 89 c7             	mov    %rax,%rdi
  40050b:	e8 a9 26 00 00       	callq  402bb9 <strcat>

            if(chdir(toSend) == -1){
  400510:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  400517:	48 89 c7             	mov    %rax,%rdi
  40051a:	e8 39 2e 00 00       	callq  403358 <chdir>
  40051f:	83 f8 ff             	cmp    $0xffffffff,%eax
  400522:	75 2d                	jne    400551 <changedir+0x411>
            //Invalid path
            //restore to the cwd
           int ret= chdir(originalWorkingDirectory);
  400524:	48 8d 85 40 fe ff ff 	lea    -0x1c0(%rbp),%rax
  40052b:	48 89 c7             	mov    %rax,%rdi
  40052e:	e8 25 2e 00 00       	callq  403358 <chdir>
  400533:	89 45 e4             	mov    %eax,-0x1c(%rbp)
           if(ret<0)
  400536:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  40053a:	79 13                	jns    40054f <changedir+0x40f>
               printf("Could Not Change Directory");
  40053c:	48 8d 3d 64 2e 00 00 	lea    0x2e64(%rip),%rdi        # 4033a7 <chdir+0x4f>
  400543:	b8 00 00 00 00       	mov    $0x0,%eax
  400548:	e8 9d 1d 00 00       	callq  4022ea <printf>
            break;
  40054d:	eb 1d                	jmp    40056c <changedir+0x42c>
  40054f:	eb 1b                	jmp    40056c <changedir+0x42c>
            }
        }

        i = i + 1;
  400551:	ff 45 f4             	incl   -0xc(%rbp)

        if(i == numOfComponents){
  400554:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400557:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  40055a:	75 02                	jne    40055e <changedir+0x41e>
            break;
  40055c:	eb 0e                	jmp    40056c <changedir+0x42c>

   
    i=0;

    
    while(i < numOfComponents){
  40055e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  400561:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  400564:	0f 8c 10 fe ff ff    	jl     40037a <changedir+0x23a>
  40056a:	eb 00                	jmp    40056c <changedir+0x42c>
        }

    }
	

}
  40056c:	c9                   	leaveq 
  40056d:	c3                   	retq   

000000000040056e <setPath>:
#include <errno.h>
#include <string.h>
#include <shell.h>


char * setPath(char* env,char* path,int mode){
  40056e:	55                   	push   %rbp
  40056f:	48 89 e5             	mov    %rsp,%rbp
  400572:	53                   	push   %rbx
  400573:	48 83 ec 38          	sub    $0x38,%rsp
  400577:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  40057b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  40057f:	89 55 cc             	mov    %edx,-0x34(%rbp)

	int newEnvVarLength;
	//char p[500];
	char *new;

	if(mode == EASIS){
  400582:	83 7d cc 01          	cmpl   $0x1,-0x34(%rbp)
  400586:	75 6f                	jne    4005f7 <setPath+0x89>

		//Calculate new space for the path
		newEnvVarLength = strlen("PATH=") + strlen(path)+1;
  400588:	48 8d 3d 33 2e 00 00 	lea    0x2e33(%rip),%rdi        # 4033c2 <chdir+0x6a>
  40058f:	e8 2c 24 00 00       	callq  4029c0 <strlen>
  400594:	89 c3                	mov    %eax,%ebx
  400596:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40059a:	48 89 c7             	mov    %rax,%rdi
  40059d:	e8 1e 24 00 00       	callq  4029c0 <strlen>
  4005a2:	01 d8                	add    %ebx,%eax
  4005a4:	ff c0                	inc    %eax
  4005a6:	89 45 e4             	mov    %eax,-0x1c(%rbp)

		//printf("In setPath.... passed path is :%s:\n newEnvVarLength :%d\n",path,newEnvVarLength);


		//Allocate that space fr the new path
		new = (char*)malloc(sizeof(char)*newEnvVarLength);
  4005a9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  4005ac:	48 98                	cltq   
  4005ae:	48 89 c7             	mov    %rax,%rdi
  4005b1:	e8 a2 2b 00 00       	callq  403158 <malloc>
  4005b6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		strcpy(new,"PATH=");//copy the old env variable
  4005ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4005be:	48 8d 35 fd 2d 00 00 	lea    0x2dfd(%rip),%rsi        # 4033c2 <chdir+0x6a>
  4005c5:	48 89 c7             	mov    %rax,%rdi
  4005c8:	e8 28 24 00 00       	callq  4029f5 <strcpy>
		strcpy(new+strlen("PATH="),path);
  4005cd:	48 8d 3d ee 2d 00 00 	lea    0x2dee(%rip),%rdi        # 4033c2 <chdir+0x6a>
  4005d4:	e8 e7 23 00 00       	callq  4029c0 <strlen>
  4005d9:	48 63 d0             	movslq %eax,%rdx
  4005dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4005e0:	48 01 c2             	add    %rax,%rdx
  4005e3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4005e7:	48 89 c6             	mov    %rax,%rsi
  4005ea:	48 89 d7             	mov    %rdx,%rdi
  4005ed:	e8 03 24 00 00       	callq  4029f5 <strcpy>
  4005f2:	e9 92 00 00 00       	jmpq   400689 <setPath+0x11b>
	}
	else{


		//Calculate new space for the path
		newEnvVarLength = strlen(env) + strlen(path)+1;
  4005f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4005fb:	48 89 c7             	mov    %rax,%rdi
  4005fe:	e8 bd 23 00 00       	callq  4029c0 <strlen>
  400603:	89 c3                	mov    %eax,%ebx
  400605:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  400609:	48 89 c7             	mov    %rax,%rdi
  40060c:	e8 af 23 00 00       	callq  4029c0 <strlen>
  400611:	01 d8                	add    %ebx,%eax
  400613:	ff c0                	inc    %eax
  400615:	89 45 e4             	mov    %eax,-0x1c(%rbp)

		//Allocate that space fr the new path
		new = (char*)malloc(sizeof(char)*newEnvVarLength);
  400618:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  40061b:	48 98                	cltq   
  40061d:	48 89 c7             	mov    %rax,%rdi
  400620:	e8 33 2b 00 00       	callq  403158 <malloc>
  400625:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		strcpy(new,env);//copy the old env variable
  400629:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  40062d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400631:	48 89 d6             	mov    %rdx,%rsi
  400634:	48 89 c7             	mov    %rax,%rdi
  400637:	e8 b9 23 00 00       	callq  4029f5 <strcpy>
		strcpy(new+strlen(env),":");
  40063c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400640:	48 89 c7             	mov    %rax,%rdi
  400643:	e8 78 23 00 00       	callq  4029c0 <strlen>
  400648:	48 63 d0             	movslq %eax,%rdx
  40064b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40064f:	48 01 d0             	add    %rdx,%rax
  400652:	48 8d 35 6f 2d 00 00 	lea    0x2d6f(%rip),%rsi        # 4033c8 <chdir+0x70>
  400659:	48 89 c7             	mov    %rax,%rdi
  40065c:	e8 94 23 00 00       	callq  4029f5 <strcpy>
		strcpy(new+strlen(env)+1,path);
  400661:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400665:	48 89 c7             	mov    %rax,%rdi
  400668:	e8 53 23 00 00       	callq  4029c0 <strlen>
  40066d:	48 98                	cltq   
  40066f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  400673:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400677:	48 01 c2             	add    %rax,%rdx
  40067a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40067e:	48 89 c6             	mov    %rax,%rsi
  400681:	48 89 d7             	mov    %rdx,%rdi
  400684:	e8 6c 23 00 00       	callq  4029f5 <strcpy>
	}


	//printf("Returning new path from setPath %s\n",new);

	return new;
  400689:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  40068d:	48 83 c4 38          	add    $0x38,%rsp
  400691:	5b                   	pop    %rbx
  400692:	5d                   	pop    %rbp
  400693:	c3                   	retq   

0000000000400694 <set>:



void set(char * args, char** envp){
  400694:	55                   	push   %rbp
  400695:	48 89 e5             	mov    %rsp,%rbp
  400698:	48 81 ec 30 04 00 00 	sub    $0x430,%rsp
  40069f:	48 89 bd d8 fb ff ff 	mov    %rdi,-0x428(%rbp)
  4006a6:	48 89 b5 d0 fb ff ff 	mov    %rsi,-0x430(%rbp)

	char *path=NULL;
  4006ad:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  4006b4:	00 
	//include logic to check for entire string ${PATH} or $PATH


	//printf("In set path\n\n");

	tokenEquals = tokenize(args,"=");
  4006b5:	48 8b 85 d8 fb ff ff 	mov    -0x428(%rbp),%rax
  4006bc:	48 8d 35 07 2d 00 00 	lea    0x2d07(%rip),%rsi        # 4033ca <chdir+0x72>
  4006c3:	48 89 c7             	mov    %rax,%rdi
  4006c6:	e8 0f 14 00 00       	callq  401ada <tokenize>
  4006cb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	 * Get the location in the envp array where PATH
	 * is stored. We will keep the modified PATH string in this location only.
	 */


	envLoc=findEnvVar("PATH",envp);
  4006cf:	48 8b 85 d0 fb ff ff 	mov    -0x430(%rbp),%rax
  4006d6:	48 89 c6             	mov    %rax,%rsi
  4006d9:	48 8d 3d ec 2c 00 00 	lea    0x2cec(%rip),%rdi        # 4033cc <chdir+0x74>
  4006e0:	e8 b7 09 00 00       	callq  40109c <findEnvVar>
  4006e5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	if(tokenEquals->numOfTokens==1){
  4006e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4006ed:	8b 00                	mov    (%rax),%eax
  4006ef:	83 f8 01             	cmp    $0x1,%eax
  4006f2:	75 3d                	jne    400731 <set+0x9d>

		//printf("PATH= case.......\n\n");
		strcpy(tokentoPass,"");
  4006f4:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  4006fb:	48 8d 35 cf 2c 00 00 	lea    0x2ccf(%rip),%rsi        # 4033d1 <chdir+0x79>
  400702:	48 89 c7             	mov    %rax,%rdi
  400705:	e8 eb 22 00 00       	callq  4029f5 <strcpy>
		path = setPath(*envLoc,tokentoPass,EASIS);
  40070a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40070e:	48 8b 00             	mov    (%rax),%rax
  400711:	48 8d 8d dc fd ff ff 	lea    -0x224(%rbp),%rcx
  400718:	ba 01 00 00 00       	mov    $0x1,%edx
  40071d:	48 89 ce             	mov    %rcx,%rsi
  400720:	48 89 c7             	mov    %rax,%rdi
  400723:	e8 46 fe ff ff       	callq  40056e <setPath>
  400728:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  40072c:	e9 ab 01 00 00       	jmpq   4008dc <set+0x248>
		return;

	}


	strcpy(tokentoPass,tokenEquals->tokenArr[1]);
  400731:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400735:	48 8b 50 10          	mov    0x10(%rax),%rdx
  400739:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  400740:	48 89 d6             	mov    %rdx,%rsi
  400743:	48 89 c7             	mov    %rax,%rdi
  400746:	e8 aa 22 00 00       	callq  4029f5 <strcpy>
	//printf("Token to pass after tokenizing on colon is .%s.\n",tokentoPass);
	tokenColon = tokenize(tokentoPass,":");
  40074b:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  400752:	48 8d 35 6f 2c 00 00 	lea    0x2c6f(%rip),%rsi        # 4033c8 <chdir+0x70>
  400759:	48 89 c7             	mov    %rax,%rdi
  40075c:	e8 79 13 00 00       	callq  401ada <tokenize>
  400761:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	/*
	 * Save the value of PATH in oldSysPath.We will need this
	 * when we need to expand ${PATH}
	 */
	char oldSysPath[500];
	token = tokenize(*envLoc,"=");
  400765:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400769:	48 8b 00             	mov    (%rax),%rax
  40076c:	48 8d 35 57 2c 00 00 	lea    0x2c57(%rip),%rsi        # 4033ca <chdir+0x72>
  400773:	48 89 c7             	mov    %rax,%rdi
  400776:	e8 5f 13 00 00       	callq  401ada <tokenize>
  40077b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	strcpy(oldSysPath,token->tokenArr[1]);
  40077f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  400783:	48 8b 50 10          	mov    0x10(%rax),%rdx
  400787:	48 8d 85 e8 fb ff ff 	lea    -0x418(%rbp),%rax
  40078e:	48 89 d6             	mov    %rdx,%rsi
  400791:	48 89 c7             	mov    %rax,%rdi
  400794:	e8 5c 22 00 00       	callq  4029f5 <strcpy>

	/*
	 * First element of the tokenColon always needs to be addes ASIS
	 * Check if the component to add is ${PATH}.If yes send oldSysPath
	 */
	if((strcmp(tokenColon->tokenArr[0],"${PATH}")==0)||(strcmp(tokenColon->tokenArr[0],"$PATH")==0)){
  400799:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40079d:	48 8b 40 08          	mov    0x8(%rax),%rax
  4007a1:	48 8d 35 2a 2c 00 00 	lea    0x2c2a(%rip),%rsi        # 4033d2 <chdir+0x7a>
  4007a8:	48 89 c7             	mov    %rax,%rdi
  4007ab:	e8 a4 22 00 00       	callq  402a54 <strcmp>
  4007b0:	85 c0                	test   %eax,%eax
  4007b2:	74 1b                	je     4007cf <set+0x13b>
  4007b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4007b8:	48 8b 40 08          	mov    0x8(%rax),%rax
  4007bc:	48 8d 35 17 2c 00 00 	lea    0x2c17(%rip),%rsi        # 4033da <chdir+0x82>
  4007c3:	48 89 c7             	mov    %rax,%rdi
  4007c6:	e8 89 22 00 00       	callq  402a54 <strcmp>
  4007cb:	85 c0                	test   %eax,%eax
  4007cd:	75 24                	jne    4007f3 <set+0x15f>
		path = setPath(*envLoc,oldSysPath,EASIS);
  4007cf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4007d3:	48 8b 00             	mov    (%rax),%rax
  4007d6:	48 8d 8d e8 fb ff ff 	lea    -0x418(%rbp),%rcx
  4007dd:	ba 01 00 00 00       	mov    $0x1,%edx
  4007e2:	48 89 ce             	mov    %rcx,%rsi
  4007e5:	48 89 c7             	mov    %rax,%rdi
  4007e8:	e8 81 fd ff ff       	callq  40056e <setPath>
  4007ed:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  4007f1:	eb 23                	jmp    400816 <set+0x182>
		//printf("PATH IS %s\n",path);
	}
	else{
		path = setPath(*envLoc,tokenColon->tokenArr[0],EASIS);
  4007f3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4007f7:	48 8b 48 08          	mov    0x8(%rax),%rcx
  4007fb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4007ff:	48 8b 00             	mov    (%rax),%rax
  400802:	ba 01 00 00 00       	mov    $0x1,%edx
  400807:	48 89 ce             	mov    %rcx,%rsi
  40080a:	48 89 c7             	mov    %rax,%rdi
  40080d:	e8 5c fd ff ff       	callq  40056e <setPath>
  400812:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}

	//Assign the newly modified path to envLoc.This causes the envp array to get updated
	*envLoc = path;
  400816:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40081a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  40081e:	48 89 10             	mov    %rdx,(%rax)

	//printf("The new environment is: %s\n", getenv("PATH"));


	//Append the later elements in a loop
	for(i=1;i<tokenColon->numOfTokens;i++){
  400821:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
  400828:	e9 a0 00 00 00       	jmpq   4008cd <set+0x239>

		/*
		 * Check if the component to add is ${PATH}.If yes send oldSysPath
		 *
		 */
		if((strcmp(tokenColon->tokenArr[i],"${PATH}")==0)||(strcmp(tokenColon->tokenArr[i],"$PATH")==0)){
  40082d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400831:	8b 55 f4             	mov    -0xc(%rbp),%edx
  400834:	48 63 d2             	movslq %edx,%rdx
  400837:	48 8b 44 d0 08       	mov    0x8(%rax,%rdx,8),%rax
  40083c:	48 8d 35 8f 2b 00 00 	lea    0x2b8f(%rip),%rsi        # 4033d2 <chdir+0x7a>
  400843:	48 89 c7             	mov    %rax,%rdi
  400846:	e8 09 22 00 00       	callq  402a54 <strcmp>
  40084b:	85 c0                	test   %eax,%eax
  40084d:	74 22                	je     400871 <set+0x1dd>
  40084f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400853:	8b 55 f4             	mov    -0xc(%rbp),%edx
  400856:	48 63 d2             	movslq %edx,%rdx
  400859:	48 8b 44 d0 08       	mov    0x8(%rax,%rdx,8),%rax
  40085e:	48 8d 35 75 2b 00 00 	lea    0x2b75(%rip),%rsi        # 4033da <chdir+0x82>
  400865:	48 89 c7             	mov    %rax,%rdi
  400868:	e8 e7 21 00 00       	callq  402a54 <strcmp>
  40086d:	85 c0                	test   %eax,%eax
  40086f:	75 24                	jne    400895 <set+0x201>
			path = setPath(*envLoc,oldSysPath,EAPPEND);
  400871:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400875:	48 8b 00             	mov    (%rax),%rax
  400878:	48 8d 8d e8 fb ff ff 	lea    -0x418(%rbp),%rcx
  40087f:	ba 02 00 00 00       	mov    $0x2,%edx
  400884:	48 89 ce             	mov    %rcx,%rsi
  400887:	48 89 c7             	mov    %rax,%rdi
  40088a:	e8 df fc ff ff       	callq  40056e <setPath>
  40088f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  400893:	eb 2a                	jmp    4008bf <set+0x22b>
			//printf("PATH IS %s\n",path);
		}
		else{
			path = setPath(*envLoc,tokenColon->tokenArr[i],EAPPEND);
  400895:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400899:	8b 55 f4             	mov    -0xc(%rbp),%edx
  40089c:	48 63 d2             	movslq %edx,%rdx
  40089f:	48 8b 4c d0 08       	mov    0x8(%rax,%rdx,8),%rcx
  4008a4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4008a8:	48 8b 00             	mov    (%rax),%rax
  4008ab:	ba 02 00 00 00       	mov    $0x2,%edx
  4008b0:	48 89 ce             	mov    %rcx,%rsi
  4008b3:	48 89 c7             	mov    %rax,%rdi
  4008b6:	e8 b3 fc ff ff       	callq  40056e <setPath>
  4008bb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		}

		//Assign the newly modified path to envLoc.This causes the envp array to get updated
		*envLoc = path;
  4008bf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4008c3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  4008c7:	48 89 10             	mov    %rdx,(%rax)

	//printf("The new environment is: %s\n", getenv("PATH"));


	//Append the later elements in a loop
	for(i=1;i<tokenColon->numOfTokens;i++){
  4008ca:	ff 45 f4             	incl   -0xc(%rbp)
  4008cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4008d1:	8b 00                	mov    (%rax),%eax
  4008d3:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  4008d6:	0f 8f 51 ff ff ff    	jg     40082d <set+0x199>


	}//End of for loop

	//printf("The new environment is: %s\n", getenv("PATH"));
}
  4008dc:	c9                   	leaveq 
  4008dd:	c3                   	retq   

00000000004008de <executeBuiltins>:
#include <parser.h>
#include <errno.h>
#include <string.h>
#include <shell.h>

void executeBuiltins(parseInfo* command,char*envp[]){
  4008de:	55                   	push   %rbp
  4008df:	48 89 e5             	mov    %rsp,%rbp
  4008e2:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  4008e6:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
  4008ea:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
		printf("Token %d : %s\n",i,command->CommArray[0]->VarList[i]);
	}*/



	if(strcmp(command->CommArray[0]->commandName,"set")==0){
  4008ee:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4008f2:	48 8b 00             	mov    (%rax),%rax
  4008f5:	48 8b 00             	mov    (%rax),%rax
  4008f8:	48 8d 35 e1 2a 00 00 	lea    0x2ae1(%rip),%rsi        # 4033e0 <chdir+0x88>
  4008ff:	48 89 c7             	mov    %rax,%rdi
  400902:	e8 4d 21 00 00       	callq  402a54 <strcmp>
  400907:	85 c0                	test   %eax,%eax
  400909:	0f 85 f5 00 00 00    	jne    400a04 <executeBuiltins+0x126>

		if(strstr(command->CommArray[0]->VarList[1],"PATH")!=NULL){
  40090f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400913:	48 8b 00             	mov    (%rax),%rax
  400916:	48 8b 40 10          	mov    0x10(%rax),%rax
  40091a:	48 8d 35 c3 2a 00 00 	lea    0x2ac3(%rip),%rsi        # 4033e4 <chdir+0x8c>
  400921:	48 89 c7             	mov    %rax,%rdi
  400924:	e8 b2 21 00 00       	callq  402adb <strstr>
  400929:	48 85 c0             	test   %rax,%rax
  40092c:	74 76                	je     4009a4 <executeBuiltins+0xc6>
			//execute change PATH
			//printf("Going to change path");


			if(command->CommArray[0]->VarNum >2){
  40092e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400932:	48 8b 00             	mov    (%rax),%rax
  400935:	8b 40 58             	mov    0x58(%rax),%eax
  400938:	83 f8 02             	cmp    $0x2,%eax
  40093b:	7e 16                	jle    400953 <executeBuiltins+0x75>

				printf("Too many arguments to set PATH.Please enter set PATH=ABC:XYX:... (no spaces in between)\n");
  40093d:	48 8d 3d ac 2a 00 00 	lea    0x2aac(%rip),%rdi        # 4033f0 <chdir+0x98>
  400944:	b8 00 00 00 00       	mov    $0x0,%eax
  400949:	e8 9c 19 00 00       	callq  4022ea <printf>
				return;
  40094e:	e9 56 01 00 00       	jmpq   400aa9 <executeBuiltins+0x1cb>
			}


			set(command->CommArray[0]->VarList[1],envp);
  400953:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400957:	48 8b 00             	mov    (%rax),%rax
  40095a:	48 8b 40 10          	mov    0x10(%rax),%rax
  40095e:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  400962:	48 89 d6             	mov    %rdx,%rsi
  400965:	48 89 c7             	mov    %rax,%rdi
  400968:	e8 27 fd ff ff       	callq  400694 <set>
			envVar=findEnvVar("PATH",envp);
  40096d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  400971:	48 89 c6             	mov    %rax,%rsi
  400974:	48 8d 3d 69 2a 00 00 	lea    0x2a69(%rip),%rdi        # 4033e4 <chdir+0x8c>
  40097b:	e8 1c 07 00 00       	callq  40109c <findEnvVar>
  400980:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			printf("Current Path is :\n %s\n",*envVar);
  400984:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  400988:	48 8b 00             	mov    (%rax),%rax
  40098b:	48 89 c6             	mov    %rax,%rsi
  40098e:	48 8d 3d b4 2a 00 00 	lea    0x2ab4(%rip),%rdi        # 403449 <chdir+0xf1>
  400995:	b8 00 00 00 00       	mov    $0x0,%eax
  40099a:	e8 4b 19 00 00       	callq  4022ea <printf>
  40099f:	e9 04 01 00 00       	jmpq   400aa8 <executeBuiltins+0x1ca>


		}
		else if(strstr(command->CommArray[0]->VarList[1],"PS1")!=NULL){
  4009a4:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4009a8:	48 8b 00             	mov    (%rax),%rax
  4009ab:	48 8b 40 10          	mov    0x10(%rax),%rax
  4009af:	48 8d 35 aa 2a 00 00 	lea    0x2aaa(%rip),%rsi        # 403460 <chdir+0x108>
  4009b6:	48 89 c7             	mov    %rax,%rdi
  4009b9:	e8 1d 21 00 00       	callq  402adb <strstr>
  4009be:	48 85 c0             	test   %rax,%rax
  4009c1:	0f 84 e1 00 00 00    	je     400aa8 <executeBuiltins+0x1ca>
			//simple change the shell variable PS1
			//Add function to remove spaces from PS1=hgchbvh

			//printf("Going to change PS1");

			if(command->CommArray[0]->VarNum >2){
  4009c7:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4009cb:	48 8b 00             	mov    (%rax),%rax
  4009ce:	8b 40 58             	mov    0x58(%rax),%eax
  4009d1:	83 f8 02             	cmp    $0x2,%eax
  4009d4:	7e 16                	jle    4009ec <executeBuiltins+0x10e>

				printf("Too many arguments to set PS1.Please enter set PS1=ABCD (no spaces in between)\n");
  4009d6:	48 8d 3d 8b 2a 00 00 	lea    0x2a8b(%rip),%rdi        # 403468 <chdir+0x110>
  4009dd:	b8 00 00 00 00       	mov    $0x0,%eax
  4009e2:	e8 03 19 00 00       	callq  4022ea <printf>
				return;
  4009e7:	e9 bd 00 00 00       	jmpq   400aa9 <executeBuiltins+0x1cb>
			}

			changePS1(command->CommArray[0]->VarList[1]);
  4009ec:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  4009f0:	48 8b 00             	mov    (%rax),%rax
  4009f3:	48 8b 40 10          	mov    0x10(%rax),%rax
  4009f7:	48 89 c7             	mov    %rax,%rdi
  4009fa:	e8 1b 0b 00 00       	callq  40151a <changePS1>
		printf("Current Working Directory is: %s\n",cmdWithoutSpaces);

	}


	return;
  4009ff:	e9 a5 00 00 00       	jmpq   400aa9 <executeBuiltins+0x1cb>

		}
	}


	else if(strcmp(command->CommArray[0]->commandName,"exit")==0){
  400a04:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400a08:	48 8b 00             	mov    (%rax),%rax
  400a0b:	48 8b 00             	mov    (%rax),%rax
  400a0e:	48 8d 35 a3 2a 00 00 	lea    0x2aa3(%rip),%rsi        # 4034b8 <chdir+0x160>
  400a15:	48 89 c7             	mov    %rax,%rdi
  400a18:	e8 37 20 00 00       	callq  402a54 <strcmp>
  400a1d:	85 c0                	test   %eax,%eax
  400a1f:	75 0c                	jne    400a2d <executeBuiltins+0x14f>

		exit(0);
  400a21:	bf 00 00 00 00       	mov    $0x0,%edi
  400a26:	e8 79 1f 00 00       	callq  4029a4 <exit>
  400a2b:	eb 7b                	jmp    400aa8 <executeBuiltins+0x1ca>
	}

	else if(strcmp(command->CommArray[0]->commandName,"cd")==0) {
  400a2d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400a31:	48 8b 00             	mov    (%rax),%rax
  400a34:	48 8b 00             	mov    (%rax),%rax
  400a37:	48 8d 35 7f 2a 00 00 	lea    0x2a7f(%rip),%rsi        # 4034bd <chdir+0x165>
  400a3e:	48 89 c7             	mov    %rax,%rdi
  400a41:	e8 0e 20 00 00       	callq  402a54 <strcmp>
  400a46:	85 c0                	test   %eax,%eax
  400a48:	75 5e                	jne    400aa8 <executeBuiltins+0x1ca>
		if(command->CommArray[0]->VarNum >2){
  400a4a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400a4e:	48 8b 00             	mov    (%rax),%rax
  400a51:	8b 40 58             	mov    0x58(%rax),%eax
  400a54:	83 f8 02             	cmp    $0x2,%eax
  400a57:	7e 13                	jle    400a6c <executeBuiltins+0x18e>

			printf("Too many arguments to cd.Please enter cd <directory name>\n");
  400a59:	48 8d 3d 60 2a 00 00 	lea    0x2a60(%rip),%rdi        # 4034c0 <chdir+0x168>
  400a60:	b8 00 00 00 00       	mov    $0x0,%eax
  400a65:	e8 80 18 00 00       	callq  4022ea <printf>
			return;
  400a6a:	eb 3d                	jmp    400aa9 <executeBuiltins+0x1cb>
		}


		//execute change directory
		changedir(command->CommArray[0]->VarList[1]);
  400a6c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  400a70:	48 8b 00             	mov    (%rax),%rax
  400a73:	48 8b 40 10          	mov    0x10(%rax),%rax
  400a77:	48 89 c7             	mov    %rax,%rdi
  400a7a:	e8 c1 f6 ff ff       	callq  400140 <changedir>
		getcwd(cmdWithoutSpaces,100);
  400a7f:	48 8d 45 94          	lea    -0x6c(%rbp),%rax
  400a83:	be 64 00 00 00       	mov    $0x64,%esi
  400a88:	48 89 c7             	mov    %rax,%rdi
  400a8b:	e8 33 14 00 00       	callq  401ec3 <getcwd>
		printf("Current Working Directory is: %s\n",cmdWithoutSpaces);
  400a90:	48 8d 45 94          	lea    -0x6c(%rbp),%rax
  400a94:	48 89 c6             	mov    %rax,%rsi
  400a97:	48 8d 3d 62 2a 00 00 	lea    0x2a62(%rip),%rdi        # 403500 <chdir+0x1a8>
  400a9e:	b8 00 00 00 00       	mov    $0x0,%eax
  400aa3:	e8 42 18 00 00       	callq  4022ea <printf>

	}


	return;
  400aa8:	90                   	nop


}
  400aa9:	c9                   	leaveq 
  400aaa:	c3                   	retq   

0000000000400aab <execute_cmd>:
#include <shell.h>



void execute_cmd(parseInfo * info,char*envp[])
{
  400aab:	55                   	push   %rbp
  400aac:	48 89 e5             	mov    %rsp,%rbp
  400aaf:	53                   	push   %rbx
  400ab0:	48 81 ec 28 08 00 00 	sub    $0x828,%rsp
  400ab7:	48 89 bd d8 f7 ff ff 	mov    %rdi,-0x828(%rbp)
  400abe:	48 89 b5 d0 f7 ff ff 	mov    %rsi,-0x830(%rbp)
	int i,j,*pipes=NULL,status;
  400ac5:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  400acc:	00 
	char cmd[20][100];

	int  *proc_ids;
	//printf("pipes=%d \n",info->pipeNum);

	for(i=0; i<=info->pipeNum; i++)
  400acd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  400ad4:	eb 36                	jmp    400b0c <execute_cmd+0x61>
	{
		//printf("info: %s\n", info->CommArray[i]->commandName);
		strcpy(cmd[i],info->CommArray[i]->commandName);
  400ad6:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400add:	8b 55 ec             	mov    -0x14(%rbp),%edx
  400ae0:	48 63 d2             	movslq %edx,%rdx
  400ae3:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  400ae7:	48 8b 00             	mov    (%rax),%rax
  400aea:	48 8d 8d fc f7 ff ff 	lea    -0x804(%rbp),%rcx
  400af1:	8b 55 ec             	mov    -0x14(%rbp),%edx
  400af4:	48 63 d2             	movslq %edx,%rdx
  400af7:	48 6b d2 64          	imul   $0x64,%rdx,%rdx
  400afb:	48 01 ca             	add    %rcx,%rdx
  400afe:	48 89 c6             	mov    %rax,%rsi
  400b01:	48 89 d7             	mov    %rdx,%rdi
  400b04:	e8 ec 1e 00 00       	callq  4029f5 <strcpy>
	char cmd[20][100];

	int  *proc_ids;
	//printf("pipes=%d \n",info->pipeNum);

	for(i=0; i<=info->pipeNum; i++)
  400b09:	ff 45 ec             	incl   -0x14(%rbp)
  400b0c:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400b13:	8b 40 50             	mov    0x50(%rax),%eax
  400b16:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  400b19:	7d bb                	jge    400ad6 <execute_cmd+0x2b>
		//printf("varList=%s\n",info->CommArray[i]->VarList[j]);
	}



	proc_ids = (int *)malloc(info->pipeNum+1);
  400b1b:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400b22:	8b 40 50             	mov    0x50(%rax),%eax
  400b25:	ff c0                	inc    %eax
  400b27:	48 98                	cltq   
  400b29:	48 89 c7             	mov    %rax,%rdi
  400b2c:	e8 27 26 00 00       	callq  403158 <malloc>
  400b31:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
printf("proc_ids=%p",proc_ids);
  400b35:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400b39:	48 89 c6             	mov    %rax,%rsi
  400b3c:	48 8d 3d df 29 00 00 	lea    0x29df(%rip),%rdi        # 403522 <chdir+0x1ca>
  400b43:	b8 00 00 00 00       	mov    $0x0,%eax
  400b48:	e8 9d 17 00 00       	callq  4022ea <printf>

	if(info->pipeNum==0)
  400b4d:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400b54:	8b 40 50             	mov    0x50(%rax),%eax
  400b57:	85 c0                	test   %eax,%eax
  400b59:	0f 85 ca 00 00 00    	jne    400c29 <execute_cmd+0x17e>
	{
		printf("forking");
  400b5f:	48 8d 3d c8 29 00 00 	lea    0x29c8(%rip),%rdi        # 40352e <chdir+0x1d6>
  400b66:	b8 00 00 00 00       	mov    $0x0,%eax
  400b6b:	e8 7a 17 00 00       	callq  4022ea <printf>


		proc_ids[0]=fork();
  400b70:	e8 c4 1d 00 00       	callq  402939 <fork>
  400b75:	89 c2                	mov    %eax,%edx
  400b77:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400b7b:	89 10                	mov    %edx,(%rax)

		if (proc_ids[0] < 0)
  400b7d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400b81:	8b 00                	mov    (%rax),%eax
  400b83:	85 c0                	test   %eax,%eax
  400b85:	79 1a                	jns    400ba1 <execute_cmd+0xf6>
		{
			strerror( errno);
  400b87:	48 8b 05 da 39 20 00 	mov    0x2039da(%rip),%rax        # 604568 <chdir+0x201210>
  400b8e:	8b 00                	mov    (%rax),%eax
  400b90:	89 c7                	mov    %eax,%edi
  400b92:	e8 5d 20 00 00       	callq  402bf4 <strerror>
			exit(1);
  400b97:	bf 01 00 00 00       	mov    $0x1,%edi
  400b9c:	e8 03 1e 00 00       	callq  4029a4 <exit>
		}
		if(proc_ids[0]==0)
  400ba1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400ba5:	8b 00                	mov    (%rax),%eax
  400ba7:	85 c0                	test   %eax,%eax
  400ba9:	0f 85 08 03 00 00    	jne    400eb7 <execute_cmd+0x40c>
		{
			//printf("executing %s\n",cmd[0]);

			printf("Executing Command %s\n",cmd[0]);
  400baf:	48 8d 85 fc f7 ff ff 	lea    -0x804(%rbp),%rax
  400bb6:	48 89 c6             	mov    %rax,%rsi
  400bb9:	48 8d 3d 76 29 00 00 	lea    0x2976(%rip),%rdi        # 403536 <chdir+0x1de>
  400bc0:	b8 00 00 00 00       	mov    $0x0,%eax
  400bc5:	e8 20 17 00 00       	callq  4022ea <printf>

			char* envpChildProcess[]={NULL};
  400bca:	48 c7 85 f0 f7 ff ff 	movq   $0x0,-0x810(%rbp)
  400bd1:	00 00 00 00 
			int ret = execve(cmd[0],info->CommArray[0]->VarList,envpChildProcess);
  400bd5:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400bdc:	48 8b 00             	mov    (%rax),%rax
  400bdf:	48 8d 48 08          	lea    0x8(%rax),%rcx
  400be3:	48 8d 95 f0 f7 ff ff 	lea    -0x810(%rbp),%rdx
  400bea:	48 8d 85 fc f7 ff ff 	lea    -0x804(%rbp),%rax
  400bf1:	48 89 ce             	mov    %rcx,%rsi
  400bf4:	48 89 c7             	mov    %rax,%rdi
  400bf7:	e8 dc 1c 00 00       	callq  4028d8 <execve>
  400bfc:	89 45 d4             	mov    %eax,-0x2c(%rbp)
			if(ret == -1)
  400bff:	83 7d d4 ff          	cmpl   $0xffffffff,-0x2c(%rbp)
  400c03:	75 1f                	jne    400c24 <execute_cmd+0x179>
			{
				strerror(errno);
  400c05:	48 8b 05 5c 39 20 00 	mov    0x20395c(%rip),%rax        # 604568 <chdir+0x201210>
  400c0c:	8b 00                	mov    (%rax),%eax
  400c0e:	89 c7                	mov    %eax,%edi
  400c10:	e8 df 1f 00 00       	callq  402bf4 <strerror>
				exit(1);
  400c15:	bf 01 00 00 00       	mov    $0x1,%edi
  400c1a:	e8 85 1d 00 00       	callq  4029a4 <exit>
  400c1f:	e9 93 02 00 00       	jmpq   400eb7 <execute_cmd+0x40c>
  400c24:	e9 8e 02 00 00       	jmpq   400eb7 <execute_cmd+0x40c>
		//printf("\ndone\n");
	}
	else
	{

		pipes=(int*)malloc(2*info->pipeNum*sizeof(int));
  400c29:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400c30:	8b 40 50             	mov    0x50(%rax),%eax
  400c33:	48 98                	cltq   
  400c35:	48 c1 e0 03          	shl    $0x3,%rax
  400c39:	48 89 c7             	mov    %rax,%rdi
  400c3c:	e8 17 25 00 00       	callq  403158 <malloc>
  400c41:	48 89 45 e0          	mov    %rax,-0x20(%rbp)


		for(i=0; i<info->pipeNum; i++)
  400c45:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  400c4c:	eb 34                	jmp    400c82 <execute_cmd+0x1d7>
		{
			if(pipe(pipes+i*2) == -1)
  400c4e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400c51:	48 98                	cltq   
  400c53:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  400c5a:	00 
  400c5b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400c5f:	48 01 d0             	add    %rdx,%rax
  400c62:	48 89 c7             	mov    %rax,%rdi
  400c65:	e8 05 1c 00 00       	callq  40286f <pipe>
  400c6a:	83 f8 ff             	cmp    $0xffffffff,%eax
  400c6d:	75 10                	jne    400c7f <execute_cmd+0x1d4>
				strerror(errno);
  400c6f:	48 8b 05 f2 38 20 00 	mov    0x2038f2(%rip),%rax        # 604568 <chdir+0x201210>
  400c76:	8b 00                	mov    (%rax),%eax
  400c78:	89 c7                	mov    %eax,%edi
  400c7a:	e8 75 1f 00 00       	callq  402bf4 <strerror>
	{

		pipes=(int*)malloc(2*info->pipeNum*sizeof(int));


		for(i=0; i<info->pipeNum; i++)
  400c7f:	ff 45 ec             	incl   -0x14(%rbp)
  400c82:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400c89:	8b 40 50             	mov    0x50(%rax),%eax
  400c8c:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  400c8f:	7f bd                	jg     400c4e <execute_cmd+0x1a3>
		{
			if(pipe(pipes+i*2) == -1)
				strerror(errno);
		}
		//printf("Multiple Commands");
		for(i=0; i<=info->pipeNum;i++)
  400c91:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  400c98:	e9 b2 01 00 00       	jmpq   400e4f <execute_cmd+0x3a4>
		{
			proc_ids[i]=fork();
  400c9d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400ca0:	48 98                	cltq   
  400ca2:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400ca9:	00 
  400caa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400cae:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  400cb2:	e8 82 1c 00 00       	callq  402939 <fork>
  400cb7:	89 03                	mov    %eax,(%rbx)
			if (proc_ids[i] < 0)
  400cb9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400cbc:	48 98                	cltq   
  400cbe:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400cc5:	00 
  400cc6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400cca:	48 01 d0             	add    %rdx,%rax
  400ccd:	8b 00                	mov    (%rax),%eax
  400ccf:	85 c0                	test   %eax,%eax
  400cd1:	79 1a                	jns    400ced <execute_cmd+0x242>
			{
				strerror(errno);
  400cd3:	48 8b 05 8e 38 20 00 	mov    0x20388e(%rip),%rax        # 604568 <chdir+0x201210>
  400cda:	8b 00                	mov    (%rax),%eax
  400cdc:	89 c7                	mov    %eax,%edi
  400cde:	e8 11 1f 00 00       	callq  402bf4 <strerror>
				exit(1);
  400ce3:	bf 01 00 00 00       	mov    $0x1,%edi
  400ce8:	e8 b7 1c 00 00       	callq  4029a4 <exit>
			}
			//printf("pid=%d",proc_ids[i]);
			if(proc_ids[i]==0)
  400ced:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400cf0:	48 98                	cltq   
  400cf2:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400cf9:	00 
  400cfa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400cfe:	48 01 d0             	add    %rdx,%rax
  400d01:	8b 00                	mov    (%rax),%eax
  400d03:	85 c0                	test   %eax,%eax
  400d05:	0f 85 41 01 00 00    	jne    400e4c <execute_cmd+0x3a1>
			{
				//printf("in child%d",i);

				if(i!=0)
  400d0b:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  400d0f:	74 37                	je     400d48 <execute_cmd+0x29d>
				{
					if(dup2(pipes[i*2-2],0)==-1)
  400d11:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400d14:	48 98                	cltq   
  400d16:	48 c1 e0 03          	shl    $0x3,%rax
  400d1a:	48 8d 50 f8          	lea    -0x8(%rax),%rdx
  400d1e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400d22:	48 01 d0             	add    %rdx,%rax
  400d25:	8b 00                	mov    (%rax),%eax
  400d27:	be 00 00 00 00       	mov    $0x0,%esi
  400d2c:	89 c7                	mov    %eax,%edi
  400d2e:	e8 bc 10 00 00       	callq  401def <dup2>
  400d33:	83 f8 ff             	cmp    $0xffffffff,%eax
  400d36:	75 10                	jne    400d48 <execute_cmd+0x29d>
						strerror(errno);
  400d38:	48 8b 05 29 38 20 00 	mov    0x203829(%rip),%rax        # 604568 <chdir+0x201210>
  400d3f:	8b 00                	mov    (%rax),%eax
  400d41:	89 c7                	mov    %eax,%edi
  400d43:	e8 ac 1e 00 00       	callq  402bf4 <strerror>
				}
				if(i!=info->pipeNum)
  400d48:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400d4f:	8b 40 50             	mov    0x50(%rax),%eax
  400d52:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  400d55:	74 37                	je     400d8e <execute_cmd+0x2e3>
				{

					if(dup2(pipes[i*2+1],1)==-1)
  400d57:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400d5a:	48 98                	cltq   
  400d5c:	48 c1 e0 03          	shl    $0x3,%rax
  400d60:	48 8d 50 04          	lea    0x4(%rax),%rdx
  400d64:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400d68:	48 01 d0             	add    %rdx,%rax
  400d6b:	8b 00                	mov    (%rax),%eax
  400d6d:	be 01 00 00 00       	mov    $0x1,%esi
  400d72:	89 c7                	mov    %eax,%edi
  400d74:	e8 76 10 00 00       	callq  401def <dup2>
  400d79:	83 f8 ff             	cmp    $0xffffffff,%eax
  400d7c:	75 10                	jne    400d8e <execute_cmd+0x2e3>
						strerror(errno);
  400d7e:	48 8b 05 e3 37 20 00 	mov    0x2037e3(%rip),%rax        # 604568 <chdir+0x201210>
  400d85:	8b 00                	mov    (%rax),%eax
  400d87:	89 c7                	mov    %eax,%edi
  400d89:	e8 66 1e 00 00       	callq  402bf4 <strerror>
				}

				for(j=0;j<info->pipeNum;j++)
  400d8e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
  400d95:	eb 3d                	jmp    400dd4 <execute_cmd+0x329>
				{
					close(pipes[j*2]);
  400d97:	8b 45 e8             	mov    -0x18(%rbp),%eax
  400d9a:	48 98                	cltq   
  400d9c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  400da3:	00 
  400da4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400da8:	48 01 d0             	add    %rdx,%rax
  400dab:	8b 00                	mov    (%rax),%eax
  400dad:	89 c7                	mov    %eax,%edi
  400daf:	e8 8e 11 00 00       	callq  401f42 <close>
					close(pipes[j*2+1]);
  400db4:	8b 45 e8             	mov    -0x18(%rbp),%eax
  400db7:	48 98                	cltq   
  400db9:	48 c1 e0 03          	shl    $0x3,%rax
  400dbd:	48 8d 50 04          	lea    0x4(%rax),%rdx
  400dc1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400dc5:	48 01 d0             	add    %rdx,%rax
  400dc8:	8b 00                	mov    (%rax),%eax
  400dca:	89 c7                	mov    %eax,%edi
  400dcc:	e8 71 11 00 00       	callq  401f42 <close>

					if(dup2(pipes[i*2+1],1)==-1)
						strerror(errno);
				}

				for(j=0;j<info->pipeNum;j++)
  400dd1:	ff 45 e8             	incl   -0x18(%rbp)
  400dd4:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400ddb:	8b 40 50             	mov    0x50(%rax),%eax
  400dde:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  400de1:	7f b4                	jg     400d97 <execute_cmd+0x2ec>
				//printf("debug:%s ", cmd[i]);


				//printf("Executing Command %s\n",cmd[i]);

				char* envpChildProcess[]={NULL};
  400de3:	48 c7 85 e8 f7 ff ff 	movq   $0x0,-0x818(%rbp)
  400dea:	00 00 00 00 
				int ret=execve(cmd[i],info->CommArray[i]->VarList,envpChildProcess);
  400dee:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400df5:	8b 55 ec             	mov    -0x14(%rbp),%edx
  400df8:	48 63 d2             	movslq %edx,%rdx
  400dfb:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  400dff:	48 8d 70 08          	lea    0x8(%rax),%rsi
  400e03:	48 8d 95 fc f7 ff ff 	lea    -0x804(%rbp),%rdx
  400e0a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400e0d:	48 98                	cltq   
  400e0f:	48 6b c0 64          	imul   $0x64,%rax,%rax
  400e13:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  400e17:	48 8d 85 e8 f7 ff ff 	lea    -0x818(%rbp),%rax
  400e1e:	48 89 c2             	mov    %rax,%rdx
  400e21:	48 89 cf             	mov    %rcx,%rdi
  400e24:	e8 af 1a 00 00       	callq  4028d8 <execve>
  400e29:	89 45 d0             	mov    %eax,-0x30(%rbp)
				if(ret == -1)
  400e2c:	83 7d d0 ff          	cmpl   $0xffffffff,-0x30(%rbp)
  400e30:	75 1a                	jne    400e4c <execute_cmd+0x3a1>
				{
					strerror(errno);
  400e32:	48 8b 05 2f 37 20 00 	mov    0x20372f(%rip),%rax        # 604568 <chdir+0x201210>
  400e39:	8b 00                	mov    (%rax),%eax
  400e3b:	89 c7                	mov    %eax,%edi
  400e3d:	e8 b2 1d 00 00       	callq  402bf4 <strerror>
					exit(1);
  400e42:	bf 01 00 00 00       	mov    $0x1,%edi
  400e47:	e8 58 1b 00 00       	callq  4029a4 <exit>
		{
			if(pipe(pipes+i*2) == -1)
				strerror(errno);
		}
		//printf("Multiple Commands");
		for(i=0; i<=info->pipeNum;i++)
  400e4c:	ff 45 ec             	incl   -0x14(%rbp)
  400e4f:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400e56:	8b 40 50             	mov    0x50(%rax),%eax
  400e59:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  400e5c:	0f 8d 3b fe ff ff    	jge    400c9d <execute_cmd+0x1f2>
				}
			}
		}
		//printf("\nin multiple's parent\n");

		for(i=0;i<info->pipeNum;i++)
  400e62:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  400e69:	eb 3d                	jmp    400ea8 <execute_cmd+0x3fd>
		{
			close(pipes[i*2]);
  400e6b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400e6e:	48 98                	cltq   
  400e70:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  400e77:	00 
  400e78:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400e7c:	48 01 d0             	add    %rdx,%rax
  400e7f:	8b 00                	mov    (%rax),%eax
  400e81:	89 c7                	mov    %eax,%edi
  400e83:	e8 ba 10 00 00       	callq  401f42 <close>
			close(pipes[i*2+1]);
  400e88:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400e8b:	48 98                	cltq   
  400e8d:	48 c1 e0 03          	shl    $0x3,%rax
  400e91:	48 8d 50 04          	lea    0x4(%rax),%rdx
  400e95:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  400e99:	48 01 d0             	add    %rdx,%rax
  400e9c:	8b 00                	mov    (%rax),%eax
  400e9e:	89 c7                	mov    %eax,%edi
  400ea0:	e8 9d 10 00 00       	callq  401f42 <close>
				}
			}
		}
		//printf("\nin multiple's parent\n");

		for(i=0;i<info->pipeNum;i++)
  400ea5:	ff 45 ec             	incl   -0x14(%rbp)
  400ea8:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400eaf:	8b 40 50             	mov    0x50(%rax),%eax
  400eb2:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  400eb5:	7f b4                	jg     400e6b <execute_cmd+0x3c0>
			close(pipes[i*2+1]);
			//printf("closed");
		}
	}
	//printf("\nin singles's parent\n");
	for (i = 0; i <= info->pipeNum; i++)
  400eb7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  400ebe:	eb 2c                	jmp    400eec <execute_cmd+0x441>
		waitpid(proc_ids[i], &status, 0);
  400ec0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  400ec3:	48 98                	cltq   
  400ec5:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  400ecc:	00 
  400ecd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400ed1:	48 01 d0             	add    %rdx,%rax
  400ed4:	8b 00                	mov    (%rax),%eax
  400ed6:	48 8d 4d cc          	lea    -0x34(%rbp),%rcx
  400eda:	ba 00 00 00 00       	mov    $0x0,%edx
  400edf:	48 89 ce             	mov    %rcx,%rsi
  400ee2:	89 c7                	mov    %eax,%edi
  400ee4:	e8 2f 11 00 00       	callq  402018 <waitpid>
			close(pipes[i*2+1]);
			//printf("closed");
		}
	}
	//printf("\nin singles's parent\n");
	for (i = 0; i <= info->pipeNum; i++)
  400ee9:	ff 45 ec             	incl   -0x14(%rbp)
  400eec:	48 8b 85 d8 f7 ff ff 	mov    -0x828(%rbp),%rax
  400ef3:	8b 40 50             	mov    0x50(%rax),%eax
  400ef6:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  400ef9:	7d c5                	jge    400ec0 <execute_cmd+0x415>
		waitpid(proc_ids[i], &status, 0);
	//printf("child returned:%d\n",waitpid(proc_ids[i], &status, 0));

}
  400efb:	48 81 c4 28 08 00 00 	add    $0x828,%rsp
  400f02:	5b                   	pop    %rbx
  400f03:	5d                   	pop    %rbp
  400f04:	c3                   	retq   

0000000000400f05 <find_file_in_dir>:




char* find_file_in_dir (char *path, char *file)
{
  400f05:	55                   	push   %rbp
  400f06:	48 89 e5             	mov    %rsp,%rbp
  400f09:	48 83 ec 30          	sub    $0x30,%rsp
  400f0d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  400f11:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	struct dirent *entry=NULL;
  400f15:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  400f1c:	00 
	char* ret = NULL;
  400f1d:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  400f24:	00 
	//ret=NULL;
	void *dir;
	dir = opendir (path);
  400f25:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  400f29:	48 89 c7             	mov    %rax,%rdi
  400f2c:	e8 17 18 00 00       	callq  402748 <opendir>
  400f31:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if(dir == NULL)
  400f35:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  400f3a:	75 0a                	jne    400f46 <find_file_in_dir+0x41>
		return (char *)NULL;
  400f3c:	b8 00 00 00 00       	mov    $0x0,%eax
  400f41:	e9 ae 00 00 00       	jmpq   400ff4 <find_file_in_dir+0xef>

	errno = 0;
  400f46:	48 8b 05 1b 36 20 00 	mov    0x20361b(%rip),%rax        # 604568 <chdir+0x201210>
  400f4d:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	//printf("In find_file_in_dir....searching %s\n",path);
	while ((entry = readdir (dir)) != NULL) {
  400f53:	eb 3e                	jmp    400f93 <find_file_in_dir+0x8e>
		//printf("entry->dname=%s file=%s",entry->d_name, file);
		if (!strcmp(entry->d_name, file)) {
  400f55:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  400f59:	48 8d 50 12          	lea    0x12(%rax),%rdx
  400f5d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  400f61:	48 89 c6             	mov    %rax,%rsi
  400f64:	48 89 d7             	mov    %rdx,%rdi
  400f67:	e8 e8 1a 00 00       	callq  402a54 <strcmp>
  400f6c:	85 c0                	test   %eax,%eax
  400f6e:	75 23                	jne    400f93 <find_file_in_dir+0x8e>
			ret=malloc(sizeof(strlen(path)+1));
  400f70:	bf 04 00 00 00       	mov    $0x4,%edi
  400f75:	e8 de 21 00 00       	callq  403158 <malloc>
  400f7a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			strcpy(ret,path);
  400f7e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  400f82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  400f86:	48 89 d6             	mov    %rdx,%rsi
  400f89:	48 89 c7             	mov    %rax,%rdi
  400f8c:	e8 64 1a 00 00       	callq  4029f5 <strcpy>
			break;
  400f91:	eb 17                	jmp    400faa <find_file_in_dir+0xa5>
	if(dir == NULL)
		return (char *)NULL;

	errno = 0;
	//printf("In find_file_in_dir....searching %s\n",path);
	while ((entry = readdir (dir)) != NULL) {
  400f93:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400f97:	48 89 c7             	mov    %rax,%rdi
  400f9a:	e8 7e 0d 00 00       	callq  401d1d <readdir>
  400f9f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  400fa3:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  400fa8:	75 ab                	jne    400f55 <find_file_in_dir+0x50>
			ret=malloc(sizeof(strlen(path)+1));
			strcpy(ret,path);
			break;
		}
	}
	if (errno && !entry){
  400faa:	48 8b 05 b7 35 20 00 	mov    0x2035b7(%rip),%rax        # 604568 <chdir+0x201210>
  400fb1:	8b 00                	mov    (%rax),%eax
  400fb3:	85 c0                	test   %eax,%eax
  400fb5:	74 17                	je     400fce <find_file_in_dir+0xc9>
  400fb7:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  400fbc:	75 10                	jne    400fce <find_file_in_dir+0xc9>
		strerror(errno);
  400fbe:	48 8b 05 a3 35 20 00 	mov    0x2035a3(%rip),%rax        # 604568 <chdir+0x201210>
  400fc5:	8b 00                	mov    (%rax),%eax
  400fc7:	89 c7                	mov    %eax,%edi
  400fc9:	e8 26 1c 00 00       	callq  402bf4 <strerror>
	}

	if(closedir (dir) == -1){
  400fce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  400fd2:	48 89 c7             	mov    %rax,%rdi
  400fd5:	e8 b6 10 00 00       	callq  402090 <closedir>
  400fda:	83 f8 ff             	cmp    $0xffffffff,%eax
  400fdd:	75 11                	jne    400ff0 <find_file_in_dir+0xeb>

		printf("Fatal error. Could not close a directory\n");
  400fdf:	48 8d 3d 6a 25 00 00 	lea    0x256a(%rip),%rdi        # 403550 <chdir+0x1f8>
  400fe6:	b8 00 00 00 00       	mov    $0x0,%eax
  400feb:	e8 fa 12 00 00       	callq  4022ea <printf>

	}


	//printf("In find_file_in_dir....returning %s\n",ret);
	return ret;
  400ff0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  400ff4:	c9                   	leaveq 
  400ff5:	c3                   	retq   

0000000000400ff6 <findBinaryFullPath>:


char* findBinaryFullPath(char* srchPath,char* binaryName){
  400ff6:	55                   	push   %rbp
  400ff7:	48 89 e5             	mov    %rsp,%rbp
  400ffa:	48 83 ec 60          	sub    $0x60,%rsp
  400ffe:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  401002:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	 * Else if none of the above are there then find the full path
	 *
	 */

	int i;
	char* x=NULL;
  401006:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  40100d:	00 
	//printf("In find full binary path\n");


	//printf("After strstr call. Search Path is :%s \n",srchPath);

	Token* dirToSearch = tokenize(srchPath,":");
  40100e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  401012:	48 8d 35 61 25 00 00 	lea    0x2561(%rip),%rsi        # 40357a <chdir+0x222>
  401019:	48 89 c7             	mov    %rax,%rdi
  40101c:	e8 b9 0a 00 00       	callq  401ada <tokenize>
  401021:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	//printf("After tokenize on : Number of tokens %d\n",dirToSearch->numOfTokens);

	for(i=0;i<dirToSearch->numOfTokens;i++){
  401025:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  40102c:	eb 5d                	jmp    40108b <findBinaryFullPath+0x95>

		//printf("Calling find_file_in_dir token number %d of %d",i,dirToSearch->numOfTokens);
		//printf("\n\npath component 1 %s\n\n",dirToSearch->tokenArr[i]);
		strcpy(temp,dirToSearch->tokenArr[i]);
  40102e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401032:	8b 55 fc             	mov    -0x4(%rbp),%edx
  401035:	48 63 d2             	movslq %edx,%rdx
  401038:	48 8b 54 d0 08       	mov    0x8(%rax,%rdx,8),%rdx
  40103d:	48 8d 45 b6          	lea    -0x4a(%rbp),%rax
  401041:	48 89 d6             	mov    %rdx,%rsi
  401044:	48 89 c7             	mov    %rax,%rdi
  401047:	e8 a9 19 00 00       	callq  4029f5 <strcpy>
		printf("\n\nBefore calling find_file_in_dir %s binary=%s\n",temp, binaryName	);
  40104c:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  401050:	48 8d 45 b6          	lea    -0x4a(%rbp),%rax
  401054:	48 89 c6             	mov    %rax,%rsi
  401057:	48 8d 3d 22 25 00 00 	lea    0x2522(%rip),%rdi        # 403580 <chdir+0x228>
  40105e:	b8 00 00 00 00       	mov    $0x0,%eax
  401063:	e8 82 12 00 00       	callq  4022ea <printf>

		x=find_file_in_dir(temp,binaryName);
  401068:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  40106c:	48 8d 45 b6          	lea    -0x4a(%rbp),%rax
  401070:	48 89 d6             	mov    %rdx,%rsi
  401073:	48 89 c7             	mov    %rax,%rdi
  401076:	e8 8a fe ff ff       	callq  400f05 <find_file_in_dir>
  40107b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		if(x!=NULL){
  40107f:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  401084:	74 02                	je     401088 <findBinaryFullPath+0x92>

			break;
  401086:	eb 0e                	jmp    401096 <findBinaryFullPath+0xa0>

	Token* dirToSearch = tokenize(srchPath,":");

	//printf("After tokenize on : Number of tokens %d\n",dirToSearch->numOfTokens);

	for(i=0;i<dirToSearch->numOfTokens;i++){
  401088:	ff 45 fc             	incl   -0x4(%rbp)
  40108b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40108f:	8b 00                	mov    (%rax),%eax
  401091:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  401094:	7f 98                	jg     40102e <findBinaryFullPath+0x38>

		}
	}


	return x;
  401096:	48 8b 45 f0          	mov    -0x10(%rbp),%rax


}
  40109a:	c9                   	leaveq 
  40109b:	c3                   	retq   

000000000040109c <findEnvVar>:
#include <parser.h>
#include <errno.h>
#include <string.h>
#include <shell.h>

char** findEnvVar(char* envVar, char* envp[]){
  40109c:	55                   	push   %rbp
  40109d:	48 89 e5             	mov    %rsp,%rbp
  4010a0:	48 83 ec 20          	sub    $0x20,%rsp
  4010a4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  4010a8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	 * envVar in the evnp[]. It returns a pointer, which is a pointer to the array
	 * envp[] that contains a the pointer to the envVar string.
	 * If not found returns null.
	 */

	int count=0;
  4010ac:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	Token* tokens;

	//printf("Inside findEnv var\n");
    
	while(envp[count]!= NULL){
  4010b3:	eb 6a                	jmp    40111f <findEnvVar+0x83>

		tokens = tokenize(envp[count],"=");
  4010b5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4010b8:	48 98                	cltq   
  4010ba:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  4010c1:	00 
  4010c2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4010c6:	48 01 d0             	add    %rdx,%rax
  4010c9:	48 8b 00             	mov    (%rax),%rax
  4010cc:	48 8d 35 dd 24 00 00 	lea    0x24dd(%rip),%rsi        # 4035b0 <chdir+0x258>
  4010d3:	48 89 c7             	mov    %rax,%rdi
  4010d6:	e8 ff 09 00 00       	callq  401ada <tokenize>
  4010db:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		//printf("%s\n",envp[count]);

		if(strcmp(tokens->tokenArr[0],envVar)==0){
  4010df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4010e3:	48 8b 40 08          	mov    0x8(%rax),%rax
  4010e7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  4010eb:	48 89 d6             	mov    %rdx,%rsi
  4010ee:	48 89 c7             	mov    %rax,%rdi
  4010f1:	e8 5e 19 00 00       	callq  402a54 <strcmp>
  4010f6:	85 c0                	test   %eax,%eax
  4010f8:	75 16                	jne    401110 <findEnvVar+0x74>
			return(envp+count);
  4010fa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4010fd:	48 98                	cltq   
  4010ff:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  401106:	00 
  401107:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  40110b:	48 01 d0             	add    %rdx,%rax
  40110e:	eb 34                	jmp    401144 <findEnvVar+0xa8>
		}
		free(tokens);
  401110:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401114:	48 89 c7             	mov    %rax,%rdi
  401117:	e8 a9 21 00 00       	callq  4032c5 <free>
		count++;
  40111c:	ff 45 fc             	incl   -0x4(%rbp)
	int count=0;
	Token* tokens;

	//printf("Inside findEnv var\n");
    
	while(envp[count]!= NULL){
  40111f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401122:	48 98                	cltq   
  401124:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  40112b:	00 
  40112c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  401130:	48 01 d0             	add    %rdx,%rax
  401133:	48 8b 00             	mov    (%rax),%rax
  401136:	48 85 c0             	test   %rax,%rax
  401139:	0f 85 76 ff ff ff    	jne    4010b5 <findEnvVar+0x19>
			return(envp+count);
		}
		free(tokens);
		count++;
	}
	return (char**)NULL;
  40113f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  401144:	c9                   	leaveq 
  401145:	c3                   	retq   

0000000000401146 <main1>:
#include <stdio.h>

int main1(int argc, char* argv[], char* envp[]) {
  401146:	55                   	push   %rbp
  401147:	48 89 e5             	mov    %rsp,%rbp
  40114a:	48 83 ec 20          	sub    $0x20,%rsp
  40114e:	89 7d fc             	mov    %edi,-0x4(%rbp)
  401151:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  401155:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	printf("Hello World!\n");
  401159:	48 8d 3d 52 24 00 00 	lea    0x2452(%rip),%rdi        # 4035b2 <chdir+0x25a>
  401160:	b8 00 00 00 00       	mov    $0x0,%eax
  401165:	e8 80 11 00 00       	callq  4022ea <printf>
	return 0;
  40116a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  40116f:	c9                   	leaveq 
  401170:	c3                   	retq   

0000000000401171 <print_info>:
#include <shell.h>




void print_info (parseInfo *info) {
  401171:	55                   	push   %rbp
  401172:	48 89 e5             	mov    %rsp,%rbp
  401175:	48 83 ec 20          	sub    $0x20,%rsp
  401179:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	printf("print_info: printing info about parseInfo struct\n");
  40117d:	48 8d 3d 3c 24 00 00 	lea    0x243c(%rip),%rdi        # 4035c0 <chdir+0x268>
  401184:	b8 00 00 00 00       	mov    $0x0,%eax
  401189:	e8 5c 11 00 00       	callq  4022ea <printf>
	//printf("Number of pipe separated commands %d\n",info->pipeNum);


	int i,j;

	for(i=0;i<=info->pipeNum;i++){
  40118e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  401195:	eb 25                	jmp    4011bc <print_info+0x4b>
		//printf("Command Name : %s\n",info->CommArray[i]->commandName);

		//printf("Command Arguments :\n");
		//printf("Number of arguments %d\n",info->CommArray[i]->VarNum);

		for(j=0;j<info->CommArray[i]->VarNum;j++){
  401197:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  40119e:	eb 03                	jmp    4011a3 <print_info+0x32>
  4011a0:	ff 45 f8             	incl   -0x8(%rbp)
  4011a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4011a7:	8b 55 fc             	mov    -0x4(%rbp),%edx
  4011aa:	48 63 d2             	movslq %edx,%rdx
  4011ad:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  4011b1:	8b 40 58             	mov    0x58(%rax),%eax
  4011b4:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  4011b7:	7f e7                	jg     4011a0 <print_info+0x2f>
	//printf("Number of pipe separated commands %d\n",info->pipeNum);


	int i,j;

	for(i=0;i<=info->pipeNum;i++){
  4011b9:	ff 45 fc             	incl   -0x4(%rbp)
  4011bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4011c0:	8b 40 50             	mov    0x50(%rax),%eax
  4011c3:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  4011c6:	7d cf                	jge    401197 <print_info+0x26>
			//printf("Argument %d : %s \n", j,info->CommArray[i]->VarList[j]);
		}

	}

	return;
  4011c8:	90                   	nop
}
  4011c9:	c9                   	leaveq 
  4011ca:	c3                   	retq   

00000000004011cb <free_info>:

void free_info (parseInfo *info) {
  4011cb:	55                   	push   %rbp
  4011cc:	48 89 e5             	mov    %rsp,%rbp
  4011cf:	48 83 ec 10          	sub    $0x10,%rsp
  4011d3:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	//printf("free_info: freeing memory associated to parseInfo struct\n");
	free(info);
  4011d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4011db:	48 89 c7             	mov    %rax,%rdi
  4011de:	e8 e2 20 00 00       	callq  4032c5 <free>
}
  4011e3:	c9                   	leaveq 
  4011e4:	c3                   	retq   

00000000004011e5 <parseModified>:

parseInfo* parseModified(char *cmd,char* envp[]){
  4011e5:	55                   	push   %rbp
  4011e6:	48 89 e5             	mov    %rsp,%rbp
  4011e9:	48 81 ec 40 02 00 00 	sub    $0x240,%rsp
  4011f0:	48 89 bd c8 fd ff ff 	mov    %rdi,-0x238(%rbp)
  4011f7:	48 89 b5 c0 fd ff ff 	mov    %rsi,-0x240(%rbp)

	parseInfo *Result;
	Token* tokenPipe;
	Token* tokenSpace;
	//Token* path;
	singleCommand* sc = NULL;
  4011fe:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  401205:	00 
//	char** envVar=NULL;
	char *fullPath=NULL;
  401206:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  40120d:	00 
	int i=0,j=0;
  40120e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  401215:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	char srchPath[500];
	//printf("In PARSE MODIFIED");
	Result = (parseInfo*)malloc(sizeof(parseInfo));
  40121c:	bf 58 00 00 00       	mov    $0x58,%edi
  401221:	e8 32 1f 00 00       	callq  403158 <malloc>
  401226:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

//	envVar=findEnvVar("PATH",envp);
    //envVar[0]="PATH=/bin";
	printf("In parser... full PATH= %s\n\n",cmd);
  40122a:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  401231:	48 89 c6             	mov    %rax,%rsi
  401234:	48 8d 3d b7 23 00 00 	lea    0x23b7(%rip),%rdi        # 4035f2 <chdir+0x29a>
  40123b:	b8 00 00 00 00       	mov    $0x0,%eax
  401240:	e8 a5 10 00 00       	callq  4022ea <printf>
//		printf("PATH is ---> %s",path->tokenArr[1]);

    

	//strcpy(srchPath,path->tokenArr[1]);
	strcpy(srchPath,"/bin");
  401245:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  40124c:	48 8d 35 bc 23 00 00 	lea    0x23bc(%rip),%rsi        # 40360f <chdir+0x2b7>
  401253:	48 89 c7             	mov    %rax,%rdi
  401256:	e8 9a 17 00 00       	callq  4029f5 <strcpy>

	printf("Seatch PAth is %s",srchPath);
  40125b:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  401262:	48 89 c6             	mov    %rax,%rsi
  401265:	48 8d 3d a8 23 00 00 	lea    0x23a8(%rip),%rdi        # 403614 <chdir+0x2bc>
  40126c:	b8 00 00 00 00       	mov    $0x0,%eax
  401271:	e8 74 10 00 00       	callq  4022ea <printf>

	tokenPipe = tokenize(cmd,"|");
  401276:	48 8b 85 c8 fd ff ff 	mov    -0x238(%rbp),%rax
  40127d:	48 8d 35 a2 23 00 00 	lea    0x23a2(%rip),%rsi        # 403626 <chdir+0x2ce>
  401284:	48 89 c7             	mov    %rax,%rdi
  401287:	e8 4e 08 00 00       	callq  401ada <tokenize>
  40128c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	printf("In PARSE MODIFIED%d\n",tokenPipe->numOfTokens);
  401290:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401294:	8b 00                	mov    (%rax),%eax
  401296:	89 c6                	mov    %eax,%esi
  401298:	48 8d 3d 89 23 00 00 	lea    0x2389(%rip),%rdi        # 403628 <chdir+0x2d0>
  40129f:	b8 00 00 00 00       	mov    $0x0,%eax
  4012a4:	e8 41 10 00 00       	callq  4022ea <printf>
	for(i=0;i<tokenPipe->numOfTokens;i++){
  4012a9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  4012b0:	e9 14 02 00 00       	jmpq   4014c9 <parseModified+0x2e4>

		//for each pipe separated token find space separated tokens
		tokenSpace=tokenize(tokenPipe->tokenArr[i]," ");
  4012b5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4012b9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  4012bc:	48 63 d2             	movslq %edx,%rdx
  4012bf:	48 8b 44 d0 08       	mov    0x8(%rax,%rdx,8),%rax
  4012c4:	48 8d 35 72 23 00 00 	lea    0x2372(%rip),%rsi        # 40363d <chdir+0x2e5>
  4012cb:	48 89 c7             	mov    %rax,%rdi
  4012ce:	e8 07 08 00 00       	callq  401ada <tokenize>
  4012d3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

		//initialize the singleCommand Structure
		sc = (singleCommand*)malloc(sizeof(singleCommand));
  4012d7:	bf 60 00 00 00       	mov    $0x60,%edi
  4012dc:	e8 77 1e 00 00       	callq  403158 <malloc>
  4012e1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		sc->commandName=(char*)malloc(100);
  4012e5:	bf 64 00 00 00       	mov    $0x64,%edi
  4012ea:	e8 69 1e 00 00       	callq  403158 <malloc>
  4012ef:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  4012f3:	48 89 02             	mov    %rax,(%rdx)
		sc->commandName[0]='\0';
  4012f6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4012fa:	48 8b 00             	mov    (%rax),%rax
  4012fd:	c6 00 00             	movb   $0x0,(%rax)
		printf("Before find full binary path\n\n\n");
  401300:	48 8d 3d 39 23 00 00 	lea    0x2339(%rip),%rdi        # 403640 <chdir+0x2e8>
  401307:	b8 00 00 00 00       	mov    $0x0,%eax
  40130c:	e8 d9 0f 00 00       	callq  4022ea <printf>
		sc->commandName=tokenSpace->tokenArr[0];
  401311:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401315:	48 8b 50 08          	mov    0x8(%rax),%rdx
  401319:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40131d:	48 89 10             	mov    %rdx,(%rax)
		if(strcmp(tokenSpace->tokenArr[0],"set") && strcmp(tokenSpace->tokenArr[0],"cd") && strcmp(tokenSpace->tokenArr[0],"exit") )
  401320:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401324:	48 8b 40 08          	mov    0x8(%rax),%rax
  401328:	48 8d 35 31 23 00 00 	lea    0x2331(%rip),%rsi        # 403660 <chdir+0x308>
  40132f:	48 89 c7             	mov    %rax,%rdi
  401332:	e8 1d 17 00 00       	callq  402a54 <strcmp>
  401337:	85 c0                	test   %eax,%eax
  401339:	0f 84 05 01 00 00    	je     401444 <parseModified+0x25f>
  40133f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401343:	48 8b 40 08          	mov    0x8(%rax),%rax
  401347:	48 8d 35 16 23 00 00 	lea    0x2316(%rip),%rsi        # 403664 <chdir+0x30c>
  40134e:	48 89 c7             	mov    %rax,%rdi
  401351:	e8 fe 16 00 00       	callq  402a54 <strcmp>
  401356:	85 c0                	test   %eax,%eax
  401358:	0f 84 e6 00 00 00    	je     401444 <parseModified+0x25f>
  40135e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401362:	48 8b 40 08          	mov    0x8(%rax),%rax
  401366:	48 8d 35 fa 22 00 00 	lea    0x22fa(%rip),%rsi        # 403667 <chdir+0x30f>
  40136d:	48 89 c7             	mov    %rax,%rdi
  401370:	e8 df 16 00 00       	callq  402a54 <strcmp>
  401375:	85 c0                	test   %eax,%eax
  401377:	0f 84 c7 00 00 00    	je     401444 <parseModified+0x25f>
		{
			printf("Loop %d cmd: %s\n\n",i,tokenSpace->tokenArr[0] );
  40137d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401381:	48 8b 50 08          	mov    0x8(%rax),%rdx
  401385:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401388:	89 c6                	mov    %eax,%esi
  40138a:	48 8d 3d db 22 00 00 	lea    0x22db(%rip),%rdi        # 40366c <chdir+0x314>
  401391:	b8 00 00 00 00       	mov    $0x0,%eax
  401396:	e8 4f 0f 00 00       	callq  4022ea <printf>

			if(strstr(tokenSpace->tokenArr[0],"/")==NULL){
  40139b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40139f:	48 8b 40 08          	mov    0x8(%rax),%rax
  4013a3:	48 8d 35 d4 22 00 00 	lea    0x22d4(%rip),%rsi        # 40367e <chdir+0x326>
  4013aa:	48 89 c7             	mov    %rax,%rdi
  4013ad:	e8 29 17 00 00       	callq  402adb <strstr>
  4013b2:	48 85 c0             	test   %rax,%rax
  4013b5:	0f 85 89 00 00 00    	jne    401444 <parseModified+0x25f>

				fullPath=findBinaryFullPath(srchPath,tokenSpace->tokenArr[0]);
  4013bb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4013bf:	48 8b 50 08          	mov    0x8(%rax),%rdx
  4013c3:	48 8d 85 dc fd ff ff 	lea    -0x224(%rbp),%rax
  4013ca:	48 89 d6             	mov    %rdx,%rsi
  4013cd:	48 89 c7             	mov    %rax,%rdi
  4013d0:	e8 21 fc ff ff       	callq  400ff6 <findBinaryFullPath>
  4013d5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				if(fullPath==NULL)
  4013d9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  4013de:	75 1b                	jne    4013fb <parseModified+0x216>
				{
					printf("Error:Command Not found.\n");
  4013e0:	48 8d 3d 99 22 00 00 	lea    0x2299(%rip),%rdi        # 403680 <chdir+0x328>
  4013e7:	b8 00 00 00 00       	mov    $0x0,%eax
  4013ec:	e8 f9 0e 00 00       	callq  4022ea <printf>
					return NULL;
  4013f1:	b8 00 00 00 00       	mov    $0x0,%eax
  4013f6:	e9 f1 00 00 00       	jmpq   4014ec <parseModified+0x307>
				}
				sc->commandName = fullPath;
  4013fb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4013ff:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  401403:	48 89 10             	mov    %rdx,(%rax)
				sc->commandName = strcat(sc->commandName,"/");
  401406:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40140a:	48 8b 00             	mov    (%rax),%rax
  40140d:	48 8d 35 6a 22 00 00 	lea    0x226a(%rip),%rsi        # 40367e <chdir+0x326>
  401414:	48 89 c7             	mov    %rax,%rdi
  401417:	e8 9d 17 00 00       	callq  402bb9 <strcat>
  40141c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  401420:	48 89 02             	mov    %rax,(%rdx)
				sc->commandName = strcat(sc->commandName,tokenSpace->tokenArr[0]);
  401423:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401427:	48 8b 50 08          	mov    0x8(%rax),%rdx
  40142b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40142f:	48 8b 00             	mov    (%rax),%rax
  401432:	48 89 d6             	mov    %rdx,%rsi
  401435:	48 89 c7             	mov    %rax,%rdi
  401438:	e8 7c 17 00 00       	callq  402bb9 <strcat>
  40143d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  401441:	48 89 02             	mov    %rax,(%rdx)
		}

		//printf("In parser..fullpath for %s is %s\n",tokenSpace->tokenArr[0],fullPath);


		printf("COMMAND NAME=%s\n",sc->commandName);
  401444:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401448:	48 8b 00             	mov    (%rax),%rax
  40144b:	48 89 c6             	mov    %rax,%rsi
  40144e:	48 8d 3d 45 22 00 00 	lea    0x2245(%rip),%rdi        # 40369a <chdir+0x342>
  401455:	b8 00 00 00 00       	mov    $0x0,%eax
  40145a:	e8 8b 0e 00 00       	callq  4022ea <printf>
		//sc->VarList[0]=fullPath;
		sc->VarNum = tokenSpace->numOfTokens;
  40145f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401463:	8b 10                	mov    (%rax),%edx
  401465:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401469:	89 50 58             	mov    %edx,0x58(%rax)
		for(j=0;j<tokenSpace->numOfTokens;j++){
  40146c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  401473:	eb 21                	jmp    401496 <parseModified+0x2b1>
			sc->VarList[j]=tokenSpace->tokenArr[j];
  401475:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401479:	8b 55 f8             	mov    -0x8(%rbp),%edx
  40147c:	48 63 d2             	movslq %edx,%rdx
  40147f:	48 8b 4c d0 08       	mov    0x8(%rax,%rdx,8),%rcx
  401484:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401488:	8b 55 f8             	mov    -0x8(%rbp),%edx
  40148b:	48 63 d2             	movslq %edx,%rdx
  40148e:	48 89 4c d0 08       	mov    %rcx,0x8(%rax,%rdx,8)


		printf("COMMAND NAME=%s\n",sc->commandName);
		//sc->VarList[0]=fullPath;
		sc->VarNum = tokenSpace->numOfTokens;
		for(j=0;j<tokenSpace->numOfTokens;j++){
  401493:	ff 45 f8             	incl   -0x8(%rbp)
  401496:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  40149a:	8b 00                	mov    (%rax),%eax
  40149c:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  40149f:	7f d4                	jg     401475 <parseModified+0x290>
			sc->VarList[j]=tokenSpace->tokenArr[j];
		}
		sc->VarList[j]=NULL;
  4014a1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4014a5:	8b 55 f8             	mov    -0x8(%rbp),%edx
  4014a8:	48 63 d2             	movslq %edx,%rdx
  4014ab:	48 c7 44 d0 08 00 00 	movq   $0x0,0x8(%rax,%rdx,8)
  4014b2:	00 00 

		Result->CommArray[i]=sc;
  4014b4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4014b8:	8b 55 fc             	mov    -0x4(%rbp),%edx
  4014bb:	48 63 d2             	movslq %edx,%rdx
  4014be:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  4014c2:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
	printf("Seatch PAth is %s",srchPath);

	tokenPipe = tokenize(cmd,"|");

	printf("In PARSE MODIFIED%d\n",tokenPipe->numOfTokens);
	for(i=0;i<tokenPipe->numOfTokens;i++){
  4014c6:	ff 45 fc             	incl   -0x4(%rbp)
  4014c9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4014cd:	8b 00                	mov    (%rax),%eax
  4014cf:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  4014d2:	0f 8f dd fd ff ff    	jg     4012b5 <parseModified+0xd0>

		Result->CommArray[i]=sc;

	}

	Result->pipeNum=tokenPipe->numOfTokens-1; //set the number of pipe separated commands
  4014d8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4014dc:	8b 00                	mov    (%rax),%eax
  4014de:	8d 50 ff             	lea    -0x1(%rax),%edx
  4014e1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4014e5:	89 50 50             	mov    %edx,0x50(%rax)

	return Result;
  4014e8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  4014ec:	c9                   	leaveq 
  4014ed:	c3                   	retq   

00000000004014ee <read_line>:

int read_line(int fd, char* buf)
{
  4014ee:	55                   	push   %rbp
  4014ef:	48 89 e5             	mov    %rsp,%rbp
  4014f2:	48 83 ec 10          	sub    $0x10,%rsp
  4014f6:	89 7d fc             	mov    %edi,-0x4(%rbp)
  4014f9:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
		//printf("read: %c ",*byte);
		if (ret == -1)
			return -1;
	}
	*(byte-1)='\0';*/
    read(0,buf,MAXLINE);
  4014fd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401501:	ba 00 01 00 00       	mov    $0x100,%edx
  401506:	48 89 c6             	mov    %rax,%rsi
  401509:	bf 00 00 00 00       	mov    $0x0,%edi
  40150e:	e8 c1 12 00 00       	callq  4027d4 <read>
	return 1;
  401513:	b8 01 00 00 00       	mov    $0x1,%eax
}
  401518:	c9                   	leaveq 
  401519:	c3                   	retq   

000000000040151a <changePS1>:
#include <parser.h>
#include <errno.h>
#include <string.h>
#include <shell.h>

void changePS1(char*str){
  40151a:	55                   	push   %rbp
  40151b:	48 89 e5             	mov    %rsp,%rbp
  40151e:	48 83 ec 20          	sub    $0x20,%rsp
  401522:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	 * The PS1 is a shell variable
	 *
	 */

	Token* tokenEqulas;
	tokenEqulas = tokenize(str,"=");
  401526:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40152a:	48 8d 35 7f 21 00 00 	lea    0x217f(%rip),%rsi        # 4036b0 <chdir+0x358>
  401531:	48 89 c7             	mov    %rax,%rdi
  401534:	e8 a1 05 00 00       	callq  401ada <tokenize>
  401539:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	//printf("no:%d\n\n",tokenEqulas->numOfTokens);

	if(tokenEqulas->numOfTokens < 2)
  40153d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401541:	8b 00                	mov    (%rax),%eax
  401543:	83 f8 01             	cmp    $0x1,%eax
  401546:	7f 13                	jg     40155b <changePS1+0x41>
	{
		printf("Error:Invalid PS1\n");
  401548:	48 8d 3d 63 21 00 00 	lea    0x2163(%rip),%rdi        # 4036b2 <chdir+0x35a>
  40154f:	b8 00 00 00 00       	mov    $0x0,%eax
  401554:	e8 91 0d 00 00       	callq  4022ea <printf>
  401559:	eb 5d                	jmp    4015b8 <changePS1+0x9e>
	}
	else if(strlen(tokenEqulas->tokenArr[1])>100){
  40155b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40155f:	48 8b 40 10          	mov    0x10(%rax),%rax
  401563:	48 89 c7             	mov    %rax,%rdi
  401566:	e8 55 14 00 00       	callq  4029c0 <strlen>
  40156b:	83 f8 64             	cmp    $0x64,%eax
  40156e:	7e 13                	jle    401583 <changePS1+0x69>
		printf("Too long a prompt name.Pleasee try again\n");
  401570:	48 8d 3d 51 21 00 00 	lea    0x2151(%rip),%rdi        # 4036c8 <chdir+0x370>
  401577:	b8 00 00 00 00       	mov    $0x0,%eax
  40157c:	e8 69 0d 00 00       	callq  4022ea <printf>
  401581:	eb 35                	jmp    4015b8 <changePS1+0x9e>
	}


	else{

		strcpy(PS1,tokenEqulas->tokenArr[1]);
  401583:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401587:	48 8b 40 10          	mov    0x10(%rax),%rax
  40158b:	48 89 c6             	mov    %rax,%rsi
  40158e:	48 8d 05 0b 30 20 00 	lea    0x20300b(%rip),%rax        # 6045a0 <PS1>
  401595:	48 89 c7             	mov    %rax,%rdi
  401598:	e8 58 14 00 00       	callq  4029f5 <strcpy>
		printf("PS1 after change %s\n",PS1);
  40159d:	48 8d 05 fc 2f 20 00 	lea    0x202ffc(%rip),%rax        # 6045a0 <PS1>
  4015a4:	48 89 c6             	mov    %rax,%rsi
  4015a7:	48 8d 3d 44 21 00 00 	lea    0x2144(%rip),%rdi        # 4036f2 <chdir+0x39a>
  4015ae:	b8 00 00 00 00       	mov    $0x0,%eax
  4015b3:	e8 32 0d 00 00       	callq  4022ea <printf>
	}

}
  4015b8:	c9                   	leaveq 
  4015b9:	c3                   	retq   

00000000004015ba <removeSpaces>:
#include<stdio.h>
#include<string.h>
#include<stdlib.h>


char* removeSpaces(char*str){
  4015ba:	55                   	push   %rbp
  4015bb:	48 89 e5             	mov    %rsp,%rbp
  4015be:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  4015c5:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
	/*
	 * This function removes spaces from str without modifying it
	 * The string returned must be malloced
	 */

	int i=0,j=0;
  4015cc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  4015d3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	char *noSpaceStr=NULL;
  4015da:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  4015e1:	00 
	char temp[100];


	for(i=0;i<strlen(str);i++){
  4015e2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  4015e9:	eb 3c                	jmp    401627 <removeSpaces+0x6d>

		if(str[i]!=' '){
  4015eb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4015ee:	48 63 d0             	movslq %eax,%rdx
  4015f1:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  4015f8:	48 01 d0             	add    %rdx,%rax
  4015fb:	0f b6 00             	movzbl (%rax),%eax
  4015fe:	3c 20                	cmp    $0x20,%al
  401600:	74 22                	je     401624 <removeSpaces+0x6a>
			temp[j++]=str[i];
  401602:	8b 45 f8             	mov    -0x8(%rbp),%eax
  401605:	8d 50 01             	lea    0x1(%rax),%edx
  401608:	89 55 f8             	mov    %edx,-0x8(%rbp)
  40160b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  40160e:	48 63 ca             	movslq %edx,%rcx
  401611:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  401618:	48 01 ca             	add    %rcx,%rdx
  40161b:	0f b6 12             	movzbl (%rdx),%edx
  40161e:	48 98                	cltq   
  401620:	88 54 05 8c          	mov    %dl,-0x74(%rbp,%rax,1)
	int i=0,j=0;
	char *noSpaceStr=NULL;
	char temp[100];


	for(i=0;i<strlen(str);i++){
  401624:	ff 45 fc             	incl   -0x4(%rbp)
  401627:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  40162e:	48 89 c7             	mov    %rax,%rdi
  401631:	e8 8a 13 00 00       	callq  4029c0 <strlen>
  401636:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  401639:	7f b0                	jg     4015eb <removeSpaces+0x31>
		if(str[i]!=' '){
			temp[j++]=str[i];
		}

	}
	temp[j]='\0';
  40163b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  40163e:	48 98                	cltq   
  401640:	c6 44 05 8c 00       	movb   $0x0,-0x74(%rbp,%rax,1)

	noSpaceStr = malloc(sizeof(char)*(strlen(temp)));
  401645:	48 8d 45 8c          	lea    -0x74(%rbp),%rax
  401649:	48 89 c7             	mov    %rax,%rdi
  40164c:	e8 6f 13 00 00       	callq  4029c0 <strlen>
  401651:	48 98                	cltq   
  401653:	48 89 c7             	mov    %rax,%rdi
  401656:	e8 fd 1a 00 00       	callq  403158 <malloc>
  40165b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	strcpy(noSpaceStr,temp);
  40165f:	48 8d 55 8c          	lea    -0x74(%rbp),%rdx
  401663:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401667:	48 89 d6             	mov    %rdx,%rsi
  40166a:	48 89 c7             	mov    %rax,%rdi
  40166d:	e8 83 13 00 00       	callq  4029f5 <strcpy>

	return noSpaceStr;
  401672:	48 8b 45 f0          	mov    -0x10(%rbp),%rax

}
  401676:	c9                   	leaveq 
  401677:	c3                   	retq   

0000000000401678 <parallel_fork>:
#include <stdlib.h>
#include <test.h>
#include <errno.h>
#include <string.h>

void parallel_fork(){
  401678:	55                   	push   %rbp
  401679:	48 89 e5             	mov    %rsp,%rbp


    //int *pipe = (int*)malloc(4*sizeof(int));


}
  40167c:	5d                   	pop    %rbp
  40167d:	c3                   	retq   

000000000040167e <fact>:


int fact(int n)
{
  40167e:	55                   	push   %rbp
  40167f:	48 89 e5             	mov    %rsp,%rbp
  401682:	53                   	push   %rbx
  401683:	48 83 ec 28          	sub    $0x28,%rsp
  401687:	89 7d dc             	mov    %edi,-0x24(%rbp)
    if(n==0 || n==1)
  40168a:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  40168e:	74 06                	je     401696 <fact+0x18>
  401690:	83 7d dc 01          	cmpl   $0x1,-0x24(%rbp)
  401694:	75 07                	jne    40169d <fact+0x1f>
        return 1;
  401696:	b8 01 00 00 00       	mov    $0x1,%eax
  40169b:	eb 39                	jmp    4016d6 <fact+0x58>
    int ret =fact(n-1)+fact(n-2);
  40169d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  4016a0:	ff c8                	dec    %eax
  4016a2:	89 c7                	mov    %eax,%edi
  4016a4:	e8 d5 ff ff ff       	callq  40167e <fact>
  4016a9:	89 c3                	mov    %eax,%ebx
  4016ab:	8b 45 dc             	mov    -0x24(%rbp),%eax
  4016ae:	83 e8 02             	sub    $0x2,%eax
  4016b1:	89 c7                	mov    %eax,%edi
  4016b3:	e8 c6 ff ff ff       	callq  40167e <fact>
  4016b8:	01 d8                	add    %ebx,%eax
  4016ba:	89 45 ec             	mov    %eax,-0x14(%rbp)
    printf("returning %d ",ret);
  4016bd:	8b 45 ec             	mov    -0x14(%rbp),%eax
  4016c0:	89 c6                	mov    %eax,%esi
  4016c2:	48 8d 3d 3e 20 00 00 	lea    0x203e(%rip),%rdi        # 403707 <chdir+0x3af>
  4016c9:	b8 00 00 00 00       	mov    $0x0,%eax
  4016ce:	e8 17 0c 00 00       	callq  4022ea <printf>
    return ret;
  4016d3:	8b 45 ec             	mov    -0x14(%rbp),%eax
    
}
  4016d6:	48 83 c4 28          	add    $0x28,%rsp
  4016da:	5b                   	pop    %rbx
  4016db:	5d                   	pop    %rbp
  4016dc:	c3                   	retq   

00000000004016dd <main11>:
int main11(int argc, char* argv[], char* envp[])
{
  4016dd:	55                   	push   %rbp
  4016de:	48 89 e5             	mov    %rsp,%rbp
  4016e1:	48 83 ec 20          	sub    $0x20,%rsp
  4016e5:	89 7d fc             	mov    %edi,-0x4(%rbp)
  4016e8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  4016ec:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)

fact(10);
  4016f0:	bf 0a 00 00 00       	mov    $0xa,%edi
  4016f5:	e8 84 ff ff ff       	callq  40167e <fact>
         printf("chpid[%d]= %d",0,pid[0]);
         waitpid(pid[i],&status,0);
   }
printf("\n***PARENT EXITNG***\n");*/

return 0;
  4016fa:	b8 00 00 00 00       	mov    $0x0,%eax
}
  4016ff:	c9                   	leaveq 
  401700:	c3                   	retq   

0000000000401701 <main>:


char PS1[200]="SBUSH";

int main (int argc, char *argv[], char* envp[])
{
  401701:	55                   	push   %rbp
  401702:	48 89 e5             	mov    %rsp,%rbp
  401705:	48 81 ec 50 01 00 00 	sub    $0x150,%rsp
  40170c:	89 bd cc fe ff ff    	mov    %edi,-0x134(%rbp)
  401712:	48 89 b5 c0 fe ff ff 	mov    %rsi,-0x140(%rbp)
  401719:	48 89 95 b8 fe ff ff 	mov    %rdx,-0x148(%rbp)


	char cmdLine[MAXLINE];


	int fd=0,ret;
  401720:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	parseInfo *info; //info stores all the information returned by parser.
	//printf("Akshay Kale %s, \n",x);
	//exit(0);
    //sleep(10);
//    printf("Argv1is:%s",argv[1]);
	if(argv && argv[1]!=NULL)
  401727:	48 83 bd c0 fe ff ff 	cmpq   $0x0,-0x140(%rbp)
  40172e:	00 
  40172f:	74 42                	je     401773 <main+0x72>
  401731:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
  401738:	48 83 c0 08          	add    $0x8,%rax
  40173c:	48 8b 00             	mov    (%rax),%rax
  40173f:	48 85 c0             	test   %rax,%rax
  401742:	74 2f                	je     401773 <main+0x72>
	{
		printf("executing script");
  401744:	48 8d 3d ca 1f 00 00 	lea    0x1fca(%rip),%rdi        # 403715 <chdir+0x3bd>
  40174b:	b8 00 00 00 00       	mov    $0x0,%eax
  401750:	e8 95 0b 00 00       	callq  4022ea <printf>
		fd=open(argv[1],0);
  401755:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
  40175c:	48 83 c0 08          	add    $0x8,%rax
  401760:	48 8b 00             	mov    (%rax),%rax
  401763:	be 00 00 00 00       	mov    $0x0,%esi
  401768:	48 89 c7             	mov    %rax,%rdi
  40176b:	e8 e9 06 00 00       	callq  401e59 <open>
  401770:	89 45 fc             	mov    %eax,-0x4(%rbp)

	while(1)
	{
		//cmdLine = "Santosh 1 2 3 | ls -l";

		if(argv[1] == NULL)
  401773:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
  40177a:	48 83 c0 08          	add    $0x8,%rax
  40177e:	48 8b 00             	mov    (%rax),%rax
  401781:	48 85 c0             	test   %rax,%rax
  401784:	75 31                	jne    4017b7 <main+0xb6>
		{
			printf("%s> ",PS1);
  401786:	48 8d 05 13 2e 20 00 	lea    0x202e13(%rip),%rax        # 6045a0 <PS1>
  40178d:	48 89 c6             	mov    %rax,%rsi
  401790:	48 8d 3d 8f 1f 00 00 	lea    0x1f8f(%rip),%rdi        # 403726 <chdir+0x3ce>
  401797:	b8 00 00 00 00       	mov    $0x0,%eax
  40179c:	e8 49 0b 00 00       	callq  4022ea <printf>
			read_line(0,cmdLine);
  4017a1:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  4017a8:	48 89 c6             	mov    %rax,%rsi
  4017ab:	bf 00 00 00 00       	mov    $0x0,%edi
  4017b0:	e8 39 fd ff ff       	callq  4014ee <read_line>
  4017b5:	eb 46                	jmp    4017fd <main+0xfc>
		}
		else
		{
			//printf("here");
			ret=read_line(fd, cmdLine);
  4017b7:	48 8d 95 f0 fe ff ff 	lea    -0x110(%rbp),%rdx
  4017be:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4017c1:	48 89 d6             	mov    %rdx,%rsi
  4017c4:	89 c7                	mov    %eax,%edi
  4017c6:	e8 23 fd ff ff       	callq  4014ee <read_line>
  4017cb:	89 45 f8             	mov    %eax,-0x8(%rbp)
			while (cmdLine[0] == '#')
  4017ce:	eb 17                	jmp    4017e7 <main+0xe6>
				ret=read_line(fd,cmdLine);
  4017d0:	48 8d 95 f0 fe ff ff 	lea    -0x110(%rbp),%rdx
  4017d7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4017da:	48 89 d6             	mov    %rdx,%rsi
  4017dd:	89 c7                	mov    %eax,%edi
  4017df:	e8 0a fd ff ff       	callq  4014ee <read_line>
  4017e4:	89 45 f8             	mov    %eax,-0x8(%rbp)
		}
		else
		{
			//printf("here");
			ret=read_line(fd, cmdLine);
			while (cmdLine[0] == '#')
  4017e7:	0f b6 85 f0 fe ff ff 	movzbl -0x110(%rbp),%eax
  4017ee:	3c 23                	cmp    $0x23,%al
  4017f0:	74 de                	je     4017d0 <main+0xcf>
				ret=read_line(fd,cmdLine);
			if(ret == -1)
  4017f2:	83 7d f8 ff          	cmpl   $0xffffffff,-0x8(%rbp)
  4017f6:	75 05                	jne    4017fd <main+0xfc>
				break;
  4017f8:	e9 5c 01 00 00       	jmpq   401959 <main+0x258>
		}
//    strcpy(cmdLine,"malluaunty");
        printf("entered: %s",cmdLine);
  4017fd:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  401804:	48 89 c6             	mov    %rax,%rsi
  401807:	48 8d 3d 1d 1f 00 00 	lea    0x1f1d(%rip),%rdi        # 40372b <chdir+0x3d3>
  40180e:	b8 00 00 00 00       	mov    $0x0,%eax
  401813:	e8 d2 0a 00 00       	callq  4022ea <printf>
		if (cmdLine == NULL) {
			printf("Unable to read last command\n");
			continue;
		}

		if(!(*cmdLine)){
  401818:	0f b6 85 f0 fe ff ff 	movzbl -0x110(%rbp),%eax
  40181f:	84 c0                	test   %al,%al
  401821:	75 05                	jne    401828 <main+0x127>
			//printf("No command entered\n");
			continue;
  401823:	e9 2c 01 00 00       	jmpq   401954 <main+0x253>
		}

		printf("Calling parser%s",cmdLine);
  401828:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  40182f:	48 89 c6             	mov    %rax,%rsi
  401832:	48 8d 3d fe 1e 00 00 	lea    0x1efe(%rip),%rdi        # 403737 <chdir+0x3df>
  401839:	b8 00 00 00 00       	mov    $0x0,%eax
  40183e:	e8 a7 0a 00 00       	callq  4022ea <printf>
		info = parseModified(cmdLine,envp);
  401843:	48 8b 95 b8 fe ff ff 	mov    -0x148(%rbp),%rdx
  40184a:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  401851:	48 89 d6             	mov    %rdx,%rsi
  401854:	48 89 c7             	mov    %rax,%rdi
  401857:	e8 89 f9 ff ff       	callq  4011e5 <parseModified>
  40185c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		if (info == NULL){
  401860:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  401865:	75 14                	jne    40187b <main+0x17a>
			free(cmdLine);
  401867:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  40186e:	48 89 c7             	mov    %rax,%rdi
  401871:	e8 4f 1a 00 00       	callq  4032c5 <free>
			continue;
  401876:	e9 d9 00 00 00       	jmpq   401954 <main+0x253>
		}

		//prints the info struct
		print_info(info);
  40187b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40187f:	48 89 c7             	mov    %rax,%rdi
  401882:	e8 ea f8 ff ff       	callq  401171 <print_info>

		strcpy(temp,info->CommArray[0]->commandName);
  401887:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40188b:	48 8b 00             	mov    (%rax),%rax
  40188e:	48 8b 10             	mov    (%rax),%rdx
  401891:	48 8d 85 dc fe ff ff 	lea    -0x124(%rbp),%rax
  401898:	48 89 d6             	mov    %rdx,%rsi
  40189b:	48 89 c7             	mov    %rax,%rdi
  40189e:	e8 52 11 00 00       	callq  4029f5 <strcpy>

		if(strcmp(temp,"set")==0||strcmp(temp,"cd")==0 || strcmp(temp,"exit")==0){
  4018a3:	48 8d 85 dc fe ff ff 	lea    -0x124(%rbp),%rax
  4018aa:	48 8d 35 97 1e 00 00 	lea    0x1e97(%rip),%rsi        # 403748 <chdir+0x3f0>
  4018b1:	48 89 c7             	mov    %rax,%rdi
  4018b4:	e8 9b 11 00 00       	callq  402a54 <strcmp>
  4018b9:	85 c0                	test   %eax,%eax
  4018bb:	74 34                	je     4018f1 <main+0x1f0>
  4018bd:	48 8d 85 dc fe ff ff 	lea    -0x124(%rbp),%rax
  4018c4:	48 8d 35 81 1e 00 00 	lea    0x1e81(%rip),%rsi        # 40374c <chdir+0x3f4>
  4018cb:	48 89 c7             	mov    %rax,%rdi
  4018ce:	e8 81 11 00 00       	callq  402a54 <strcmp>
  4018d3:	85 c0                	test   %eax,%eax
  4018d5:	74 1a                	je     4018f1 <main+0x1f0>
  4018d7:	48 8d 85 dc fe ff ff 	lea    -0x124(%rbp),%rax
  4018de:	48 8d 35 6a 1e 00 00 	lea    0x1e6a(%rip),%rsi        # 40374f <chdir+0x3f7>
  4018e5:	48 89 c7             	mov    %rax,%rdi
  4018e8:	e8 67 11 00 00       	callq  402a54 <strcmp>
  4018ed:	85 c0                	test   %eax,%eax
  4018ef:	75 29                	jne    40191a <main+0x219>

			printf("Executing Builtin command\n");
  4018f1:	48 8d 3d 5c 1e 00 00 	lea    0x1e5c(%rip),%rdi        # 403754 <chdir+0x3fc>
  4018f8:	b8 00 00 00 00       	mov    $0x0,%eax
  4018fd:	e8 e8 09 00 00       	callq  4022ea <printf>
			executeBuiltins(info,envp);
  401902:	48 8b 95 b8 fe ff ff 	mov    -0x148(%rbp),%rdx
  401909:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40190d:	48 89 d6             	mov    %rdx,%rsi
  401910:	48 89 c7             	mov    %rax,%rdi
  401913:	e8 c6 ef ff ff       	callq  4008de <executeBuiltins>
  401918:	eb 27                	jmp    401941 <main+0x240>
		}

		else{
            printf("Calling Execute");
  40191a:	48 8d 3d 4e 1e 00 00 	lea    0x1e4e(%rip),%rdi        # 40376f <chdir+0x417>
  401921:	b8 00 00 00 00       	mov    $0x0,%eax
  401926:	e8 bf 09 00 00       	callq  4022ea <printf>
			execute_cmd(info,envp);
  40192b:	48 8b 95 b8 fe ff ff 	mov    -0x148(%rbp),%rdx
  401932:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401936:	48 89 d6             	mov    %rdx,%rsi
  401939:	48 89 c7             	mov    %rax,%rdi
  40193c:	e8 6a f1 ff ff       	callq  400aab <execute_cmd>
		}



		static int loop=0;
		loop++;
  401941:	8b 05 39 2d 20 00    	mov    0x202d39(%rip),%eax        # 604680 <loop.1277>
  401947:	ff c0                	inc    %eax
  401949:	89 05 31 2d 20 00    	mov    %eax,0x202d31(%rip)        # 604680 <loop.1277>
		//printf("Out of execute%d\n",loop++);
		//exit(0);
	}/* while(1) */
  40194f:	e9 1f fe ff ff       	jmpq   401773 <main+0x72>
  401954:	e9 1a fe ff ff       	jmpq   401773 <main+0x72>
	//printf("BYE BYE");
	return 0;
  401959:	b8 00 00 00 00       	mov    $0x0,%eax
}
  40195e:	c9                   	leaveq 
  40195f:	c3                   	retq   

0000000000401960 <onlyWhiteSpace>:
#include <string.h>
#include <shell.h>



int onlyWhiteSpace(char *str){
  401960:	55                   	push   %rbp
  401961:	48 89 e5             	mov    %rsp,%rbp
  401964:	48 83 ec 18          	sub    $0x18,%rsp
  401968:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	//checks if a token is solely composed of white space.
	//if yes returns 1 else returns 0.So that token is not added to the array.

	int i=0;
  40196c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

	while(str[i]!='\0'){
  401973:	eb 32                	jmp    4019a7 <onlyWhiteSpace+0x47>

		if(!((str[i]=='\t') || (str[i]==' '))){
  401975:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401978:	48 63 d0             	movslq %eax,%rdx
  40197b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40197f:	48 01 d0             	add    %rdx,%rax
  401982:	0f b6 00             	movzbl (%rax),%eax
  401985:	3c 09                	cmp    $0x9,%al
  401987:	74 1b                	je     4019a4 <onlyWhiteSpace+0x44>
  401989:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40198c:	48 63 d0             	movslq %eax,%rdx
  40198f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401993:	48 01 d0             	add    %rdx,%rax
  401996:	0f b6 00             	movzbl (%rax),%eax
  401999:	3c 20                	cmp    $0x20,%al
  40199b:	74 07                	je     4019a4 <onlyWhiteSpace+0x44>

			return 0;
  40199d:	b8 00 00 00 00       	mov    $0x0,%eax
  4019a2:	eb 1c                	jmp    4019c0 <onlyWhiteSpace+0x60>
		}
		i++;
  4019a4:	ff 45 fc             	incl   -0x4(%rbp)
	//checks if a token is solely composed of white space.
	//if yes returns 1 else returns 0.So that token is not added to the array.

	int i=0;

	while(str[i]!='\0'){
  4019a7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4019aa:	48 63 d0             	movslq %eax,%rdx
  4019ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4019b1:	48 01 d0             	add    %rdx,%rax
  4019b4:	0f b6 00             	movzbl (%rax),%eax
  4019b7:	84 c0                	test   %al,%al
  4019b9:	75 ba                	jne    401975 <onlyWhiteSpace+0x15>
			return 0;
		}
		i++;
	}

	return 1;
  4019bb:	b8 01 00 00 00       	mov    $0x1,%eax

}
  4019c0:	c9                   	leaveq 
  4019c1:	c3                   	retq   

00000000004019c2 <substring>:


char * substring(char* str, int front, int back){
  4019c2:	55                   	push   %rbp
  4019c3:	48 89 e5             	mov    %rsp,%rbp
  4019c6:	48 81 ec 20 02 00 00 	sub    $0x220,%rsp
  4019cd:	48 89 bd e8 fd ff ff 	mov    %rdi,-0x218(%rbp)
  4019d4:	89 b5 e4 fd ff ff    	mov    %esi,-0x21c(%rbp)
  4019da:	89 95 e0 fd ff ff    	mov    %edx,-0x220(%rbp)

	//temporary buffer to hold the token;
	char n[500];
	char *p;
	int i=0;
  4019e0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

	//Must handle condition of consequtive delims, delim at the end.Not done till now.

	if(back==front){
  4019e7:	8b 85 e0 fd ff ff    	mov    -0x220(%rbp),%eax
  4019ed:	3b 85 e4 fd ff ff    	cmp    -0x21c(%rbp),%eax
  4019f3:	75 0a                	jne    4019ff <substring+0x3d>

		return (char*)NULL;
  4019f5:	b8 00 00 00 00       	mov    $0x0,%eax
  4019fa:	e9 d9 00 00 00       	jmpq   401ad8 <substring+0x116>

	}

	while(back < front){
  4019ff:	eb 31                	jmp    401a32 <substring+0x70>
		n[i++]=str[back++];
  401a01:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401a04:	8d 50 01             	lea    0x1(%rax),%edx
  401a07:	89 55 fc             	mov    %edx,-0x4(%rbp)
  401a0a:	8b 95 e0 fd ff ff    	mov    -0x220(%rbp),%edx
  401a10:	8d 4a 01             	lea    0x1(%rdx),%ecx
  401a13:	89 8d e0 fd ff ff    	mov    %ecx,-0x220(%rbp)
  401a19:	48 63 ca             	movslq %edx,%rcx
  401a1c:	48 8b 95 e8 fd ff ff 	mov    -0x218(%rbp),%rdx
  401a23:	48 01 ca             	add    %rcx,%rdx
  401a26:	0f b6 12             	movzbl (%rdx),%edx
  401a29:	48 98                	cltq   
  401a2b:	88 94 05 fc fd ff ff 	mov    %dl,-0x204(%rbp,%rax,1)

		return (char*)NULL;

	}

	while(back < front){
  401a32:	8b 85 e0 fd ff ff    	mov    -0x220(%rbp),%eax
  401a38:	3b 85 e4 fd ff ff    	cmp    -0x21c(%rbp),%eax
  401a3e:	7c c1                	jl     401a01 <substring+0x3f>
		n[i++]=str[back++];
	}
	n[i] = '\0';
  401a40:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401a43:	48 98                	cltq   
  401a45:	c6 84 05 fc fd ff ff 	movb   $0x0,-0x204(%rbp,%rax,1)
  401a4c:	00 
	printf("nIn substring... %s\n",n);
  401a4d:	48 8d 85 fc fd ff ff 	lea    -0x204(%rbp),%rax
  401a54:	48 89 c6             	mov    %rax,%rsi
  401a57:	48 8d 3d 21 1d 00 00 	lea    0x1d21(%rip),%rdi        # 40377f <chdir+0x427>
  401a5e:	b8 00 00 00 00       	mov    $0x0,%eax
  401a63:	e8 82 08 00 00       	callq  4022ea <printf>

	if(onlyWhiteSpace(n)==0){
  401a68:	48 8d 85 fc fd ff ff 	lea    -0x204(%rbp),%rax
  401a6f:	48 89 c7             	mov    %rax,%rdi
  401a72:	e8 e9 fe ff ff       	callq  401960 <onlyWhiteSpace>
  401a77:	85 c0                	test   %eax,%eax
  401a79:	75 40                	jne    401abb <substring+0xf9>
		p = (char*)malloc(sizeof(char)*(i+1));
  401a7b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401a7e:	ff c0                	inc    %eax
  401a80:	48 98                	cltq   
  401a82:	48 89 c7             	mov    %rax,%rdi
  401a85:	e8 ce 16 00 00       	callq  403158 <malloc>
  401a8a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		strcpy(p,n);
  401a8e:	48 8d 95 fc fd ff ff 	lea    -0x204(%rbp),%rdx
  401a95:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401a99:	48 89 d6             	mov    %rdx,%rsi
  401a9c:	48 89 c7             	mov    %rax,%rdi
  401a9f:	e8 51 0f 00 00       	callq  4029f5 <strcpy>
		printf("After white space p=  ");
  401aa4:	48 8d 3d e9 1c 00 00 	lea    0x1ce9(%rip),%rdi        # 403794 <chdir+0x43c>
  401aab:	b8 00 00 00 00       	mov    $0x0,%eax
  401ab0:	e8 35 08 00 00       	callq  4022ea <printf>
        return p;
  401ab5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401ab9:	eb 1d                	jmp    401ad8 <substring+0x116>
	}
	else
		p = (char*)NULL;
  401abb:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  401ac2:	00 

    printf("Returning %s from substring");
  401ac3:	48 8d 3d e1 1c 00 00 	lea    0x1ce1(%rip),%rdi        # 4037ab <chdir+0x453>
  401aca:	b8 00 00 00 00       	mov    $0x0,%eax
  401acf:	e8 16 08 00 00       	callq  4022ea <printf>
	return p;
  401ad4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax

}
  401ad8:	c9                   	leaveq 
  401ad9:	c3                   	retq   

0000000000401ada <tokenize>:


Token* tokenize(char *str,char* delim){
  401ada:	55                   	push   %rbp
  401adb:	48 89 e5             	mov    %rsp,%rbp
  401ade:	48 83 ec 30          	sub    $0x30,%rsp
  401ae2:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  401ae6:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)

	Token* token=(Token*)malloc(sizeof(Token));
  401aea:	bf 98 01 00 00       	mov    $0x198,%edi
  401aef:	e8 64 16 00 00       	callq  403158 <malloc>
  401af4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//printf("In Tokenize Printing str %s\n",str);
	int tokenCount=0;
  401af8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	int front=0,back=0;
  401aff:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  401b06:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	int i=0;
  401b0d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
	char *p;

	printf("IN TOKENIZER %s %s",str,delim);
  401b14:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  401b18:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401b1c:	48 89 c6             	mov    %rax,%rsi
  401b1f:	48 8d 3d a1 1c 00 00 	lea    0x1ca1(%rip),%rdi        # 4037c7 <chdir+0x46f>
  401b26:	b8 00 00 00 00       	mov    $0x0,%eax
  401b2b:	e8 ba 07 00 00       	callq  4022ea <printf>

	while(str[front]!='\0'){
  401b30:	e9 c0 00 00 00       	jmpq   401bf5 <tokenize+0x11b>

		if(str[front]== *delim){
  401b35:	8b 45 f8             	mov    -0x8(%rbp),%eax
  401b38:	48 63 d0             	movslq %eax,%rdx
  401b3b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401b3f:	48 01 d0             	add    %rdx,%rax
  401b42:	0f b6 10             	movzbl (%rax),%edx
  401b45:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  401b49:	0f b6 00             	movzbl (%rax),%eax
  401b4c:	38 c2                	cmp    %al,%dl
  401b4e:	0f 85 9e 00 00 00    	jne    401bf2 <tokenize+0x118>
			//delimiter found. Extract substring.
			p=substring(str,front,back);
  401b54:	8b 55 f4             	mov    -0xc(%rbp),%edx
  401b57:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  401b5a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401b5e:	89 ce                	mov    %ecx,%esi
  401b60:	48 89 c7             	mov    %rax,%rdi
  401b63:	e8 5a fe ff ff       	callq  4019c2 <substring>
  401b68:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
            printf("Back in token %s %d ",p,p);
  401b6c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  401b70:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  401b74:	48 89 c6             	mov    %rax,%rsi
  401b77:	48 8d 3d 5c 1c 00 00 	lea    0x1c5c(%rip),%rdi        # 4037da <chdir+0x482>
  401b7e:	b8 00 00 00 00       	mov    $0x0,%eax
  401b83:	e8 62 07 00 00       	callq  4022ea <printf>
            
            if(p==NULL)
  401b88:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  401b8d:	75 11                	jne    401ba0 <tokenize+0xc6>
                printf("p is null");
  401b8f:	48 8d 3d 59 1c 00 00 	lea    0x1c59(%rip),%rdi        # 4037ef <chdir+0x497>
  401b96:	b8 00 00 00 00       	mov    $0x0,%eax
  401b9b:	e8 4a 07 00 00       	callq  4022ea <printf>

			if(p != NULL){
  401ba0:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  401ba5:	74 3e                	je     401be5 <tokenize+0x10b>
				token->tokenArr[tokenCount++]=p;
  401ba7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401baa:	8d 50 01             	lea    0x1(%rax),%edx
  401bad:	89 55 fc             	mov    %edx,-0x4(%rbp)
  401bb0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  401bb4:	48 98                	cltq   
  401bb6:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  401bba:	48 89 4c c2 08       	mov    %rcx,0x8(%rdx,%rax,8)
				printf("\nIn tokenizer..appending %s\n",token->tokenArr[tokenCount-1]);
  401bbf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401bc2:	8d 50 ff             	lea    -0x1(%rax),%edx
  401bc5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401bc9:	48 63 d2             	movslq %edx,%rdx
  401bcc:	48 8b 44 d0 08       	mov    0x8(%rax,%rdx,8),%rax
  401bd1:	48 89 c6             	mov    %rax,%rsi
  401bd4:	48 8d 3d 1e 1c 00 00 	lea    0x1c1e(%rip),%rdi        # 4037f9 <chdir+0x4a1>
  401bdb:	b8 00 00 00 00       	mov    $0x0,%eax
  401be0:	e8 05 07 00 00       	callq  4022ea <printf>
			}

			back = front +1;
  401be5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  401be8:	ff c0                	inc    %eax
  401bea:	89 45 f4             	mov    %eax,-0xc(%rbp)
			front++;
  401bed:	ff 45 f8             	incl   -0x8(%rbp)
  401bf0:	eb 03                	jmp    401bf5 <tokenize+0x11b>
			//continue;
		}

		else{
			front++;
  401bf2:	ff 45 f8             	incl   -0x8(%rbp)
	int i=0;
	char *p;

	printf("IN TOKENIZER %s %s",str,delim);

	while(str[front]!='\0'){
  401bf5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  401bf8:	48 63 d0             	movslq %eax,%rdx
  401bfb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401bff:	48 01 d0             	add    %rdx,%rax
  401c02:	0f b6 00             	movzbl (%rax),%eax
  401c05:	84 c0                	test   %al,%al
  401c07:	0f 85 28 ff ff ff    	jne    401b35 <tokenize+0x5b>
		else{
			front++;
		}
	}//end while

	p = substring(str,front,back);
  401c0d:	8b 55 f4             	mov    -0xc(%rbp),%edx
  401c10:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  401c13:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  401c17:	89 ce                	mov    %ecx,%esi
  401c19:	48 89 c7             	mov    %rax,%rdi
  401c1c:	e8 a1 fd ff ff       	callq  4019c2 <substring>
  401c21:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if(p != NULL){
  401c25:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  401c2a:	74 18                	je     401c44 <tokenize+0x16a>
		token->tokenArr[tokenCount++]=p;
  401c2c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401c2f:	8d 50 01             	lea    0x1(%rax),%edx
  401c32:	89 55 fc             	mov    %edx,-0x4(%rbp)
  401c35:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  401c39:	48 98                	cltq   
  401c3b:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  401c3f:	48 89 4c c2 08       	mov    %rcx,0x8(%rdx,%rax,8)
	}
	token->numOfTokens=tokenCount;
  401c44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401c48:	8b 55 fc             	mov    -0x4(%rbp),%edx
  401c4b:	89 10                	mov    %edx,(%rax)


	printf("Before Returning Token\n\n");
  401c4d:	48 8d 3d c2 1b 00 00 	lea    0x1bc2(%rip),%rdi        # 403816 <chdir+0x4be>
  401c54:	b8 00 00 00 00       	mov    $0x0,%eax
  401c59:	e8 8c 06 00 00       	callq  4022ea <printf>

	for(i=0;i<token->numOfTokens;i++){
  401c5e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  401c65:	eb 2e                	jmp    401c95 <tokenize+0x1bb>

		printf("Token %d : %s %d\n",i,token->tokenArr[i],token->numOfTokens);
  401c67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401c6b:	8b 08                	mov    (%rax),%ecx
  401c6d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401c71:	8b 55 f0             	mov    -0x10(%rbp),%edx
  401c74:	48 63 d2             	movslq %edx,%rdx
  401c77:	48 8b 54 d0 08       	mov    0x8(%rax,%rdx,8),%rdx
  401c7c:	8b 45 f0             	mov    -0x10(%rbp),%eax
  401c7f:	89 c6                	mov    %eax,%esi
  401c81:	48 8d 3d a7 1b 00 00 	lea    0x1ba7(%rip),%rdi        # 40382f <chdir+0x4d7>
  401c88:	b8 00 00 00 00       	mov    $0x0,%eax
  401c8d:	e8 58 06 00 00       	callq  4022ea <printf>
	token->numOfTokens=tokenCount;


	printf("Before Returning Token\n\n");

	for(i=0;i<token->numOfTokens;i++){
  401c92:	ff 45 f0             	incl   -0x10(%rbp)
  401c95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401c99:	8b 00                	mov    (%rax),%eax
  401c9b:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  401c9e:	7f c7                	jg     401c67 <tokenize+0x18d>

		printf("Token %d : %s %d\n",i,token->tokenArr[i],token->numOfTokens);
	}


	return token;
  401ca0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax

}
  401ca4:	c9                   	leaveq 
  401ca5:	c3                   	retq   

0000000000401ca6 <main2>:
#include<stdlib.h>
#include<stdio.h>
int main2 (int argc, char *argv[], char* envp[])
{
  401ca6:	55                   	push   %rbp
  401ca7:	48 89 e5             	mov    %rsp,%rbp
  401caa:	48 83 ec 30          	sub    $0x30,%rsp
  401cae:	89 7d ec             	mov    %edi,-0x14(%rbp)
  401cb1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  401cb5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
char* s=(char*)malloc(10);
  401cb9:	bf 0a 00 00 00       	mov    $0xa,%edi
  401cbe:	e8 95 14 00 00       	callq  403158 <malloc>
  401cc3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

printf("s=%d",s);
  401cc7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  401ccb:	48 89 c6             	mov    %rax,%rsi
  401cce:	48 8d 3d 6c 1b 00 00 	lea    0x1b6c(%rip),%rdi        # 403841 <chdir+0x4e9>
  401cd5:	b8 00 00 00 00       	mov    $0x0,%eax
  401cda:	e8 0b 06 00 00       	callq  4022ea <printf>
return 0;
  401cdf:	b8 00 00 00 00       	mov    $0x0,%eax
}
  401ce4:	c9                   	leaveq 
  401ce5:	c3                   	retq   

0000000000401ce6 <test>:
#include <stdlib.h>
#include <string.h>


	
uint64_t test(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3){
  401ce6:	55                   	push   %rbp
  401ce7:	48 89 e5             	mov    %rsp,%rbp
  401cea:	48 83 ec 30          	sub    $0x30,%rsp
  401cee:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401cf2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  401cf6:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  401cfa:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)

	//printf("Inside test\n");


	uint64_t ret;
	__asm__("movq %1,%%rax;"
  401cfe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401d02:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401d06:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  401d0a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  401d0e:	cd 80                	int    $0x80
  401d10:	48 89 c0             	mov    %rax,%rax
  401d13:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %3,%%rsi;"
			"movq %4, %%rdx;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2),"m"(a3));
	return ret;
  401d17:	48 8b 45 f8          	mov    -0x8(%rbp),%rax


}
  401d1b:	c9                   	leaveq 
  401d1c:	c3                   	retq   

0000000000401d1d <readdir>:




struct dirent* readdir(void *dir){
  401d1d:	55                   	push   %rbp
  401d1e:	48 89 e5             	mov    %rsp,%rbp
  401d21:	48 81 ec 20 04 00 00 	sub    $0x420,%rsp
  401d28:	48 89 bd e8 fb ff ff 	mov    %rdi,-0x418(%rbp)

	char buff[1024];

	if((uint64_t)dir == -1){
  401d2f:	48 8b 85 e8 fb ff ff 	mov    -0x418(%rbp),%rax
  401d36:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  401d3a:	75 18                	jne    401d54 <readdir+0x37>

		printf("Bad directory stream\n");
  401d3c:	48 8d 3d 05 1b 00 00 	lea    0x1b05(%rip),%rdi        # 403848 <chdir+0x4f0>
  401d43:	b8 00 00 00 00       	mov    $0x0,%eax
  401d48:	e8 9d 05 00 00       	callq  4022ea <printf>
		return NULL;
  401d4d:	b8 00 00 00 00       	mov    $0x0,%eax
  401d52:	eb 6a                	jmp    401dbe <readdir+0xa1>
	}


	int ret = test(78,(uint64_t)dir,(uint64_t)buff,(uint64_t)1024);
  401d54:	48 8d 95 f0 fb ff ff 	lea    -0x410(%rbp),%rdx
  401d5b:	48 8b 85 e8 fb ff ff 	mov    -0x418(%rbp),%rax
  401d62:	b9 00 04 00 00       	mov    $0x400,%ecx
  401d67:	48 89 c6             	mov    %rax,%rsi
  401d6a:	bf 4e 00 00 00       	mov    $0x4e,%edi
  401d6f:	e8 72 ff ff ff       	callq  401ce6 <test>
  401d74:	89 45 fc             	mov    %eax,-0x4(%rbp)

	//printf("Ret value %d\n", ret );

	if(ret == -1){
  401d77:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  401d7b:	75 18                	jne    401d95 <readdir+0x78>

		//Error
		printf("Error while reading directory\n");
  401d7d:	48 8d 3d dc 1a 00 00 	lea    0x1adc(%rip),%rdi        # 403860 <chdir+0x508>
  401d84:	b8 00 00 00 00       	mov    $0x0,%eax
  401d89:	e8 5c 05 00 00       	callq  4022ea <printf>
		return NULL;
  401d8e:	b8 00 00 00 00       	mov    $0x0,%eax
  401d93:	eb 29                	jmp    401dbe <readdir+0xa1>

	}

	else if (ret == 0){
  401d95:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  401d99:	75 07                	jne    401da2 <readdir+0x85>

		//End of directory stream
		return NULL;
  401d9b:	b8 00 00 00 00       	mov    $0x0,%eax
  401da0:	eb 1c                	jmp    401dbe <readdir+0xa1>

	}

	else if(ret !=0){
  401da2:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  401da6:	74 11                	je     401db9 <readdir+0x9c>

		//There is a valid child
		//printf("Ret of readdir is not 0\n");
		struct dirent* x = (struct dirent*)buff;
  401da8:	48 8d 85 f0 fb ff ff 	lea    -0x410(%rbp),%rax
  401daf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		//printf("Name of entry dir%s\n",x->d_name );
		return x;
  401db3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  401db7:	eb 05                	jmp    401dbe <readdir+0xa1>
	}


	return NULL;
  401db9:	b8 00 00 00 00       	mov    $0x0,%eax

}
  401dbe:	c9                   	leaveq 
  401dbf:	c3                   	retq   

0000000000401dc0 <syscall_2>:
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
}

static __inline uint64_t syscall_2(uint64_t n, uint64_t a1, uint64_t a2) {
  401dc0:	55                   	push   %rbp
  401dc1:	48 89 e5             	mov    %rsp,%rbp
  401dc4:	48 83 ec 28          	sub    $0x28,%rsp
  401dc8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401dcc:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  401dd0:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	uint64_t ret;
	__asm__("movq %1,%%rax;"
  401dd4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401dd8:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401ddc:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  401de0:	cd 80                	int    $0x80
  401de2:	48 89 c0             	mov    %rax,%rax
  401de5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %2,%%rdi;"
			"movq %3,%%rsi;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
  401de9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401ded:	c9                   	leaveq 
  401dee:	c3                   	retq   

0000000000401def <dup2>:
#include<sys/syscall.h>
#include<syscall.h>
#include<stdlib.h>

int dup2(int oldfd, int newfd)
{
  401def:	55                   	push   %rbp
  401df0:	48 89 e5             	mov    %rsp,%rbp
  401df3:	48 83 ec 18          	sub    $0x18,%rsp
  401df7:	89 7d ec             	mov    %edi,-0x14(%rbp)
  401dfa:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int retvalue;
	retvalue = syscall_2(SYS_dup2, oldfd, newfd);
  401dfd:	8b 45 e8             	mov    -0x18(%rbp),%eax
  401e00:	48 63 d0             	movslq %eax,%rdx
  401e03:	8b 45 ec             	mov    -0x14(%rbp),%eax
  401e06:	48 98                	cltq   
  401e08:	48 89 c6             	mov    %rax,%rsi
  401e0b:	bf 21 00 00 00       	mov    $0x21,%edi
  401e10:	e8 ab ff ff ff       	callq  401dc0 <syscall_2>
  401e15:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(retvalue >=0){
  401e18:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  401e1c:	78 05                	js     401e23 <dup2+0x34>
		return retvalue;
  401e1e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401e21:	eb 05                	jmp    401e28 <dup2+0x39>
	}
	return -1;
  401e23:	b8 ff ff ff ff       	mov    $0xffffffff,%eax


}
  401e28:	c9                   	leaveq 
  401e29:	c3                   	retq   

0000000000401e2a <syscall_2>:
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
}

static __inline uint64_t syscall_2(uint64_t n, uint64_t a1, uint64_t a2) {
  401e2a:	55                   	push   %rbp
  401e2b:	48 89 e5             	mov    %rsp,%rbp
  401e2e:	48 83 ec 28          	sub    $0x28,%rsp
  401e32:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401e36:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  401e3a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	uint64_t ret;
	__asm__("movq %1,%%rax;"
  401e3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401e42:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401e46:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  401e4a:	cd 80                	int    $0x80
  401e4c:	48 89 c0             	mov    %rax,%rax
  401e4f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %2,%%rdi;"
			"movq %3,%%rsi;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
  401e53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401e57:	c9                   	leaveq 
  401e58:	c3                   	retq   

0000000000401e59 <open>:
#include <errno.h>

//int errno = 0;

int open(const char *pathname, int flags)
{
  401e59:	55                   	push   %rbp
  401e5a:	48 89 e5             	mov    %rsp,%rbp
  401e5d:	48 83 ec 20          	sub    $0x20,%rsp
  401e61:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401e65:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int retvalue;
	retvalue = syscall_2(SYS_open, (uint64_t)pathname, (uint64_t)flags);
  401e68:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  401e6b:	48 63 d0             	movslq %eax,%rdx
  401e6e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401e72:	48 89 c6             	mov    %rax,%rsi
  401e75:	bf 02 00 00 00       	mov    $0x2,%edi
  401e7a:	e8 ab ff ff ff       	callq  401e2a <syscall_2>
  401e7f:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(retvalue >=0){
  401e82:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  401e86:	78 05                	js     401e8d <open+0x34>
		return retvalue;
  401e88:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401e8b:	eb 05                	jmp    401e92 <open+0x39>
	}

	return -1;
  401e8d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
  401e92:	c9                   	leaveq 
  401e93:	c3                   	retq   

0000000000401e94 <syscall_2>:
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
}

static __inline uint64_t syscall_2(uint64_t n, uint64_t a1, uint64_t a2) {
  401e94:	55                   	push   %rbp
  401e95:	48 89 e5             	mov    %rsp,%rbp
  401e98:	48 83 ec 28          	sub    $0x28,%rsp
  401e9c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401ea0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  401ea4:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	uint64_t ret;
	__asm__("movq %1,%%rax;"
  401ea8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401eac:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401eb0:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  401eb4:	cd 80                	int    $0x80
  401eb6:	48 89 c0             	mov    %rax,%rax
  401eb9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %2,%%rdi;"
			"movq %3,%%rsi;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
  401ebd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401ec1:	c9                   	leaveq 
  401ec2:	c3                   	retq   

0000000000401ec3 <getcwd>:
#include <stdlib.h>
#include <errno.h>

//int errno=0; //Only define here. declaration seeps through to the files via stdlib.h

char* getcwd(char *buf, size_t size){
  401ec3:	55                   	push   %rbp
  401ec4:	48 89 e5             	mov    %rsp,%rbp
  401ec7:	48 83 ec 20          	sub    $0x20,%rsp
  401ecb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401ecf:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int retvalue;
	retvalue=syscall_2(SYS_getcwd,(uint64_t)buf,(uint64_t)size);
  401ed3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401ed7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  401edb:	48 89 c6             	mov    %rax,%rsi
  401ede:	bf 4f 00 00 00       	mov    $0x4f,%edi
  401ee3:	e8 ac ff ff ff       	callq  401e94 <syscall_2>
  401ee8:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(retvalue >=0){
  401eeb:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  401eef:	78 06                	js     401ef7 <getcwd+0x34>
		return buf;
  401ef1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401ef5:	eb 05                	jmp    401efc <getcwd+0x39>
	}
	return NULL;
  401ef7:	b8 00 00 00 00       	mov    $0x0,%eax

}
  401efc:	c9                   	leaveq 
  401efd:	c3                   	retq   

0000000000401efe <syscall_1>:
			:"=r"(ret):"m"(n));

	return ret;
}

static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
  401efe:	55                   	push   %rbp
  401eff:	48 89 e5             	mov    %rsp,%rbp
  401f02:	48 83 ec 20          	sub    $0x20,%rsp
  401f06:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401f0a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int64_t ret;

	__asm__("movq $78,%r15");
  401f0e:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
	//__asm__("movq %0,%%rax;"
	//		::"m"(n));

	//while(1);

	if(n==60){
  401f15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401f19:	48 83 f8 3c          	cmp    $0x3c,%rax
  401f1d:	75 0c                	jne    401f2b <syscall_1+0x2d>
		__asm__("movq %0,%%rax;"
  401f1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401f23:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401f27:	cd 80                	int    $0x80
  401f29:	eb 11                	jmp    401f3c <syscall_1+0x3e>

		//while(1);
	}
	else{

		__asm__("movq %1,%%rax;"
  401f2b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401f2f:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401f33:	cd 80                	int    $0x80
  401f35:	48 89 c0             	mov    %rax,%rax
  401f38:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				"movq %2,%%rdi;"
				"int $0x80;"
				"movq %%rax,%0;"
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
  401f3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401f40:	c9                   	leaveq 
  401f41:	c3                   	retq   

0000000000401f42 <close>:
#include<sys/syscall.h>
#include<syscall.h>
#include <stdlib.h>

int close(int fd)
{
  401f42:	55                   	push   %rbp
  401f43:	48 89 e5             	mov    %rsp,%rbp
  401f46:	48 83 ec 18          	sub    $0x18,%rsp
  401f4a:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int retvalue;
	retvalue = syscall_1(SYS_close, fd);
  401f4d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  401f50:	48 98                	cltq   
  401f52:	48 89 c6             	mov    %rax,%rsi
  401f55:	bf 03 00 00 00       	mov    $0x3,%edi
  401f5a:	e8 9f ff ff ff       	callq  401efe <syscall_1>
  401f5f:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(retvalue >=0){
  401f62:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  401f66:	78 05                	js     401f6d <close+0x2b>
		return retvalue;
  401f68:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401f6b:	eb 05                	jmp    401f72 <close+0x30>
	}
	return -1;
  401f6d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
  401f72:	c9                   	leaveq 
  401f73:	c3                   	retq   

0000000000401f74 <syscall_0>:
#define _SYSCALL_H

#include <sys/defs.h>
#include <sys/syscall.h>

static __inline uint64_t syscall_0(uint64_t n) {
  401f74:	55                   	push   %rbp
  401f75:	48 89 e5             	mov    %rsp,%rbp
  401f78:	48 83 ec 18          	sub    $0x18,%rsp
  401f7c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	uint64_t ret;
	__asm__("movq %1,%%rax;"
  401f80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401f84:	cd 80                	int    $0x80
  401f86:	48 89 c0             	mov    %rax,%rax
  401f89:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n));

	return ret;
  401f8d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401f91:	c9                   	leaveq 
  401f92:	c3                   	retq   

0000000000401f93 <syscall_3>:
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
}

static __inline uint64_t syscall_3(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3) {
  401f93:	55                   	push   %rbp
  401f94:	48 89 e5             	mov    %rsp,%rbp
  401f97:	48 83 ec 30          	sub    $0x30,%rsp
  401f9b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  401f9f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  401fa3:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  401fa7:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)

	uint64_t ret;
    
	__asm__("movq %1,%%rax;"
  401fab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  401faf:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  401fb3:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  401fb7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  401fbb:	cd 80                	int    $0x80
  401fbd:	48 89 c0             	mov    %rax,%rax
  401fc0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %3, %%rsi;"
			"movq %4, %%rdx;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2),"m"(a3));
	return ret;
  401fc4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  401fc8:	c9                   	leaveq 
  401fc9:	c3                   	retq   

0000000000401fca <getpid>:
#include <sys/defs.h>
#include <stdlib.h>
#include <sys/syscall.h>

pid_t getpid()
{
  401fca:	55                   	push   %rbp
  401fcb:	48 89 e5             	mov    %rsp,%rbp
  401fce:	48 83 ec 10          	sub    $0x10,%rsp
	int retvalue;
	retvalue = syscall_0(SYS_getpid);
  401fd2:	bf 27 00 00 00       	mov    $0x27,%edi
  401fd7:	e8 98 ff ff ff       	callq  401f74 <syscall_0>
  401fdc:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(retvalue >=0){
  401fdf:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  401fe3:	78 05                	js     401fea <getpid+0x20>
		return retvalue;
  401fe5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  401fe8:	eb 05                	jmp    401fef <getpid+0x25>
	}
	return -1;
  401fea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax


}
  401fef:	c9                   	leaveq 
  401ff0:	c3                   	retq   

0000000000401ff1 <getppid>:

pid_t getppid()
{
  401ff1:	55                   	push   %rbp
  401ff2:	48 89 e5             	mov    %rsp,%rbp
  401ff5:	48 83 ec 10          	sub    $0x10,%rsp
	int retvalue;
	retvalue = syscall_0(SYS_getppid);
  401ff9:	bf 6e 00 00 00       	mov    $0x6e,%edi
  401ffe:	e8 71 ff ff ff       	callq  401f74 <syscall_0>
  402003:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(retvalue >=0){
  402006:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  40200a:	78 05                	js     402011 <getppid+0x20>
		return retvalue;
  40200c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40200f:	eb 05                	jmp    402016 <getppid+0x25>
	}

	return -1;
  402011:	b8 ff ff ff ff       	mov    $0xffffffff,%eax


}
  402016:	c9                   	leaveq 
  402017:	c3                   	retq   

0000000000402018 <waitpid>:

pid_t waitpid(pid_t pid, int *status, int options)
{
  402018:	55                   	push   %rbp
  402019:	48 89 e5             	mov    %rsp,%rbp
  40201c:	48 83 ec 20          	sub    $0x20,%rsp
  402020:	89 7d ec             	mov    %edi,-0x14(%rbp)
  402023:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  402027:	89 55 e8             	mov    %edx,-0x18(%rbp)
	pid_t retvalue;
	retvalue = syscall_3(SYS_wait4,(uint64_t)pid,(uint64_t)status,(uint64_t)options);
  40202a:	8b 45 e8             	mov    -0x18(%rbp),%eax
  40202d:	48 63 c8             	movslq %eax,%rcx
  402030:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  402034:	8b 45 ec             	mov    -0x14(%rbp),%eax
  402037:	48 89 c6             	mov    %rax,%rsi
  40203a:	bf 3d 00 00 00       	mov    $0x3d,%edi
  40203f:	e8 4f ff ff ff       	callq  401f93 <syscall_3>
  402044:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(retvalue >=0){
		return retvalue;
  402047:	8b 45 fc             	mov    -0x4(%rbp),%eax
	}

	return -1;

}
  40204a:	c9                   	leaveq 
  40204b:	c3                   	retq   

000000000040204c <syscall_1>:
			:"=r"(ret):"m"(n));

	return ret;
}

static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
  40204c:	55                   	push   %rbp
  40204d:	48 89 e5             	mov    %rsp,%rbp
  402050:	48 83 ec 20          	sub    $0x20,%rsp
  402054:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402058:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int64_t ret;

	__asm__("movq $78,%r15");
  40205c:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
	//__asm__("movq %0,%%rax;"
	//		::"m"(n));

	//while(1);

	if(n==60){
  402063:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402067:	48 83 f8 3c          	cmp    $0x3c,%rax
  40206b:	75 0c                	jne    402079 <syscall_1+0x2d>
		__asm__("movq %0,%%rax;"
  40206d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402071:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402075:	cd 80                	int    $0x80
  402077:	eb 11                	jmp    40208a <syscall_1+0x3e>

		//while(1);
	}
	else{

		__asm__("movq %1,%%rax;"
  402079:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40207d:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402081:	cd 80                	int    $0x80
  402083:	48 89 c0             	mov    %rax,%rax
  402086:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				"movq %2,%%rdi;"
				"int $0x80;"
				"movq %%rax,%0;"
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
  40208a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  40208e:	c9                   	leaveq 
  40208f:	c3                   	retq   

0000000000402090 <closedir>:
#include<sys/defs.h>
#include<stdlib.h>
#include<errno.h>


int closedir(void *dir){
  402090:	55                   	push   %rbp
  402091:	48 89 e5             	mov    %rsp,%rbp
  402094:	48 83 ec 20          	sub    $0x20,%rsp
  402098:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)


	if((uint64_t)dir == -1){
  40209c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4020a0:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  4020a4:	75 18                	jne    4020be <closedir+0x2e>

		printf("Cannot close bad directory stream\n");
  4020a6:	48 8d 3d d3 17 00 00 	lea    0x17d3(%rip),%rdi        # 403880 <chdir+0x528>
  4020ad:	b8 00 00 00 00       	mov    $0x0,%eax
  4020b2:	e8 33 02 00 00       	callq  4022ea <printf>
		return -1;
  4020b7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4020bc:	eb 2c                	jmp    4020ea <closedir+0x5a>
	}
	int fd = (uint64_t)dir;
  4020be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4020c2:	89 45 fc             	mov    %eax,-0x4(%rbp)

	int retvalue;
	retvalue = syscall_1(SYS_close,(uint64_t)fd);
  4020c5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4020c8:	48 98                	cltq   
  4020ca:	48 89 c6             	mov    %rax,%rsi
  4020cd:	bf 03 00 00 00       	mov    $0x3,%edi
  4020d2:	e8 75 ff ff ff       	callq  40204c <syscall_1>
  4020d7:	89 45 f8             	mov    %eax,-0x8(%rbp)

	//printf("closedir syscall returned %d\n",retvalue );

	if(retvalue<0){
  4020da:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  4020de:	79 07                	jns    4020e7 <closedir+0x57>
		
		return -1;
  4020e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  4020e5:	eb 03                	jmp    4020ea <closedir+0x5a>

	}
	return retvalue;
  4020e7:	8b 45 f8             	mov    -0x8(%rbp),%eax


}
  4020ea:	c9                   	leaveq 
  4020eb:	c3                   	retq   

00000000004020ec <print_num>:

// update errno.
char screen[1024];
int screen_ctr;
void print_num(int num, int base)
{
  4020ec:	55                   	push   %rbp
  4020ed:	48 89 e5             	mov    %rsp,%rbp
  4020f0:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  4020f7:	89 bd 6c ff ff ff    	mov    %edi,-0x94(%rbp)
  4020fd:	89 b5 68 ff ff ff    	mov    %esi,-0x98(%rbp)
	int number[32];
	int i=0;
  402103:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

	if(base == 16)
  40210a:	83 bd 68 ff ff ff 10 	cmpl   $0x10,-0x98(%rbp)
  402111:	75 44                	jne    402157 <print_num+0x6b>
	{
		screen[screen_ctr++] = '0';
  402113:	48 8b 05 56 24 20 00 	mov    0x202456(%rip),%rax        # 604570 <chdir+0x201218>
  40211a:	8b 00                	mov    (%rax),%eax
  40211c:	8d 48 01             	lea    0x1(%rax),%ecx
  40211f:	48 8b 15 4a 24 20 00 	mov    0x20244a(%rip),%rdx        # 604570 <chdir+0x201218>
  402126:	89 0a                	mov    %ecx,(%rdx)
  402128:	48 8b 15 49 24 20 00 	mov    0x202449(%rip),%rdx        # 604578 <chdir+0x201220>
  40212f:	48 98                	cltq   
  402131:	c6 04 02 30          	movb   $0x30,(%rdx,%rax,1)
		screen[screen_ctr++] = 'x';
  402135:	48 8b 05 34 24 20 00 	mov    0x202434(%rip),%rax        # 604570 <chdir+0x201218>
  40213c:	8b 00                	mov    (%rax),%eax
  40213e:	8d 48 01             	lea    0x1(%rax),%ecx
  402141:	48 8b 15 28 24 20 00 	mov    0x202428(%rip),%rdx        # 604570 <chdir+0x201218>
  402148:	89 0a                	mov    %ecx,(%rdx)
  40214a:	48 8b 15 27 24 20 00 	mov    0x202427(%rip),%rdx        # 604578 <chdir+0x201220>
  402151:	48 98                	cltq   
  402153:	c6 04 02 78          	movb   $0x78,(%rdx,%rax,1)
	}
	do
	{
		int rem=num%base;
  402157:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
  40215d:	99                   	cltd   
  40215e:	f7 bd 68 ff ff ff    	idivl  -0x98(%rbp)
  402164:	89 55 f8             	mov    %edx,-0x8(%rbp)
		if((rem) >= 10)
  402167:	83 7d f8 09          	cmpl   $0x9,-0x8(%rbp)
  40216b:	7e 06                	jle    402173 <print_num+0x87>
		{

			rem = rem-10 + 'a';
  40216d:	83 45 f8 57          	addl   $0x57,-0x8(%rbp)
  402171:	eb 04                	jmp    402177 <print_num+0x8b>
		}
		else{
			rem = rem + '0';
  402173:	83 45 f8 30          	addl   $0x30,-0x8(%rbp)
		}
		number[i]= rem;
  402177:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40217a:	48 98                	cltq   
  40217c:	8b 55 f8             	mov    -0x8(%rbp),%edx
  40217f:	89 94 85 78 ff ff ff 	mov    %edx,-0x88(%rbp,%rax,4)
		i++;
  402186:	ff 45 fc             	incl   -0x4(%rbp)
	}while((num=num/base) !=0);
  402189:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
  40218f:	99                   	cltd   
  402190:	f7 bd 68 ff ff ff    	idivl  -0x98(%rbp)
  402196:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
  40219c:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%rbp)
  4021a3:	75 b2                	jne    402157 <print_num+0x6b>


	while(i-- != 0)
  4021a5:	eb 2e                	jmp    4021d5 <print_num+0xe9>
	{

		screen[screen_ctr++] = number[i];
  4021a7:	48 8b 05 c2 23 20 00 	mov    0x2023c2(%rip),%rax        # 604570 <chdir+0x201218>
  4021ae:	8b 00                	mov    (%rax),%eax
  4021b0:	8d 48 01             	lea    0x1(%rax),%ecx
  4021b3:	48 8b 15 b6 23 20 00 	mov    0x2023b6(%rip),%rdx        # 604570 <chdir+0x201218>
  4021ba:	89 0a                	mov    %ecx,(%rdx)
  4021bc:	8b 55 fc             	mov    -0x4(%rbp),%edx
  4021bf:	48 63 d2             	movslq %edx,%rdx
  4021c2:	8b 94 95 78 ff ff ff 	mov    -0x88(%rbp,%rdx,4),%edx
  4021c9:	48 8b 0d a8 23 20 00 	mov    0x2023a8(%rip),%rcx        # 604578 <chdir+0x201220>
  4021d0:	48 98                	cltq   
  4021d2:	88 14 01             	mov    %dl,(%rcx,%rax,1)
		number[i]= rem;
		i++;
	}while((num=num/base) !=0);


	while(i-- != 0)
  4021d5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4021d8:	8d 50 ff             	lea    -0x1(%rax),%edx
  4021db:	89 55 fc             	mov    %edx,-0x4(%rbp)
  4021de:	85 c0                	test   %eax,%eax
  4021e0:	75 c5                	jne    4021a7 <print_num+0xbb>
	{

		screen[screen_ctr++] = number[i];
	}
}
  4021e2:	c9                   	leaveq 
  4021e3:	c3                   	retq   

00000000004021e4 <print_ptr>:



void print_ptr(long unsigned int num, long unsigned int base)
{
  4021e4:	55                   	push   %rbp
  4021e5:	48 89 e5             	mov    %rsp,%rbp
  4021e8:	48 81 ec 20 01 00 00 	sub    $0x120,%rsp
  4021ef:	48 89 bd e8 fe ff ff 	mov    %rdi,-0x118(%rbp)
  4021f6:	48 89 b5 e0 fe ff ff 	mov    %rsi,-0x120(%rbp)
	long unsigned int number[32];
	int i=0;
  4021fd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

		screen[screen_ctr++] = '0';
  402204:	48 8b 05 65 23 20 00 	mov    0x202365(%rip),%rax        # 604570 <chdir+0x201218>
  40220b:	8b 00                	mov    (%rax),%eax
  40220d:	8d 48 01             	lea    0x1(%rax),%ecx
  402210:	48 8b 15 59 23 20 00 	mov    0x202359(%rip),%rdx        # 604570 <chdir+0x201218>
  402217:	89 0a                	mov    %ecx,(%rdx)
  402219:	48 8b 15 58 23 20 00 	mov    0x202358(%rip),%rdx        # 604578 <chdir+0x201220>
  402220:	48 98                	cltq   
  402222:	c6 04 02 30          	movb   $0x30,(%rdx,%rax,1)
		screen[screen_ctr++] = 'x';
  402226:	48 8b 05 43 23 20 00 	mov    0x202343(%rip),%rax        # 604570 <chdir+0x201218>
  40222d:	8b 00                	mov    (%rax),%eax
  40222f:	8d 48 01             	lea    0x1(%rax),%ecx
  402232:	48 8b 15 37 23 20 00 	mov    0x202337(%rip),%rdx        # 604570 <chdir+0x201218>
  402239:	89 0a                	mov    %ecx,(%rdx)
  40223b:	48 8b 15 36 23 20 00 	mov    0x202336(%rip),%rdx        # 604578 <chdir+0x201220>
  402242:	48 98                	cltq   
  402244:	c6 04 02 78          	movb   $0x78,(%rdx,%rax,1)
	
	do
	{
		long unsigned int rem=num%base;
  402248:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  40224f:	ba 00 00 00 00       	mov    $0x0,%edx
  402254:	48 f7 b5 e0 fe ff ff 	divq   -0x120(%rbp)
  40225b:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
		if((rem) >= 10)
  40225f:	48 83 7d f0 09       	cmpq   $0x9,-0x10(%rbp)
  402264:	76 07                	jbe    40226d <print_ptr+0x89>
		{
			rem = rem-10 + 'a';
  402266:	48 83 45 f0 57       	addq   $0x57,-0x10(%rbp)
  40226b:	eb 05                	jmp    402272 <print_ptr+0x8e>
		}
		else{
			rem = rem + '0';
  40226d:	48 83 45 f0 30       	addq   $0x30,-0x10(%rbp)
		}
		number[i]= rem;
  402272:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402275:	48 98                	cltq   
  402277:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  40227b:	48 89 94 c5 f0 fe ff 	mov    %rdx,-0x110(%rbp,%rax,8)
  402282:	ff 
		i++;
  402283:	ff 45 fc             	incl   -0x4(%rbp)
	}while((num=num/base) !=0);
  402286:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  40228d:	ba 00 00 00 00       	mov    $0x0,%edx
  402292:	48 f7 b5 e0 fe ff ff 	divq   -0x120(%rbp)
  402299:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
  4022a0:	48 83 bd e8 fe ff ff 	cmpq   $0x0,-0x118(%rbp)
  4022a7:	00 
  4022a8:	75 9e                	jne    402248 <print_ptr+0x64>


	while(i-- != 0)
  4022aa:	eb 2f                	jmp    4022db <print_ptr+0xf7>
	{

		screen[screen_ctr++] = number[i];
  4022ac:	48 8b 05 bd 22 20 00 	mov    0x2022bd(%rip),%rax        # 604570 <chdir+0x201218>
  4022b3:	8b 00                	mov    (%rax),%eax
  4022b5:	8d 48 01             	lea    0x1(%rax),%ecx
  4022b8:	48 8b 15 b1 22 20 00 	mov    0x2022b1(%rip),%rdx        # 604570 <chdir+0x201218>
  4022bf:	89 0a                	mov    %ecx,(%rdx)
  4022c1:	8b 55 fc             	mov    -0x4(%rbp),%edx
  4022c4:	48 63 d2             	movslq %edx,%rdx
  4022c7:	48 8b 94 d5 f0 fe ff 	mov    -0x110(%rbp,%rdx,8),%rdx
  4022ce:	ff 
  4022cf:	48 8b 0d a2 22 20 00 	mov    0x2022a2(%rip),%rcx        # 604578 <chdir+0x201220>
  4022d6:	48 98                	cltq   
  4022d8:	88 14 01             	mov    %dl,(%rcx,%rax,1)
		number[i]= rem;
		i++;
	}while((num=num/base) !=0);


	while(i-- != 0)
  4022db:	8b 45 fc             	mov    -0x4(%rbp),%eax
  4022de:	8d 50 ff             	lea    -0x1(%rax),%edx
  4022e1:	89 55 fc             	mov    %edx,-0x4(%rbp)
  4022e4:	85 c0                	test   %eax,%eax
  4022e6:	75 c4                	jne    4022ac <print_ptr+0xc8>
	{

		screen[screen_ctr++] = number[i];
    }
}
  4022e8:	c9                   	leaveq 
  4022e9:	c3                   	retq   

00000000004022ea <printf>:





int printf(const char *format, ...) {
  4022ea:	55                   	push   %rbp
  4022eb:	48 89 e5             	mov    %rsp,%rbp
  4022ee:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  4022f5:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  4022f9:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  4022fd:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  402301:	4c 89 45 f0          	mov    %r8,-0x10(%rbp)
  402305:	4c 89 4d f8          	mov    %r9,-0x8(%rbp)
  402309:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
	va_list val;
	int printed = 0;
  402310:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%rbp)
	screen_ctr=0;
  402317:	48 8b 05 52 22 20 00 	mov    0x202252(%rip),%rax        # 604570 <chdir+0x201218>
  40231e:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	va_start(val, format);
  402324:	c7 45 88 08 00 00 00 	movl   $0x8,-0x78(%rbp)
  40232b:	48 8d 45 10          	lea    0x10(%rbp),%rax
  40232f:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  402333:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  402337:	48 89 45 98          	mov    %rax,-0x68(%rbp)

	while(*format)
  40233b:	e9 0d 03 00 00       	jmpq   40264d <printf+0x363>
	{
		if(*format == '%')
  402340:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  402347:	0f b6 00             	movzbl (%rax),%eax
  40234a:	3c 25                	cmp    $0x25,%al
  40234c:	0f 85 c6 02 00 00    	jne    402618 <printf+0x32e>
		{
			switch(*(++format))
  402352:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
  402359:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  402360:	0f b6 00             	movzbl (%rax),%eax
  402363:	0f be c0             	movsbl %al,%eax
  402366:	83 f8 64             	cmp    $0x64,%eax
  402369:	74 3c                	je     4023a7 <printf+0xbd>
  40236b:	83 f8 64             	cmp    $0x64,%eax
  40236e:	7f 17                	jg     402387 <printf+0x9d>
  402370:	83 f8 25             	cmp    $0x25,%eax
  402373:	0f 84 73 02 00 00    	je     4025ec <printf+0x302>
  402379:	83 f8 63             	cmp    $0x63,%eax
  40237c:	0f 84 ae 00 00 00    	je     402430 <printf+0x146>
  402382:	e9 c6 02 00 00       	jmpq   40264d <printf+0x363>
  402387:	83 f8 73             	cmp    $0x73,%eax
  40238a:	0f 84 03 01 00 00    	je     402493 <printf+0x1a9>
  402390:	83 f8 78             	cmp    $0x78,%eax
  402393:	0f 84 7b 01 00 00    	je     402514 <printf+0x22a>
  402399:	83 f8 70             	cmp    $0x70,%eax
  40239c:	0f 84 fb 01 00 00    	je     40259d <printf+0x2b3>
  4023a2:	e9 a6 02 00 00       	jmpq   40264d <printf+0x363>
			{
			case 'd':
				printed=printed;
				int num = va_arg(val, int);
  4023a7:	8b 45 88             	mov    -0x78(%rbp),%eax
  4023aa:	83 f8 30             	cmp    $0x30,%eax
  4023ad:	73 17                	jae    4023c6 <printf+0xdc>
  4023af:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  4023b3:	8b 45 88             	mov    -0x78(%rbp),%eax
  4023b6:	89 c0                	mov    %eax,%eax
  4023b8:	48 01 d0             	add    %rdx,%rax
  4023bb:	8b 55 88             	mov    -0x78(%rbp),%edx
  4023be:	83 c2 08             	add    $0x8,%edx
  4023c1:	89 55 88             	mov    %edx,-0x78(%rbp)
  4023c4:	eb 0f                	jmp    4023d5 <printf+0xeb>
  4023c6:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  4023ca:	48 89 d0             	mov    %rdx,%rax
  4023cd:	48 83 c2 08          	add    $0x8,%rdx
  4023d1:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
  4023d5:	8b 00                	mov    (%rax),%eax
  4023d7:	89 45 bc             	mov    %eax,-0x44(%rbp)
				if(num<0)
  4023da:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
  4023de:	79 35                	jns    402415 <printf+0x12b>
				{
					screen[screen_ctr++]='-';
  4023e0:	48 8b 05 89 21 20 00 	mov    0x202189(%rip),%rax        # 604570 <chdir+0x201218>
  4023e7:	8b 00                	mov    (%rax),%eax
  4023e9:	8d 48 01             	lea    0x1(%rax),%ecx
  4023ec:	48 8b 15 7d 21 20 00 	mov    0x20217d(%rip),%rdx        # 604570 <chdir+0x201218>
  4023f3:	89 0a                	mov    %ecx,(%rdx)
  4023f5:	48 8b 15 7c 21 20 00 	mov    0x20217c(%rip),%rdx        # 604578 <chdir+0x201220>
  4023fc:	48 98                	cltq   
  4023fe:	c6 04 02 2d          	movb   $0x2d,(%rdx,%rax,1)
					print_num(-num,10);
  402402:	8b 45 bc             	mov    -0x44(%rbp),%eax
  402405:	f7 d8                	neg    %eax
  402407:	be 0a 00 00 00       	mov    $0xa,%esi
  40240c:	89 c7                	mov    %eax,%edi
  40240e:	e8 d9 fc ff ff       	callq  4020ec <print_num>
  402413:	eb 0f                	jmp    402424 <printf+0x13a>
				}
				else
					print_num(num,10);
  402415:	8b 45 bc             	mov    -0x44(%rbp),%eax
  402418:	be 0a 00 00 00       	mov    $0xa,%esi
  40241d:	89 c7                	mov    %eax,%edi
  40241f:	e8 c8 fc ff ff       	callq  4020ec <print_num>
				format++;
  402424:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
				continue;
  40242b:	e9 1d 02 00 00       	jmpq   40264d <printf+0x363>

			case 'c':
				printed=printed;;
				int chr = va_arg(val, int);
  402430:	8b 45 88             	mov    -0x78(%rbp),%eax
  402433:	83 f8 30             	cmp    $0x30,%eax
  402436:	73 17                	jae    40244f <printf+0x165>
  402438:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  40243c:	8b 45 88             	mov    -0x78(%rbp),%eax
  40243f:	89 c0                	mov    %eax,%eax
  402441:	48 01 d0             	add    %rdx,%rax
  402444:	8b 55 88             	mov    -0x78(%rbp),%edx
  402447:	83 c2 08             	add    $0x8,%edx
  40244a:	89 55 88             	mov    %edx,-0x78(%rbp)
  40244d:	eb 0f                	jmp    40245e <printf+0x174>
  40244f:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  402453:	48 89 d0             	mov    %rdx,%rax
  402456:	48 83 c2 08          	add    $0x8,%rdx
  40245a:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
  40245e:	8b 00                	mov    (%rax),%eax
  402460:	89 45 b8             	mov    %eax,-0x48(%rbp)
				screen[screen_ctr++] = chr;
  402463:	48 8b 05 06 21 20 00 	mov    0x202106(%rip),%rax        # 604570 <chdir+0x201218>
  40246a:	8b 00                	mov    (%rax),%eax
  40246c:	8d 48 01             	lea    0x1(%rax),%ecx
  40246f:	48 8b 15 fa 20 20 00 	mov    0x2020fa(%rip),%rdx        # 604570 <chdir+0x201218>
  402476:	89 0a                	mov    %ecx,(%rdx)
  402478:	8b 55 b8             	mov    -0x48(%rbp),%edx
  40247b:	48 8b 0d f6 20 20 00 	mov    0x2020f6(%rip),%rcx        # 604578 <chdir+0x201220>
  402482:	48 98                	cltq   
  402484:	88 14 01             	mov    %dl,(%rcx,%rax,1)
				format++;
  402487:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
				continue;
  40248e:	e9 ba 01 00 00       	jmpq   40264d <printf+0x363>

			case 's':
				printed=printed;
				char* str = va_arg(val, char*);
  402493:	8b 45 88             	mov    -0x78(%rbp),%eax
  402496:	83 f8 30             	cmp    $0x30,%eax
  402499:	73 17                	jae    4024b2 <printf+0x1c8>
  40249b:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  40249f:	8b 45 88             	mov    -0x78(%rbp),%eax
  4024a2:	89 c0                	mov    %eax,%eax
  4024a4:	48 01 d0             	add    %rdx,%rax
  4024a7:	8b 55 88             	mov    -0x78(%rbp),%edx
  4024aa:	83 c2 08             	add    $0x8,%edx
  4024ad:	89 55 88             	mov    %edx,-0x78(%rbp)
  4024b0:	eb 0f                	jmp    4024c1 <printf+0x1d7>
  4024b2:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  4024b6:	48 89 d0             	mov    %rdx,%rax
  4024b9:	48 83 c2 08          	add    $0x8,%rdx
  4024bd:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
  4024c1:	48 8b 00             	mov    (%rax),%rax
  4024c4:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				while(*(str) != '\0')
  4024c8:	eb 33                	jmp    4024fd <printf+0x213>
					screen[screen_ctr++] = *str++;
  4024ca:	48 8b 05 9f 20 20 00 	mov    0x20209f(%rip),%rax        # 604570 <chdir+0x201218>
  4024d1:	8b 00                	mov    (%rax),%eax
  4024d3:	89 c2                	mov    %eax,%edx
  4024d5:	8d 4a 01             	lea    0x1(%rdx),%ecx
  4024d8:	48 8b 05 91 20 20 00 	mov    0x202091(%rip),%rax        # 604570 <chdir+0x201218>
  4024df:	89 08                	mov    %ecx,(%rax)
  4024e1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  4024e5:	48 8d 48 01          	lea    0x1(%rax),%rcx
  4024e9:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  4024ed:	0f b6 00             	movzbl (%rax),%eax
  4024f0:	48 8b 0d 81 20 20 00 	mov    0x202081(%rip),%rcx        # 604578 <chdir+0x201220>
  4024f7:	48 63 d2             	movslq %edx,%rdx
  4024fa:	88 04 11             	mov    %al,(%rcx,%rdx,1)
				continue;

			case 's':
				printed=printed;
				char* str = va_arg(val, char*);
				while(*(str) != '\0')
  4024fd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  402501:	0f b6 00             	movzbl (%rax),%eax
  402504:	84 c0                	test   %al,%al
  402506:	75 c2                	jne    4024ca <printf+0x1e0>
					screen[screen_ctr++] = *str++;
				format++;
  402508:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
				continue;
  40250f:	e9 39 01 00 00       	jmpq   40264d <printf+0x363>

			case 'x':
				printed=printed;
				int hex = va_arg(val, int);
  402514:	8b 45 88             	mov    -0x78(%rbp),%eax
  402517:	83 f8 30             	cmp    $0x30,%eax
  40251a:	73 17                	jae    402533 <printf+0x249>
  40251c:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  402520:	8b 45 88             	mov    -0x78(%rbp),%eax
  402523:	89 c0                	mov    %eax,%eax
  402525:	48 01 d0             	add    %rdx,%rax
  402528:	8b 55 88             	mov    -0x78(%rbp),%edx
  40252b:	83 c2 08             	add    $0x8,%edx
  40252e:	89 55 88             	mov    %edx,-0x78(%rbp)
  402531:	eb 0f                	jmp    402542 <printf+0x258>
  402533:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  402537:	48 89 d0             	mov    %rdx,%rax
  40253a:	48 83 c2 08          	add    $0x8,%rdx
  40253e:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
  402542:	8b 00                	mov    (%rax),%eax
  402544:	89 45 b4             	mov    %eax,-0x4c(%rbp)
				if(hex<0)
  402547:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
  40254b:	79 35                	jns    402582 <printf+0x298>
				{
					screen[screen_ctr++]='-';
  40254d:	48 8b 05 1c 20 20 00 	mov    0x20201c(%rip),%rax        # 604570 <chdir+0x201218>
  402554:	8b 00                	mov    (%rax),%eax
  402556:	8d 48 01             	lea    0x1(%rax),%ecx
  402559:	48 8b 15 10 20 20 00 	mov    0x202010(%rip),%rdx        # 604570 <chdir+0x201218>
  402560:	89 0a                	mov    %ecx,(%rdx)
  402562:	48 8b 15 0f 20 20 00 	mov    0x20200f(%rip),%rdx        # 604578 <chdir+0x201220>
  402569:	48 98                	cltq   
  40256b:	c6 04 02 2d          	movb   $0x2d,(%rdx,%rax,1)
					print_num(-hex,16);
  40256f:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  402572:	f7 d8                	neg    %eax
  402574:	be 10 00 00 00       	mov    $0x10,%esi
  402579:	89 c7                	mov    %eax,%edi
  40257b:	e8 6c fb ff ff       	callq  4020ec <print_num>
  402580:	eb 0f                	jmp    402591 <printf+0x2a7>
				}
				else
					print_num(hex,16);
  402582:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  402585:	be 10 00 00 00       	mov    $0x10,%esi
  40258a:	89 c7                	mov    %eax,%edi
  40258c:	e8 5b fb ff ff       	callq  4020ec <print_num>

				format++;
  402591:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
				continue;
  402598:	e9 b0 00 00 00       	jmpq   40264d <printf+0x363>

			case 'p':
				printed=printed;
				long unsigned int ptr =(unsigned long int) va_arg(val, long int );
  40259d:	8b 45 88             	mov    -0x78(%rbp),%eax
  4025a0:	83 f8 30             	cmp    $0x30,%eax
  4025a3:	73 17                	jae    4025bc <printf+0x2d2>
  4025a5:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  4025a9:	8b 45 88             	mov    -0x78(%rbp),%eax
  4025ac:	89 c0                	mov    %eax,%eax
  4025ae:	48 01 d0             	add    %rdx,%rax
  4025b1:	8b 55 88             	mov    -0x78(%rbp),%edx
  4025b4:	83 c2 08             	add    $0x8,%edx
  4025b7:	89 55 88             	mov    %edx,-0x78(%rbp)
  4025ba:	eb 0f                	jmp    4025cb <printf+0x2e1>
  4025bc:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  4025c0:	48 89 d0             	mov    %rdx,%rax
  4025c3:	48 83 c2 08          	add    $0x8,%rdx
  4025c7:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
  4025cb:	48 8b 00             	mov    (%rax),%rax
  4025ce:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
				print_ptr(ptr,16);
  4025d2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  4025d6:	be 10 00 00 00       	mov    $0x10,%esi
  4025db:	48 89 c7             	mov    %rax,%rdi
  4025de:	e8 01 fc ff ff       	callq  4021e4 <print_ptr>

				format++;
  4025e3:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
				continue;
  4025ea:	eb 61                	jmp    40264d <printf+0x363>


			case '%':
				printed=printed;
				char c='%';
  4025ec:	c6 45 a7 25          	movb   $0x25,-0x59(%rbp)

				screen[screen_ctr++] = c;
  4025f0:	48 8b 05 79 1f 20 00 	mov    0x201f79(%rip),%rax        # 604570 <chdir+0x201218>
  4025f7:	8b 00                	mov    (%rax),%eax
  4025f9:	8d 48 01             	lea    0x1(%rax),%ecx
  4025fc:	48 8b 15 6d 1f 20 00 	mov    0x201f6d(%rip),%rdx        # 604570 <chdir+0x201218>
  402603:	89 0a                	mov    %ecx,(%rdx)
  402605:	48 8b 0d 6c 1f 20 00 	mov    0x201f6c(%rip),%rcx        # 604578 <chdir+0x201220>
  40260c:	48 63 d0             	movslq %eax,%rdx
  40260f:	0f b6 45 a7          	movzbl -0x59(%rbp),%eax
  402613:	88 04 11             	mov    %al,(%rcx,%rdx,1)
  402616:	eb 35                	jmp    40264d <printf+0x363>
			}
		}
		else
		{

			screen[screen_ctr++] = *format;
  402618:	48 8b 05 51 1f 20 00 	mov    0x201f51(%rip),%rax        # 604570 <chdir+0x201218>
  40261f:	8b 00                	mov    (%rax),%eax
  402621:	8d 48 01             	lea    0x1(%rax),%ecx
  402624:	48 8b 15 45 1f 20 00 	mov    0x201f45(%rip),%rdx        # 604570 <chdir+0x201218>
  40262b:	89 0a                	mov    %ecx,(%rdx)
  40262d:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  402634:	0f b6 12             	movzbl (%rdx),%edx
  402637:	48 8b 0d 3a 1f 20 00 	mov    0x201f3a(%rip),%rcx        # 604578 <chdir+0x201220>
  40263e:	48 98                	cltq   
  402640:	88 14 01             	mov    %dl,(%rcx,%rax,1)
			++printed;
  402643:	ff 45 cc             	incl   -0x34(%rbp)
			++format;
  402646:	48 ff 85 78 ff ff ff 	incq   -0x88(%rbp)
	va_list val;
	int printed = 0;
	screen_ctr=0;
	va_start(val, format);

	while(*format)
  40264d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  402654:	0f b6 00             	movzbl (%rax),%eax
  402657:	84 c0                	test   %al,%al
  402659:	0f 85 e1 fc ff ff    	jne    402340 <printf+0x56>
			++printed;
			++format;
		}
	}

	printed = write(1,screen, screen_ctr);
  40265f:	48 8b 05 0a 1f 20 00 	mov    0x201f0a(%rip),%rax        # 604570 <chdir+0x201218>
  402666:	8b 00                	mov    (%rax),%eax
  402668:	48 98                	cltq   
  40266a:	48 89 c2             	mov    %rax,%rdx
  40266d:	48 8b 05 04 1f 20 00 	mov    0x201f04(%rip),%rax        # 604578 <chdir+0x201220>
  402674:	48 89 c6             	mov    %rax,%rsi
  402677:	bf 01 00 00 00       	mov    $0x1,%edi
  40267c:	e8 52 00 00 00       	callq  4026d3 <write>
  402681:	89 45 cc             	mov    %eax,-0x34(%rbp)
	if(printed < 0)
  402684:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  402688:	79 07                	jns    402691 <printf+0x3a7>
		return -1;
  40268a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  40268f:	eb 09                	jmp    40269a <printf+0x3b0>
	return screen_ctr;
  402691:	48 8b 05 d8 1e 20 00 	mov    0x201ed8(%rip),%rax        # 604570 <chdir+0x201218>
  402698:	8b 00                	mov    (%rax),%eax

}
  40269a:	c9                   	leaveq 
  40269b:	c3                   	retq   

000000000040269c <syscall_3>:
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
}

static __inline uint64_t syscall_3(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3) {
  40269c:	55                   	push   %rbp
  40269d:	48 89 e5             	mov    %rsp,%rbp
  4026a0:	48 83 ec 30          	sub    $0x30,%rsp
  4026a4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  4026a8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  4026ac:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  4026b0:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)

	uint64_t ret;
    
	__asm__("movq %1,%%rax;"
  4026b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4026b8:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  4026bc:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  4026c0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  4026c4:	cd 80                	int    $0x80
  4026c6:	48 89 c0             	mov    %rax,%rax
  4026c9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %3, %%rsi;"
			"movq %4, %%rdx;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2),"m"(a3));
	return ret;
  4026cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  4026d1:	c9                   	leaveq 
  4026d2:	c3                   	retq   

00000000004026d3 <write>:
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>


ssize_t write(int fd, const void *buf, size_t count){
  4026d3:	55                   	push   %rbp
  4026d4:	48 89 e5             	mov    %rsp,%rbp
  4026d7:	48 83 ec 28          	sub    $0x28,%rsp
  4026db:	89 7d ec             	mov    %edi,-0x14(%rbp)
  4026de:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  4026e2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	int retvalue=syscall_3(SYS_write,fd,(uint64_t)buf,(uint64_t)count);
  4026e6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  4026ea:	8b 45 ec             	mov    -0x14(%rbp),%eax
  4026ed:	48 98                	cltq   
  4026ef:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  4026f3:	48 89 c6             	mov    %rax,%rsi
  4026f6:	bf 01 00 00 00       	mov    $0x1,%edi
  4026fb:	e8 9c ff ff ff       	callq  40269c <syscall_3>
  402700:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(retvalue >=0){
  402703:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  402707:	78 07                	js     402710 <write+0x3d>
		return retvalue;
  402709:	8b 45 fc             	mov    -0x4(%rbp),%eax
  40270c:	48 98                	cltq   
  40270e:	eb 07                	jmp    402717 <write+0x44>
	}
	return -1;
  402710:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
}
  402717:	c9                   	leaveq 
  402718:	c3                   	retq   

0000000000402719 <syscall_2>:
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
}

static __inline uint64_t syscall_2(uint64_t n, uint64_t a1, uint64_t a2) {
  402719:	55                   	push   %rbp
  40271a:	48 89 e5             	mov    %rsp,%rbp
  40271d:	48 83 ec 28          	sub    $0x28,%rsp
  402721:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402725:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  402729:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	uint64_t ret;
	__asm__("movq %1,%%rax;"
  40272d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402731:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402735:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  402739:	cd 80                	int    $0x80
  40273b:	48 89 c0             	mov    %rax,%rax
  40273e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %2,%%rdi;"
			"movq %3,%%rsi;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
  402742:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  402746:	c9                   	leaveq 
  402747:	c3                   	retq   

0000000000402748 <opendir>:
#include<syscall.h>
#include<string.h>


void *opendir(const char *name)
{
  402748:	55                   	push   %rbp
  402749:	48 89 e5             	mov    %rsp,%rbp
  40274c:	48 83 ec 20          	sub    $0x20,%rsp
  402750:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	
	uint64_t fd=0;
  402754:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  40275b:	00 

	//WARNING THIS IS A HACK MUST ALLOCATE SPACE FR FD and return it

	fd = (uint64_t)syscall_2(SYS_open, (uint64_t) name, O_DIRECTORY | O_RDONLY);
  40275c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402760:	ba 00 00 01 00       	mov    $0x10000,%edx
  402765:	48 89 c6             	mov    %rax,%rsi
  402768:	bf 02 00 00 00       	mov    $0x2,%edi
  40276d:	e8 a7 ff ff ff       	callq  402719 <syscall_2>
  402772:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	


	if(fd == -1){
  402776:	48 83 7d f8 ff       	cmpq   $0xffffffffffffffff,-0x8(%rbp)
  40277b:	75 1a                	jne    402797 <opendir+0x4f>
		printf("No such file or directory\n");
  40277d:	48 8d 3d 1f 11 00 00 	lea    0x111f(%rip),%rdi        # 4038a3 <chdir+0x54b>
  402784:	b8 00 00 00 00       	mov    $0x0,%eax
  402789:	e8 5c fb ff ff       	callq  4022ea <printf>
		return (void*)-1;
  40278e:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  402795:	eb 04                	jmp    40279b <opendir+0x53>
	}

	return (void*)fd;
  402797:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  40279b:	c9                   	leaveq 
  40279c:	c3                   	retq   

000000000040279d <syscall_3>:

static __inline uint64_t syscall_3(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3) {
  40279d:	55                   	push   %rbp
  40279e:	48 89 e5             	mov    %rsp,%rbp
  4027a1:	48 83 ec 30          	sub    $0x30,%rsp
  4027a5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  4027a9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  4027ad:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  4027b1:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)

	uint64_t ret;
    
	__asm__("movq %1,%%rax;"
  4027b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4027b9:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  4027bd:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  4027c1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  4027c5:	cd 80                	int    $0x80
  4027c7:	48 89 c0             	mov    %rax,%rax
  4027ca:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %3, %%rsi;"
			"movq %4, %%rdx;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2),"m"(a3));
	return ret;
  4027ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  4027d2:	c9                   	leaveq 
  4027d3:	c3                   	retq   

00000000004027d4 <read>:
#include <sys/syscall.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>

ssize_t read(int fd, void *buf, size_t count){
  4027d4:	55                   	push   %rbp
  4027d5:	48 89 e5             	mov    %rsp,%rbp
  4027d8:	48 83 ec 30          	sub    $0x30,%rsp
  4027dc:	89 7d ec             	mov    %edi,-0x14(%rbp)
  4027df:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  4027e3:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	int retvalue;
	retvalue =syscall_3(SYS_read,fd,(uint64_t)buf,(uint64_t)count);
  4027e7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  4027eb:	8b 45 ec             	mov    -0x14(%rbp),%eax
  4027ee:	48 98                	cltq   
  4027f0:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  4027f4:	48 89 c6             	mov    %rax,%rsi
  4027f7:	bf 00 00 00 00       	mov    $0x0,%edi
  4027fc:	e8 9c ff ff ff       	callq  40279d <syscall_3>
  402801:	89 45 fc             	mov    %eax,-0x4(%rbp)
	
	if(retvalue < 0 ){
  402804:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  402808:	79 1a                	jns    402824 <read+0x50>
		printf("Error in reading File\n");
  40280a:	48 8d 3d ad 10 00 00 	lea    0x10ad(%rip),%rdi        # 4038be <chdir+0x566>
  402811:	b8 00 00 00 00       	mov    $0x0,%eax
  402816:	e8 cf fa ff ff       	callq  4022ea <printf>
		return -1;
  40281b:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  402822:	eb 05                	jmp    402829 <read+0x55>
	}
	
	return retvalue;
  402824:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402827:	48 98                	cltq   

}
  402829:	c9                   	leaveq 
  40282a:	c3                   	retq   

000000000040282b <syscall_1>:
			:"=r"(ret):"m"(n));

	return ret;
}

static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
  40282b:	55                   	push   %rbp
  40282c:	48 89 e5             	mov    %rsp,%rbp
  40282f:	48 83 ec 20          	sub    $0x20,%rsp
  402833:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402837:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int64_t ret;

	__asm__("movq $78,%r15");
  40283b:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
	//__asm__("movq %0,%%rax;"
	//		::"m"(n));

	//while(1);

	if(n==60){
  402842:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402846:	48 83 f8 3c          	cmp    $0x3c,%rax
  40284a:	75 0c                	jne    402858 <syscall_1+0x2d>
		__asm__("movq %0,%%rax;"
  40284c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402850:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402854:	cd 80                	int    $0x80
  402856:	eb 11                	jmp    402869 <syscall_1+0x3e>

		//while(1);
	}
	else{

		__asm__("movq %1,%%rax;"
  402858:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40285c:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402860:	cd 80                	int    $0x80
  402862:	48 89 c0             	mov    %rax,%rax
  402865:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				"movq %2,%%rdi;"
				"int $0x80;"
				"movq %%rax,%0;"
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
  402869:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  40286d:	c9                   	leaveq 
  40286e:	c3                   	retq   

000000000040286f <pipe>:
#include<sys/defs.h>
#include<sys/syscall.h>
#include<syscall.h>
#include<stdlib.h>
int pipe(int fd[2])
{
  40286f:	55                   	push   %rbp
  402870:	48 89 e5             	mov    %rsp,%rbp
  402873:	48 83 ec 18          	sub    $0x18,%rsp
  402877:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int retvalue;
	retvalue = syscall_1(SYS_pipe, (uint64_t)fd);
  40287b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40287f:	48 89 c6             	mov    %rax,%rsi
  402882:	bf 16 00 00 00       	mov    $0x16,%edi
  402887:	e8 9f ff ff ff       	callq  40282b <syscall_1>
  40288c:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(retvalue >=0){
  40288f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  402893:	78 05                	js     40289a <pipe+0x2b>
		return retvalue;
  402895:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402898:	eb 05                	jmp    40289f <pipe+0x30>
	}

	return -1;
  40289a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  40289f:	c9                   	leaveq 
  4028a0:	c3                   	retq   

00000000004028a1 <syscall_3>:
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2));
	return ret;
}

static __inline uint64_t syscall_3(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3) {
  4028a1:	55                   	push   %rbp
  4028a2:	48 89 e5             	mov    %rsp,%rbp
  4028a5:	48 83 ec 30          	sub    $0x30,%rsp
  4028a9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  4028ad:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  4028b1:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  4028b5:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)

	uint64_t ret;
    
	__asm__("movq %1,%%rax;"
  4028b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4028bd:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  4028c1:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  4028c5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  4028c9:	cd 80                	int    $0x80
  4028cb:	48 89 c0             	mov    %rax,%rax
  4028ce:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"movq %3, %%rsi;"
			"movq %4, %%rdx;"
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n),"m"(a1),"m"(a2),"m"(a3));
	return ret;
  4028d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  4028d6:	c9                   	leaveq 
  4028d7:	c3                   	retq   

00000000004028d8 <execve>:
#include<sys/syscall.h>
#include<syscall.h>
#include<stdlib.h>

int execve(const char *filename, char *const argv[], char *const envp[])
{
  4028d8:	55                   	push   %rbp
  4028d9:	48 89 e5             	mov    %rsp,%rbp
  4028dc:	48 83 ec 28          	sub    $0x28,%rsp
  4028e0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  4028e4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  4028e8:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
		int retvalue;
		retvalue = syscall_3(SYS_execve, (uint64_t)filename, (uint64_t)argv, (uint64_t)envp);
  4028ec:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  4028f0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  4028f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4028f8:	48 89 c6             	mov    %rax,%rsi
  4028fb:	bf 3b 00 00 00       	mov    $0x3b,%edi
  402900:	e8 9c ff ff ff       	callq  4028a1 <syscall_3>
  402905:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if(retvalue >=0){
  402908:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  40290c:	78 05                	js     402913 <execve+0x3b>
			return retvalue;
  40290e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402911:	eb 05                	jmp    402918 <execve+0x40>
		}
		return -1;
  402913:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
  402918:	c9                   	leaveq 
  402919:	c3                   	retq   

000000000040291a <syscall_0>:
#define _SYSCALL_H

#include <sys/defs.h>
#include <sys/syscall.h>

static __inline uint64_t syscall_0(uint64_t n) {
  40291a:	55                   	push   %rbp
  40291b:	48 89 e5             	mov    %rsp,%rbp
  40291e:	48 83 ec 18          	sub    $0x18,%rsp
  402922:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	uint64_t ret;
	__asm__("movq %1,%%rax;"
  402926:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40292a:	cd 80                	int    $0x80
  40292c:	48 89 c0             	mov    %rax,%rax
  40292f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			"int $0x80;"
			"movq %%rax,%0;"
			:"=r"(ret):"m"(n));

	return ret;
  402933:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  402937:	c9                   	leaveq 
  402938:	c3                   	retq   

0000000000402939 <fork>:
#include <stdio.h>
#include <errno.h>


pid_t fork()
{
  402939:	55                   	push   %rbp
  40293a:	48 89 e5             	mov    %rsp,%rbp
  40293d:	48 83 ec 10          	sub    $0x10,%rsp
	int retvalue;

	retvalue = syscall_0(SYS_fork);
  402941:	bf 39 00 00 00       	mov    $0x39,%edi
  402946:	e8 cf ff ff ff       	callq  40291a <syscall_0>
  40294b:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(retvalue >=0){
  40294e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  402952:	78 05                	js     402959 <fork+0x20>
		return retvalue;
  402954:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402957:	eb 05                	jmp    40295e <fork+0x25>
	}
	return -1;
  402959:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
  40295e:	c9                   	leaveq 
  40295f:	c3                   	retq   

0000000000402960 <syscall_1>:

static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
  402960:	55                   	push   %rbp
  402961:	48 89 e5             	mov    %rsp,%rbp
  402964:	48 83 ec 20          	sub    $0x20,%rsp
  402968:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  40296c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int64_t ret;

	__asm__("movq $78,%r15");
  402970:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
	//__asm__("movq %0,%%rax;"
	//		::"m"(n));

	//while(1);

	if(n==60){
  402977:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40297b:	48 83 f8 3c          	cmp    $0x3c,%rax
  40297f:	75 0c                	jne    40298d <syscall_1+0x2d>
		__asm__("movq %0,%%rax;"
  402981:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402985:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402989:	cd 80                	int    $0x80
  40298b:	eb 11                	jmp    40299e <syscall_1+0x3e>

		//while(1);
	}
	else{

		__asm__("movq %1,%%rax;"
  40298d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402991:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402995:	cd 80                	int    $0x80
  402997:	48 89 c0             	mov    %rax,%rax
  40299a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				"movq %2,%%rdi;"
				"int $0x80;"
				"movq %%rax,%0;"
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
  40299e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  4029a2:	c9                   	leaveq 
  4029a3:	c3                   	retq   

00000000004029a4 <exit>:
#include <sys/defs.h>
#include <syscall.h>
#include <stdlib.h>
#include <sys/syscall.h>

void exit(int status){
  4029a4:	55                   	push   %rbp
  4029a5:	48 89 e5             	mov    %rsp,%rbp
  4029a8:	48 83 ec 08          	sub    $0x8,%rsp
  4029ac:	89 7d fc             	mov    %edi,-0x4(%rbp)

	syscall_1(SYS_exit,44);
  4029af:	be 2c 00 00 00       	mov    $0x2c,%esi
  4029b4:	bf 3c 00 00 00       	mov    $0x3c,%edi
  4029b9:	e8 a2 ff ff ff       	callq  402960 <syscall_1>


}
  4029be:	c9                   	leaveq 
  4029bf:	c3                   	retq   

00000000004029c0 <strlen>:
#include <errno.h>



int strlen(const char *str)
{
  4029c0:	55                   	push   %rbp
  4029c1:	48 89 e5             	mov    %rsp,%rbp
  4029c4:	48 83 ec 18          	sub    $0x18,%rsp
  4029c8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	const char *ptr=str;
  4029cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4029d0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for(;*ptr != '\0'; ptr++);
  4029d4:	eb 04                	jmp    4029da <strlen+0x1a>
  4029d6:	48 ff 45 f8          	incq   -0x8(%rbp)
  4029da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4029de:	0f b6 00             	movzbl (%rax),%eax
  4029e1:	84 c0                	test   %al,%al
  4029e3:	75 f1                	jne    4029d6 <strlen+0x16>

	return ptr-str;
  4029e5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  4029e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4029ed:	48 29 c2             	sub    %rax,%rdx
  4029f0:	48 89 d0             	mov    %rdx,%rax
}
  4029f3:	c9                   	leaveq 
  4029f4:	c3                   	retq   

00000000004029f5 <strcpy>:

char* strcpy(char* dst, const char* src)
{
  4029f5:	55                   	push   %rbp
  4029f6:	48 89 e5             	mov    %rsp,%rbp
  4029f9:	48 83 ec 30          	sub    $0x30,%rsp
  4029fd:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  402a01:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	////printf("In strcpy\n");
	int i, len=strlen(src);
  402a05:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  402a09:	48 89 c7             	mov    %rax,%rdi
  402a0c:	e8 af ff ff ff       	callq  4029c0 <strlen>
  402a11:	89 45 ec             	mov    %eax,-0x14(%rbp)
	//printf("In strlen.... length of src %d\n",len);
	char* ptr=dst;
  402a14:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  402a18:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	for(i=0; i<=len; i++)
  402a1c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  402a23:	eb 21                	jmp    402a46 <strcpy+0x51>
	{
		*ptr++ = src[i];
  402a25:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402a29:	48 8d 50 01          	lea    0x1(%rax),%rdx
  402a2d:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  402a31:	8b 55 fc             	mov    -0x4(%rbp),%edx
  402a34:	48 63 ca             	movslq %edx,%rcx
  402a37:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  402a3b:	48 01 ca             	add    %rcx,%rdx
  402a3e:	0f b6 12             	movzbl (%rdx),%edx
  402a41:	88 10                	mov    %dl,(%rax)
	////printf("In strcpy\n");
	int i, len=strlen(src);
	//printf("In strlen.... length of src %d\n",len);
	char* ptr=dst;

	for(i=0; i<=len; i++)
  402a43:	ff 45 fc             	incl   -0x4(%rbp)
  402a46:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402a49:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  402a4c:	7e d7                	jle    402a25 <strcpy+0x30>
	{
		*ptr++ = src[i];
	}
	return dst;
  402a4e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
}
  402a52:	c9                   	leaveq 
  402a53:	c3                   	retq   

0000000000402a54 <strcmp>:


int strcmp(const char *str1, const char *str2)
{
  402a54:	55                   	push   %rbp
  402a55:	48 89 e5             	mov    %rsp,%rbp
  402a58:	48 83 ec 10          	sub    $0x10,%rsp
  402a5c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  402a60:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)

	while(1)
	{
		////printf("In strcmp\n");

		if(*str1 != *str2)
  402a64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402a68:	0f b6 10             	movzbl (%rax),%edx
  402a6b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402a6f:	0f b6 00             	movzbl (%rax),%eax
  402a72:	38 c2                	cmp    %al,%dl
  402a74:	74 1a                	je     402a90 <strcmp+0x3c>
			return (*str1 - *str2);
  402a76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402a7a:	0f b6 00             	movzbl (%rax),%eax
  402a7d:	0f be d0             	movsbl %al,%edx
  402a80:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402a84:	0f b6 00             	movzbl (%rax),%eax
  402a87:	0f be c0             	movsbl %al,%eax
  402a8a:	29 c2                	sub    %eax,%edx
  402a8c:	89 d0                	mov    %edx,%eax
  402a8e:	eb 49                	jmp    402ad9 <strcmp+0x85>

		else if((*str1 == *str2) && (*(str1+1) == *(str2 + 1)) && (*(str1 + 1) == '\0'))
  402a90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402a94:	0f b6 10             	movzbl (%rax),%edx
  402a97:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402a9b:	0f b6 00             	movzbl (%rax),%eax
  402a9e:	38 c2                	cmp    %al,%dl
  402aa0:	75 2d                	jne    402acf <strcmp+0x7b>
  402aa2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402aa6:	48 ff c0             	inc    %rax
  402aa9:	0f b6 10             	movzbl (%rax),%edx
  402aac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402ab0:	48 ff c0             	inc    %rax
  402ab3:	0f b6 00             	movzbl (%rax),%eax
  402ab6:	38 c2                	cmp    %al,%dl
  402ab8:	75 15                	jne    402acf <strcmp+0x7b>
  402aba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402abe:	48 ff c0             	inc    %rax
  402ac1:	0f b6 00             	movzbl (%rax),%eax
  402ac4:	84 c0                	test   %al,%al
  402ac6:	75 07                	jne    402acf <strcmp+0x7b>
			return 0;
  402ac8:	b8 00 00 00 00       	mov    $0x0,%eax
  402acd:	eb 0a                	jmp    402ad9 <strcmp+0x85>


		str1++;
  402acf:	48 ff 45 f8          	incq   -0x8(%rbp)
		str2++;
  402ad3:	48 ff 45 f0          	incq   -0x10(%rbp)

	}
  402ad7:	eb 8b                	jmp    402a64 <strcmp+0x10>

	return 0;
}
  402ad9:	c9                   	leaveq 
  402ada:	c3                   	retq   

0000000000402adb <strstr>:

const char *strstr(const char *haystack, const char *needle)
{
  402adb:	55                   	push   %rbp
  402adc:	48 89 e5             	mov    %rsp,%rbp
  402adf:	48 83 ec 20          	sub    $0x20,%rsp
  402ae3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402ae7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	//printf("In strstrt\n %s %s\n\n", haystack,  needle);
	int len = strlen(haystack), i, j;
  402aeb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402aef:	48 89 c7             	mov    %rax,%rdi
  402af2:	e8 c9 fe ff ff       	callq  4029c0 <strlen>
  402af7:	89 45 f4             	mov    %eax,-0xc(%rbp)
	for(i=0; i< len; i++)
  402afa:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  402b01:	e9 a0 00 00 00       	jmpq   402ba6 <strstr+0xcb>
	{
		for(j = i; j< strlen(needle); j++)
  402b06:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402b09:	89 45 f8             	mov    %eax,-0x8(%rbp)
  402b0c:	eb 31                	jmp    402b3f <strstr+0x64>
		{
			if(*(haystack+i+j) != *(needle+j))
  402b0e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402b11:	48 63 d0             	movslq %eax,%rdx
  402b14:	8b 45 f8             	mov    -0x8(%rbp),%eax
  402b17:	48 98                	cltq   
  402b19:	48 01 c2             	add    %rax,%rdx
  402b1c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402b20:	48 01 d0             	add    %rdx,%rax
  402b23:	0f b6 10             	movzbl (%rax),%edx
  402b26:	8b 45 f8             	mov    -0x8(%rbp),%eax
  402b29:	48 63 c8             	movslq %eax,%rcx
  402b2c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402b30:	48 01 c8             	add    %rcx,%rax
  402b33:	0f b6 00             	movzbl (%rax),%eax
  402b36:	38 c2                	cmp    %al,%dl
  402b38:	74 02                	je     402b3c <strstr+0x61>
				break;
  402b3a:	eb 14                	jmp    402b50 <strstr+0x75>

	//printf("In strstrt\n %s %s\n\n", haystack,  needle);
	int len = strlen(haystack), i, j;
	for(i=0; i< len; i++)
	{
		for(j = i; j< strlen(needle); j++)
  402b3c:	ff 45 f8             	incl   -0x8(%rbp)
  402b3f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402b43:	48 89 c7             	mov    %rax,%rdi
  402b46:	e8 75 fe ff ff       	callq  4029c0 <strlen>
  402b4b:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  402b4e:	7f be                	jg     402b0e <strstr+0x33>
		{
			if(*(haystack+i+j) != *(needle+j))
				break;
		}	

		if( (j == strlen(needle) ) && (*(haystack+i+j-1) == *(needle+j-1)))
  402b50:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402b54:	48 89 c7             	mov    %rax,%rdi
  402b57:	e8 64 fe ff ff       	callq  4029c0 <strlen>
  402b5c:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  402b5f:	75 42                	jne    402ba3 <strstr+0xc8>
  402b61:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402b64:	48 63 d0             	movslq %eax,%rdx
  402b67:	8b 45 f8             	mov    -0x8(%rbp),%eax
  402b6a:	48 98                	cltq   
  402b6c:	48 01 d0             	add    %rdx,%rax
  402b6f:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  402b73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402b77:	48 01 d0             	add    %rdx,%rax
  402b7a:	0f b6 10             	movzbl (%rax),%edx
  402b7d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  402b80:	48 98                	cltq   
  402b82:	48 8d 48 ff          	lea    -0x1(%rax),%rcx
  402b86:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  402b8a:	48 01 c8             	add    %rcx,%rax
  402b8d:	0f b6 00             	movzbl (%rax),%eax
  402b90:	38 c2                	cmp    %al,%dl
  402b92:	75 0f                	jne    402ba3 <strstr+0xc8>
		{
			return (haystack + i);
  402b94:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402b97:	48 63 d0             	movslq %eax,%rdx
  402b9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402b9e:	48 01 d0             	add    %rdx,%rax
  402ba1:	eb 14                	jmp    402bb7 <strstr+0xdc>
const char *strstr(const char *haystack, const char *needle)
{

	//printf("In strstrt\n %s %s\n\n", haystack,  needle);
	int len = strlen(haystack), i, j;
	for(i=0; i< len; i++)
  402ba3:	ff 45 fc             	incl   -0x4(%rbp)
  402ba6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402ba9:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  402bac:	0f 8c 54 ff ff ff    	jl     402b06 <strstr+0x2b>
		{
			return (haystack + i);
		}
	}

	return NULL;
  402bb2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  402bb7:	c9                   	leaveq 
  402bb8:	c3                   	retq   

0000000000402bb9 <strcat>:

char *strcat(char *dst, const char *src)
{
  402bb9:	55                   	push   %rbp
  402bba:	48 89 e5             	mov    %rsp,%rbp
  402bbd:	48 83 ec 10          	sub    $0x10,%rsp
  402bc1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  402bc5:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	strcpy(&dst[strlen(dst)],src);
  402bc9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402bcd:	48 89 c7             	mov    %rax,%rdi
  402bd0:	e8 eb fd ff ff       	callq  4029c0 <strlen>
  402bd5:	48 63 d0             	movslq %eax,%rdx
  402bd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402bdc:	48 01 c2             	add    %rax,%rdx
  402bdf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  402be3:	48 89 c6             	mov    %rax,%rsi
  402be6:	48 89 d7             	mov    %rdx,%rdi
  402be9:	e8 07 fe ff ff       	callq  4029f5 <strcpy>
	//printf("after cat: %s\n\n\n",dst);
	return dst;
  402bee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  402bf2:	c9                   	leaveq 
  402bf3:	c3                   	retq   

0000000000402bf4 <strerror>:

uint64_t strerror(int err)
{
  402bf4:	55                   	push   %rbp
  402bf5:	48 89 e5             	mov    %rsp,%rbp
  402bf8:	48 83 ec 10          	sub    $0x10,%rsp
  402bfc:	89 7d fc             	mov    %edi,-0x4(%rbp)

	switch(err)
  402bff:	83 7d fc 24          	cmpl   $0x24,-0x4(%rbp)
  402c03:	0f 87 5a 03 00 00    	ja     402f63 <strerror+0x36f>
  402c09:	8b 45 fc             	mov    -0x4(%rbp),%eax
  402c0c:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
  402c13:	00 
  402c14:	48 8d 05 a1 0f 00 00 	lea    0xfa1(%rip),%rax        # 403bbc <chdir+0x864>
  402c1b:	8b 04 02             	mov    (%rdx,%rax,1),%eax
  402c1e:	48 63 d0             	movslq %eax,%rdx
  402c21:	48 8d 05 94 0f 00 00 	lea    0xf94(%rip),%rax        # 403bbc <chdir+0x864>
  402c28:	48 01 d0             	add    %rdx,%rax
  402c2b:	ff e0                	jmpq   *%rax
	{

	case EPERM    : {return  printf("Operation not permitted \n");break;}
  402c2d:	48 8d 3d a4 0c 00 00 	lea    0xca4(%rip),%rdi        # 4038d8 <chdir+0x580>
  402c34:	b8 00 00 00 00       	mov    $0x0,%eax
  402c39:	e8 ac f6 ff ff       	callq  4022ea <printf>
  402c3e:	48 98                	cltq   
  402c40:	e9 23 03 00 00       	jmpq   402f68 <strerror+0x374>
	case ENOENT   : {return  printf("No such file or directory \n");break;}
  402c45:	48 8d 3d a6 0c 00 00 	lea    0xca6(%rip),%rdi        # 4038f2 <chdir+0x59a>
  402c4c:	b8 00 00 00 00       	mov    $0x0,%eax
  402c51:	e8 94 f6 ff ff       	callq  4022ea <printf>
  402c56:	48 98                	cltq   
  402c58:	e9 0b 03 00 00       	jmpq   402f68 <strerror+0x374>
	case ESRCH    : {return  printf("No such process \n");;break;}
  402c5d:	48 8d 3d aa 0c 00 00 	lea    0xcaa(%rip),%rdi        # 40390e <chdir+0x5b6>
  402c64:	b8 00 00 00 00       	mov    $0x0,%eax
  402c69:	e8 7c f6 ff ff       	callq  4022ea <printf>
  402c6e:	48 98                	cltq   
  402c70:	e9 f3 02 00 00       	jmpq   402f68 <strerror+0x374>
	case EINTR    : {return  printf("Interrupted system call \n");break;}
  402c75:	48 8d 3d a4 0c 00 00 	lea    0xca4(%rip),%rdi        # 403920 <chdir+0x5c8>
  402c7c:	b8 00 00 00 00       	mov    $0x0,%eax
  402c81:	e8 64 f6 ff ff       	callq  4022ea <printf>
  402c86:	48 98                	cltq   
  402c88:	e9 db 02 00 00       	jmpq   402f68 <strerror+0x374>
	case EIO      : {return  printf("error \n");;break;}
  402c8d:	48 8d 3d a6 0c 00 00 	lea    0xca6(%rip),%rdi        # 40393a <chdir+0x5e2>
  402c94:	b8 00 00 00 00       	mov    $0x0,%eax
  402c99:	e8 4c f6 ff ff       	callq  4022ea <printf>
  402c9e:	48 98                	cltq   
  402ca0:	e9 c3 02 00 00       	jmpq   402f68 <strerror+0x374>
	case ENXIO    : {return  printf("No such device or address \n");break;}
  402ca5:	48 8d 3d 96 0c 00 00 	lea    0xc96(%rip),%rdi        # 403942 <chdir+0x5ea>
  402cac:	b8 00 00 00 00       	mov    $0x0,%eax
  402cb1:	e8 34 f6 ff ff       	callq  4022ea <printf>
  402cb6:	48 98                	cltq   
  402cb8:	e9 ab 02 00 00       	jmpq   402f68 <strerror+0x374>
	case E2BIG    : {return  printf("Argument list too long \n");break;}
  402cbd:	48 8d 3d 9a 0c 00 00 	lea    0xc9a(%rip),%rdi        # 40395e <chdir+0x606>
  402cc4:	b8 00 00 00 00       	mov    $0x0,%eax
  402cc9:	e8 1c f6 ff ff       	callq  4022ea <printf>
  402cce:	48 98                	cltq   
  402cd0:	e9 93 02 00 00       	jmpq   402f68 <strerror+0x374>
	case ENOEXEC  : {return  printf("Exec format error \n");break;}
  402cd5:	48 8d 3d 9b 0c 00 00 	lea    0xc9b(%rip),%rdi        # 403977 <chdir+0x61f>
  402cdc:	b8 00 00 00 00       	mov    $0x0,%eax
  402ce1:	e8 04 f6 ff ff       	callq  4022ea <printf>
  402ce6:	48 98                	cltq   
  402ce8:	e9 7b 02 00 00       	jmpq   402f68 <strerror+0x374>
	case EBADF    : {return  printf("Bad file number \n");break;}
  402ced:	48 8d 3d 97 0c 00 00 	lea    0xc97(%rip),%rdi        # 40398b <chdir+0x633>
  402cf4:	b8 00 00 00 00       	mov    $0x0,%eax
  402cf9:	e8 ec f5 ff ff       	callq  4022ea <printf>
  402cfe:	48 98                	cltq   
  402d00:	e9 63 02 00 00       	jmpq   402f68 <strerror+0x374>
	case ECHILD   : {return  printf("No child processes \n");break;}
  402d05:	48 8d 3d 91 0c 00 00 	lea    0xc91(%rip),%rdi        # 40399d <chdir+0x645>
  402d0c:	b8 00 00 00 00       	mov    $0x0,%eax
  402d11:	e8 d4 f5 ff ff       	callq  4022ea <printf>
  402d16:	48 98                	cltq   
  402d18:	e9 4b 02 00 00       	jmpq   402f68 <strerror+0x374>
	case EAGAIN   : {return  printf("Try again \n");;break;}
  402d1d:	48 8d 3d 8e 0c 00 00 	lea    0xc8e(%rip),%rdi        # 4039b2 <chdir+0x65a>
  402d24:	b8 00 00 00 00       	mov    $0x0,%eax
  402d29:	e8 bc f5 ff ff       	callq  4022ea <printf>
  402d2e:	48 98                	cltq   
  402d30:	e9 33 02 00 00       	jmpq   402f68 <strerror+0x374>
	case ENOMEM   : {return  printf("Out of memory \n");;break;}
  402d35:	48 8d 3d 82 0c 00 00 	lea    0xc82(%rip),%rdi        # 4039be <chdir+0x666>
  402d3c:	b8 00 00 00 00       	mov    $0x0,%eax
  402d41:	e8 a4 f5 ff ff       	callq  4022ea <printf>
  402d46:	48 98                	cltq   
  402d48:	e9 1b 02 00 00       	jmpq   402f68 <strerror+0x374>
	case EACCES   : {return  printf("Permission denied \n");break;}
  402d4d:	48 8d 3d 7a 0c 00 00 	lea    0xc7a(%rip),%rdi        # 4039ce <chdir+0x676>
  402d54:	b8 00 00 00 00       	mov    $0x0,%eax
  402d59:	e8 8c f5 ff ff       	callq  4022ea <printf>
  402d5e:	48 98                	cltq   
  402d60:	e9 03 02 00 00       	jmpq   402f68 <strerror+0x374>
	case EFAULT   : {return  printf("Bad address \n");;break;}
  402d65:	48 8d 3d 76 0c 00 00 	lea    0xc76(%rip),%rdi        # 4039e2 <chdir+0x68a>
  402d6c:	b8 00 00 00 00       	mov    $0x0,%eax
  402d71:	e8 74 f5 ff ff       	callq  4022ea <printf>
  402d76:	48 98                	cltq   
  402d78:	e9 eb 01 00 00       	jmpq   402f68 <strerror+0x374>
	case ENOTBLK  : {return  printf("Block device required \n");break;}
  402d7d:	48 8d 3d 6c 0c 00 00 	lea    0xc6c(%rip),%rdi        # 4039f0 <chdir+0x698>
  402d84:	b8 00 00 00 00       	mov    $0x0,%eax
  402d89:	e8 5c f5 ff ff       	callq  4022ea <printf>
  402d8e:	48 98                	cltq   
  402d90:	e9 d3 01 00 00       	jmpq   402f68 <strerror+0x374>
	case EBUSY    : {return  printf("Device or resource busy \n");break;}
  402d95:	48 8d 3d 6c 0c 00 00 	lea    0xc6c(%rip),%rdi        # 403a08 <chdir+0x6b0>
  402d9c:	b8 00 00 00 00       	mov    $0x0,%eax
  402da1:	e8 44 f5 ff ff       	callq  4022ea <printf>
  402da6:	48 98                	cltq   
  402da8:	e9 bb 01 00 00       	jmpq   402f68 <strerror+0x374>
	case EEXIST   : {return  printf("File exists \n");;break;}
  402dad:	48 8d 3d 6e 0c 00 00 	lea    0xc6e(%rip),%rdi        # 403a22 <chdir+0x6ca>
  402db4:	b8 00 00 00 00       	mov    $0x0,%eax
  402db9:	e8 2c f5 ff ff       	callq  4022ea <printf>
  402dbe:	48 98                	cltq   
  402dc0:	e9 a3 01 00 00       	jmpq   402f68 <strerror+0x374>
	case EXDEV    : {return  printf("Cross-device link \n");break;}
  402dc5:	48 8d 3d 64 0c 00 00 	lea    0xc64(%rip),%rdi        # 403a30 <chdir+0x6d8>
  402dcc:	b8 00 00 00 00       	mov    $0x0,%eax
  402dd1:	e8 14 f5 ff ff       	callq  4022ea <printf>
  402dd6:	48 98                	cltq   
  402dd8:	e9 8b 01 00 00       	jmpq   402f68 <strerror+0x374>
	case ENODEV   : {return  printf("No such device \n");break;}
  402ddd:	48 8d 3d 60 0c 00 00 	lea    0xc60(%rip),%rdi        # 403a44 <chdir+0x6ec>
  402de4:	b8 00 00 00 00       	mov    $0x0,%eax
  402de9:	e8 fc f4 ff ff       	callq  4022ea <printf>
  402dee:	48 98                	cltq   
  402df0:	e9 73 01 00 00       	jmpq   402f68 <strerror+0x374>
	case ENOTDIR  : {return  printf("Not a directory \n");break;}
  402df5:	48 8d 3d 59 0c 00 00 	lea    0xc59(%rip),%rdi        # 403a55 <chdir+0x6fd>
  402dfc:	b8 00 00 00 00       	mov    $0x0,%eax
  402e01:	e8 e4 f4 ff ff       	callq  4022ea <printf>
  402e06:	48 98                	cltq   
  402e08:	e9 5b 01 00 00       	jmpq   402f68 <strerror+0x374>
	case EISDIR   : {return  printf("Is a directory \n");break;}
  402e0d:	48 8d 3d 53 0c 00 00 	lea    0xc53(%rip),%rdi        # 403a67 <chdir+0x70f>
  402e14:	b8 00 00 00 00       	mov    $0x0,%eax
  402e19:	e8 cc f4 ff ff       	callq  4022ea <printf>
  402e1e:	48 98                	cltq   
  402e20:	e9 43 01 00 00       	jmpq   402f68 <strerror+0x374>
	case EINVAL   : {return  printf("Invalid argument \n");break;}
  402e25:	48 8d 3d 4c 0c 00 00 	lea    0xc4c(%rip),%rdi        # 403a78 <chdir+0x720>
  402e2c:	b8 00 00 00 00       	mov    $0x0,%eax
  402e31:	e8 b4 f4 ff ff       	callq  4022ea <printf>
  402e36:	48 98                	cltq   
  402e38:	e9 2b 01 00 00       	jmpq   402f68 <strerror+0x374>
	case ENFILE   : {return  printf("File table overflow \n");break;}
  402e3d:	48 8d 3d 47 0c 00 00 	lea    0xc47(%rip),%rdi        # 403a8b <chdir+0x733>
  402e44:	b8 00 00 00 00       	mov    $0x0,%eax
  402e49:	e8 9c f4 ff ff       	callq  4022ea <printf>
  402e4e:	48 98                	cltq   
  402e50:	e9 13 01 00 00       	jmpq   402f68 <strerror+0x374>
	case EMFILE   : {return  printf("Too many open files \n");break;}
  402e55:	48 8d 3d 45 0c 00 00 	lea    0xc45(%rip),%rdi        # 403aa1 <chdir+0x749>
  402e5c:	b8 00 00 00 00       	mov    $0x0,%eax
  402e61:	e8 84 f4 ff ff       	callq  4022ea <printf>
  402e66:	48 98                	cltq   
  402e68:	e9 fb 00 00 00       	jmpq   402f68 <strerror+0x374>
	case ENOTTY   : {return  printf("Not a typewriter \n");break;}
  402e6d:	48 8d 3d 43 0c 00 00 	lea    0xc43(%rip),%rdi        # 403ab7 <chdir+0x75f>
  402e74:	b8 00 00 00 00       	mov    $0x0,%eax
  402e79:	e8 6c f4 ff ff       	callq  4022ea <printf>
  402e7e:	48 98                	cltq   
  402e80:	e9 e3 00 00 00       	jmpq   402f68 <strerror+0x374>
	case ETXTBSY  : {return  printf("Text file busy \n");break;}
  402e85:	48 8d 3d 3e 0c 00 00 	lea    0xc3e(%rip),%rdi        # 403aca <chdir+0x772>
  402e8c:	b8 00 00 00 00       	mov    $0x0,%eax
  402e91:	e8 54 f4 ff ff       	callq  4022ea <printf>
  402e96:	48 98                	cltq   
  402e98:	e9 cb 00 00 00       	jmpq   402f68 <strerror+0x374>
	case EFBIG    : {return  printf("File too large \n");break;}
  402e9d:	48 8d 3d 37 0c 00 00 	lea    0xc37(%rip),%rdi        # 403adb <chdir+0x783>
  402ea4:	b8 00 00 00 00       	mov    $0x0,%eax
  402ea9:	e8 3c f4 ff ff       	callq  4022ea <printf>
  402eae:	48 98                	cltq   
  402eb0:	e9 b3 00 00 00       	jmpq   402f68 <strerror+0x374>
	case ENOSPC   : {return  printf("No space left on device \n");break;}
  402eb5:	48 8d 3d 30 0c 00 00 	lea    0xc30(%rip),%rdi        # 403aec <chdir+0x794>
  402ebc:	b8 00 00 00 00       	mov    $0x0,%eax
  402ec1:	e8 24 f4 ff ff       	callq  4022ea <printf>
  402ec6:	48 98                	cltq   
  402ec8:	e9 9b 00 00 00       	jmpq   402f68 <strerror+0x374>
	case ESPIPE   : {return  printf("Illegal seek \n");break;}
  402ecd:	48 8d 3d 32 0c 00 00 	lea    0xc32(%rip),%rdi        # 403b06 <chdir+0x7ae>
  402ed4:	b8 00 00 00 00       	mov    $0x0,%eax
  402ed9:	e8 0c f4 ff ff       	callq  4022ea <printf>
  402ede:	48 98                	cltq   
  402ee0:	e9 83 00 00 00       	jmpq   402f68 <strerror+0x374>
	case EROFS    : {return  printf("Read-only file system \n");break;}
  402ee5:	48 8d 3d 29 0c 00 00 	lea    0xc29(%rip),%rdi        # 403b15 <chdir+0x7bd>
  402eec:	b8 00 00 00 00       	mov    $0x0,%eax
  402ef1:	e8 f4 f3 ff ff       	callq  4022ea <printf>
  402ef6:	48 98                	cltq   
  402ef8:	eb 6e                	jmp    402f68 <strerror+0x374>
	case EMLINK   : {return  printf("Too many links \n");break;}
  402efa:	48 8d 3d 2c 0c 00 00 	lea    0xc2c(%rip),%rdi        # 403b2d <chdir+0x7d5>
  402f01:	b8 00 00 00 00       	mov    $0x0,%eax
  402f06:	e8 df f3 ff ff       	callq  4022ea <printf>
  402f0b:	48 98                	cltq   
  402f0d:	eb 59                	jmp    402f68 <strerror+0x374>
	case EPIPE    : {return  printf("Broken pipe \n");break;}
  402f0f:	48 8d 3d 28 0c 00 00 	lea    0xc28(%rip),%rdi        # 403b3e <chdir+0x7e6>
  402f16:	b8 00 00 00 00       	mov    $0x0,%eax
  402f1b:	e8 ca f3 ff ff       	callq  4022ea <printf>
  402f20:	48 98                	cltq   
  402f22:	eb 44                	jmp    402f68 <strerror+0x374>
	case EDOM     : {return  printf("Math argument out of domain of func \n");break;}
  402f24:	48 8d 3d 25 0c 00 00 	lea    0xc25(%rip),%rdi        # 403b50 <chdir+0x7f8>
  402f2b:	b8 00 00 00 00       	mov    $0x0,%eax
  402f30:	e8 b5 f3 ff ff       	callq  4022ea <printf>
  402f35:	48 98                	cltq   
  402f37:	eb 2f                	jmp    402f68 <strerror+0x374>
	case ERANGE   : {return  printf("Math result not representable \n");break;}
  402f39:	48 8d 3d 38 0c 00 00 	lea    0xc38(%rip),%rdi        # 403b78 <chdir+0x820>
  402f40:	b8 00 00 00 00       	mov    $0x0,%eax
  402f45:	e8 a0 f3 ff ff       	callq  4022ea <printf>
  402f4a:	48 98                	cltq   
  402f4c:	eb 1a                	jmp    402f68 <strerror+0x374>
	case ENAMETOOLONG:	{return printf(" The path is too long to search \n");break;}
  402f4e:	48 8d 3d 43 0c 00 00 	lea    0xc43(%rip),%rdi        # 403b98 <chdir+0x840>
  402f55:	b8 00 00 00 00       	mov    $0x0,%eax
  402f5a:	e8 8b f3 ff ff       	callq  4022ea <printf>
  402f5f:	48 98                	cltq   
  402f61:	eb 05                	jmp    402f68 <strerror+0x374>
	
	//return printf("error occured.\n");
	}
return 0;
  402f63:	b8 00 00 00 00       	mov    $0x0,%eax
  402f68:	c9                   	leaveq 
  402f69:	c3                   	retq   

0000000000402f6a <syscall_1>:
			:"=r"(ret):"m"(n));

	return ret;
}

static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
  402f6a:	55                   	push   %rbp
  402f6b:	48 89 e5             	mov    %rsp,%rbp
  402f6e:	48 83 ec 20          	sub    $0x20,%rsp
  402f72:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402f76:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int64_t ret;

	__asm__("movq $78,%r15");
  402f7a:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
	//__asm__("movq %0,%%rax;"
	//		::"m"(n));

	//while(1);

	if(n==60){
  402f81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402f85:	48 83 f8 3c          	cmp    $0x3c,%rax
  402f89:	75 0c                	jne    402f97 <syscall_1+0x2d>
		__asm__("movq %0,%%rax;"
  402f8b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402f8f:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402f93:	cd 80                	int    $0x80
  402f95:	eb 11                	jmp    402fa8 <syscall_1+0x3e>

		//while(1);
	}
	else{

		__asm__("movq %1,%%rax;"
  402f97:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402f9b:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  402f9f:	cd 80                	int    $0x80
  402fa1:	48 89 c0             	mov    %rax,%rax
  402fa4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				"movq %2,%%rdi;"
				"int $0x80;"
				"movq %%rax,%0;"
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
  402fa8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  402fac:	c9                   	leaveq 
  402fad:	c3                   	retq   

0000000000402fae <make_head>:

enum {NEW_MCB, NO_MCB, REUSE_MCB};
enum {FREE, IN_USE};

void make_head(char *addr, int size) 
{
  402fae:	55                   	push   %rbp
  402faf:	48 89 e5             	mov    %rsp,%rbp
  402fb2:	48 83 ec 1c          	sub    $0x1c,%rsp
  402fb6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  402fba:	89 75 e4             	mov    %esi,-0x1c(%rbp)
    MCB_P head         = (MCB_P)addr;
  402fbd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  402fc1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    head->is_available = FREE;
  402fc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402fc9:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
    head->size         = size;
  402fcf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  402fd3:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  402fd6:	89 50 04             	mov    %edx,0x4(%rax)
}
  402fd9:	c9                   	leaveq 
  402fda:	c3                   	retq   

0000000000402fdb <alloc_new>:

void *alloc_new(int aligned_size)
{
  402fdb:	55                   	push   %rbp
  402fdc:	48 89 e5             	mov    %rsp,%rbp
  402fdf:	48 83 ec 30          	sub    $0x30,%rsp
  402fe3:	89 7d dc             	mov    %edi,-0x24(%rbp)
    char *add;
    uint64_t no_of_pages = 0, sz;    
  402fe6:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  402fed:	00 
    MCB_P p_mcb;
    
    sz          = sizeof(MCB_t);
  402fee:	48 c7 45 f0 08 00 00 	movq   $0x8,-0x10(%rbp)
  402ff5:	00 
    no_of_pages = (aligned_size + sz) /(PAGESIZE + 1) + 1;
  402ff6:	8b 45 dc             	mov    -0x24(%rbp),%eax
  402ff9:	48 63 d0             	movslq %eax,%rdx
  402ffc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  403000:	48 01 d0             	add    %rdx,%rax
  403003:	48 ba f1 ff 00 f0 ff 	movabs $0xfff000fff000fff1,%rdx
  40300a:	00 f0 ff 
  40300d:	48 f7 e2             	mul    %rdx
  403010:	48 89 d0             	mov    %rdx,%rax
  403013:	48 c1 e8 0c          	shr    $0xc,%rax
  403017:	48 ff c0             	inc    %rax
  40301a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    add = (char*)syscall_1(SYS_brk, (uint64_t)no_of_pages*4096);    
  40301e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  403022:	48 c1 e0 0c          	shl    $0xc,%rax
  403026:	48 89 c6             	mov    %rax,%rsi
  403029:	bf 0c 00 00 00       	mov    $0xc,%edi
  40302e:	e8 37 ff ff ff       	callq  402f6a <syscall_1>
  403033:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    printf("add=%p",add);
  403037:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40303b:	48 89 c6             	mov    %rax,%rsi
  40303e:	48 8d 3d 0b 0c 00 00 	lea    0xc0b(%rip),%rdi        # 403c50 <chdir+0x8f8>
  403045:	b8 00 00 00 00       	mov    $0x0,%eax
  40304a:	e8 9b f2 ff ff       	callq  4022ea <printf>
    if (heap_end == 0) {
  40304f:	48 8b 05 3a 16 20 00 	mov    0x20163a(%rip),%rax        # 604690 <heap_end>
  403056:	48 85 c0             	test   %rax,%rax
  403059:	75 2a                	jne    403085 <alloc_new+0xaa>
        mem_start_p   = add;
  40305b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40305f:	48 89 05 22 16 20 00 	mov    %rax,0x201622(%rip)        # 604688 <mem_start_p>
        mcb_count     = 0;
  403066:	c7 05 30 16 20 00 00 	movl   $0x0,0x201630(%rip)        # 6046a0 <mcb_count>
  40306d:	00 00 00 
        allocated_mem = 0;
  403070:	c7 05 22 16 20 00 00 	movl   $0x0,0x201622(%rip)        # 60469c <allocated_mem>
  403077:	00 00 00 
        heap_end = add; 
  40307a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40307e:	48 89 05 0b 16 20 00 	mov    %rax,0x20160b(%rip)        # 604690 <heap_end>
    }
    
    heap_end = (char*)((uint64_t)add + (uint64_t)(PAGESIZE * no_of_pages));
  403085:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  403089:	48 c1 e0 0c          	shl    $0xc,%rax
  40308d:	48 89 c2             	mov    %rax,%rdx
  403090:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403094:	48 01 d0             	add    %rdx,%rax
  403097:	48 89 05 f2 15 20 00 	mov    %rax,0x2015f2(%rip)        # 604690 <heap_end>
    max_mem += PAGESIZE * no_of_pages; 
  40309e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4030a2:	c1 e0 0c             	shl    $0xc,%eax
  4030a5:	89 c2                	mov    %eax,%edx
  4030a7:	8b 05 eb 15 20 00    	mov    0x2015eb(%rip),%eax        # 604698 <max_mem>
  4030ad:	01 d0                	add    %edx,%eax
  4030af:	89 05 e3 15 20 00    	mov    %eax,0x2015e3(%rip)        # 604698 <max_mem>
    
    p_mcb               = (MCB_P)add; 
  4030b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4030b9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    p_mcb->is_available = IN_USE;
  4030bd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4030c1:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    p_mcb->size         = aligned_size + sz; 
  4030c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4030cb:	89 c2                	mov    %eax,%edx
  4030cd:	8b 45 dc             	mov    -0x24(%rbp),%eax
  4030d0:	01 d0                	add    %edx,%eax
  4030d2:	89 c2                	mov    %eax,%edx
  4030d4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  4030d8:	89 50 04             	mov    %edx,0x4(%rax)
    mcb_count++;    
  4030db:	8b 05 bf 15 20 00    	mov    0x2015bf(%rip),%eax        # 6046a0 <mcb_count>
  4030e1:	ff c0                	inc    %eax
  4030e3:	89 05 b7 15 20 00    	mov    %eax,0x2015b7(%rip)        # 6046a0 <mcb_count>

    if (PAGESIZE * no_of_pages > aligned_size + sz) {
  4030e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4030ed:	48 c1 e0 0c          	shl    $0xc,%rax
  4030f1:	48 89 c1             	mov    %rax,%rcx
  4030f4:	8b 45 dc             	mov    -0x24(%rbp),%eax
  4030f7:	48 63 d0             	movslq %eax,%rdx
  4030fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4030fe:	48 01 d0             	add    %rdx,%rax
  403101:	48 39 c1             	cmp    %rax,%rcx
  403104:	76 34                	jbe    40313a <alloc_new+0x15f>
        make_head(((char *)p_mcb + aligned_size + sz), (PAGESIZE * no_of_pages - aligned_size - sz));
  403106:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40310a:	c1 e0 0c             	shl    $0xc,%eax
  40310d:	89 c2                	mov    %eax,%edx
  40310f:	8b 45 dc             	mov    -0x24(%rbp),%eax
  403112:	29 c2                	sub    %eax,%edx
  403114:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  403118:	29 c2                	sub    %eax,%edx
  40311a:	89 d0                	mov    %edx,%eax
  40311c:	8b 55 dc             	mov    -0x24(%rbp),%edx
  40311f:	48 63 ca             	movslq %edx,%rcx
  403122:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  403126:	48 01 d1             	add    %rdx,%rcx
  403129:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  40312d:	48 01 ca             	add    %rcx,%rdx
  403130:	89 c6                	mov    %eax,%esi
  403132:	48 89 d7             	mov    %rdx,%rdi
  403135:	e8 74 fe ff ff       	callq  402fae <make_head>
    }

    allocated_mem += aligned_size; 
  40313a:	8b 15 5c 15 20 00    	mov    0x20155c(%rip),%edx        # 60469c <allocated_mem>
  403140:	8b 45 dc             	mov    -0x24(%rbp),%eax
  403143:	01 d0                	add    %edx,%eax
  403145:	89 05 51 15 20 00    	mov    %eax,0x201551(%rip)        # 60469c <allocated_mem>
    
    return ((void *) p_mcb + sz);
  40314b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40314f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  403153:	48 01 d0             	add    %rdx,%rax
}
  403156:	c9                   	leaveq 
  403157:	c3                   	retq   

0000000000403158 <malloc>:

void* malloc(size_t elem_size)
{
  403158:	55                   	push   %rbp
  403159:	48 89 e5             	mov    %rsp,%rbp
  40315c:	48 83 ec 30          	sub    $0x30,%rsp
  403160:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    MCB_P p_mcb;
    int flag, sz, temp = 0, aligned_size;
  403164:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)

    // Align elem_size to header size
    aligned_size = ((((elem_size - 1) >> 3) + 1) << 3);
  40316b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  40316f:	48 ff c8             	dec    %rax
  403172:	48 c1 e8 03          	shr    $0x3,%rax
  403176:	48 ff c0             	inc    %rax
  403179:	48 c1 e0 03          	shl    $0x3,%rax
  40317d:	89 45 ec             	mov    %eax,-0x14(%rbp)
    heap_end=heap_end;
  403180:	48 8b 05 09 15 20 00 	mov    0x201509(%rip),%rax        # 604690 <heap_end>
  403187:	48 89 05 02 15 20 00 	mov    %rax,0x201502(%rip)        # 604690 <heap_end>
    if (heap_end == 0) {
  40318e:	48 8b 05 fb 14 20 00 	mov    0x2014fb(%rip),%rax        # 604690 <heap_end>
  403195:	48 85 c0             	test   %rax,%rax
  403198:	75 0f                	jne    4031a9 <malloc+0x51>
        /*no heap has been assigned yet*/
        return alloc_new(aligned_size);
  40319a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  40319d:	89 c7                	mov    %eax,%edi
  40319f:	e8 37 fe ff ff       	callq  402fdb <alloc_new>
  4031a4:	e9 1a 01 00 00       	jmpq   4032c3 <malloc+0x16b>
    } else {

        flag  = NO_MCB;
  4031a9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
        p_mcb = (MCB_P)mem_start_p;
  4031b0:	48 8b 05 d1 14 20 00 	mov    0x2014d1(%rip),%rax        # 604688 <mem_start_p>
  4031b7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        sz    = sizeof(MCB_t);
  4031bb:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%rbp)

        //printf("\nheap_end : %p\treqd size: %p",heap_end, ((char *)p_mcb + aligned_size + sz));
        while (heap_end >= ((char *)p_mcb + aligned_size + sz)) {
  4031c2:	eb 33                	jmp    4031f7 <malloc+0x9f>
            if (p_mcb->is_available == FREE) {
  4031c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4031c8:	8b 00                	mov    (%rax),%eax
  4031ca:	85 c0                	test   %eax,%eax
  4031cc:	75 1c                	jne    4031ea <malloc+0x92>
                if (p_mcb->size >= (aligned_size + sz)) {
  4031ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4031d2:	8b 40 04             	mov    0x4(%rax),%eax
  4031d5:	8b 55 e8             	mov    -0x18(%rbp),%edx
  4031d8:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  4031db:	01 ca                	add    %ecx,%edx
  4031dd:	39 d0                	cmp    %edx,%eax
  4031df:	7c 09                	jl     4031ea <malloc+0x92>
                    flag = REUSE_MCB;
  4031e1:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%rbp)
                    break;
  4031e8:	eb 2e                	jmp    403218 <malloc+0xc0>
                }
            }
            p_mcb = (MCB_P) ((char *)p_mcb + p_mcb->size);
  4031ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4031ee:	8b 40 04             	mov    0x4(%rax),%eax
  4031f1:	48 98                	cltq   
  4031f3:	48 01 45 f8          	add    %rax,-0x8(%rbp)
        flag  = NO_MCB;
        p_mcb = (MCB_P)mem_start_p;
        sz    = sizeof(MCB_t);

        //printf("\nheap_end : %p\treqd size: %p",heap_end, ((char *)p_mcb + aligned_size + sz));
        while (heap_end >= ((char *)p_mcb + aligned_size + sz)) {
  4031f7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  4031fa:	48 63 d0             	movslq %eax,%rdx
  4031fd:	8b 45 e8             	mov    -0x18(%rbp),%eax
  403200:	48 98                	cltq   
  403202:	48 01 c2             	add    %rax,%rdx
  403205:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  403209:	48 01 c2             	add    %rax,%rdx
  40320c:	48 8b 05 7d 14 20 00 	mov    0x20147d(%rip),%rax        # 604690 <heap_end>
  403213:	48 39 c2             	cmp    %rax,%rdx
  403216:	76 ac                	jbe    4031c4 <malloc+0x6c>
                }
            }
            p_mcb = (MCB_P) ((char *)p_mcb + p_mcb->size);
        }

        if (flag != NO_MCB) {
  403218:	83 7d f4 01          	cmpl   $0x1,-0xc(%rbp)
  40321c:	0f 84 97 00 00 00    	je     4032b9 <malloc+0x161>
            p_mcb->is_available = IN_USE;
  403222:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  403226:	c7 00 01 00 00 00    	movl   $0x1,(%rax)

            if (flag == REUSE_MCB) {
  40322c:	83 7d f4 02          	cmpl   $0x2,-0xc(%rbp)
  403230:	75 67                	jne    403299 <malloc+0x141>
                if (p_mcb->size > aligned_size + sz) {
  403232:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  403236:	8b 40 04             	mov    0x4(%rax),%eax
  403239:	8b 55 e8             	mov    -0x18(%rbp),%edx
  40323c:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  40323f:	01 ca                	add    %ecx,%edx
  403241:	39 d0                	cmp    %edx,%eax
  403243:	7e 46                	jle    40328b <malloc+0x133>
                    temp        = p_mcb->size; 
  403245:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  403249:	8b 40 04             	mov    0x4(%rax),%eax
  40324c:	89 45 f0             	mov    %eax,-0x10(%rbp)
                    p_mcb->size = aligned_size + sz;
  40324f:	8b 45 e8             	mov    -0x18(%rbp),%eax
  403252:	8b 55 ec             	mov    -0x14(%rbp),%edx
  403255:	01 c2                	add    %eax,%edx
  403257:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  40325b:	89 50 04             	mov    %edx,0x4(%rax)

                    make_head(((char *)p_mcb + aligned_size + sz),(temp - aligned_size - sz));
  40325e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  403261:	8b 55 f0             	mov    -0x10(%rbp),%edx
  403264:	29 c2                	sub    %eax,%edx
  403266:	89 d0                	mov    %edx,%eax
  403268:	2b 45 e8             	sub    -0x18(%rbp),%eax
  40326b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  40326e:	48 63 ca             	movslq %edx,%rcx
  403271:	8b 55 e8             	mov    -0x18(%rbp),%edx
  403274:	48 63 d2             	movslq %edx,%rdx
  403277:	48 01 d1             	add    %rdx,%rcx
  40327a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  40327e:	48 01 ca             	add    %rcx,%rdx
  403281:	89 c6                	mov    %eax,%esi
  403283:	48 89 d7             	mov    %rdx,%rdi
  403286:	e8 23 fd ff ff       	callq  402fae <make_head>
                }        
                mcb_count++;
  40328b:	8b 05 0f 14 20 00    	mov    0x20140f(%rip),%eax        # 6046a0 <mcb_count>
  403291:	ff c0                	inc    %eax
  403293:	89 05 07 14 20 00    	mov    %eax,0x201407(%rip)        # 6046a0 <mcb_count>
            }
            allocated_mem += aligned_size;
  403299:	8b 15 fd 13 20 00    	mov    0x2013fd(%rip),%edx        # 60469c <allocated_mem>
  40329f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  4032a2:	01 d0                	add    %edx,%eax
  4032a4:	89 05 f2 13 20 00    	mov    %eax,0x2013f2(%rip)        # 60469c <allocated_mem>
            return ((char *) p_mcb + sz);
  4032aa:	8b 45 e8             	mov    -0x18(%rbp),%eax
  4032ad:	48 63 d0             	movslq %eax,%rdx
  4032b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4032b4:	48 01 d0             	add    %rdx,%rax
  4032b7:	eb 0a                	jmp    4032c3 <malloc+0x16b>
        }

        /*when no hole is found to match the request*/
        return alloc_new(aligned_size); 
  4032b9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  4032bc:	89 c7                	mov    %eax,%edi
  4032be:	e8 18 fd ff ff       	callq  402fdb <alloc_new>
    }

}
  4032c3:	c9                   	leaveq 
  4032c4:	c3                   	retq   

00000000004032c5 <free>:

void free(void *p)
{
  4032c5:	55                   	push   %rbp
  4032c6:	48 89 e5             	mov    %rsp,%rbp
  4032c9:	48 83 ec 18          	sub    $0x18,%rsp
  4032cd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    MCB_P ptr = (MCB_P)p;
  4032d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4032d5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    ptr--;
  4032d9:	48 83 6d f8 08       	subq   $0x8,-0x8(%rbp)

    mcb_count--;
  4032de:	8b 05 bc 13 20 00    	mov    0x2013bc(%rip),%eax        # 6046a0 <mcb_count>
  4032e4:	ff c8                	dec    %eax
  4032e6:	89 05 b4 13 20 00    	mov    %eax,0x2013b4(%rip)        # 6046a0 <mcb_count>
    ptr->is_available = FREE;
  4032ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4032f0:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
    allocated_mem    -= (ptr->size - sizeof(MCB_t));
  4032f6:	8b 05 a0 13 20 00    	mov    0x2013a0(%rip),%eax        # 60469c <allocated_mem>
  4032fc:	89 c2                	mov    %eax,%edx
  4032fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  403302:	8b 40 04             	mov    0x4(%rax),%eax
  403305:	29 c2                	sub    %eax,%edx
  403307:	89 d0                	mov    %edx,%eax
  403309:	83 c0 08             	add    $0x8,%eax
  40330c:	89 05 8a 13 20 00    	mov    %eax,0x20138a(%rip)        # 60469c <allocated_mem>

}
  403312:	c9                   	leaveq 
  403313:	c3                   	retq   

0000000000403314 <syscall_1>:
			:"=r"(ret):"m"(n));

	return ret;
}

static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {
  403314:	55                   	push   %rbp
  403315:	48 89 e5             	mov    %rsp,%rbp
  403318:	48 83 ec 20          	sub    $0x20,%rsp
  40331c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  403320:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)

	int64_t ret;

	__asm__("movq $78,%r15");
  403324:	49 c7 c7 4e 00 00 00 	mov    $0x4e,%r15
	//__asm__("movq %0,%%rax;"
	//		::"m"(n));

	//while(1);

	if(n==60){
  40332b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  40332f:	48 83 f8 3c          	cmp    $0x3c,%rax
  403333:	75 0c                	jne    403341 <syscall_1+0x2d>
		__asm__("movq %0,%%rax;"
  403335:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403339:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  40333d:	cd 80                	int    $0x80
  40333f:	eb 11                	jmp    403352 <syscall_1+0x3e>

		//while(1);
	}
	else{

		__asm__("movq %1,%%rax;"
  403341:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403345:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
  403349:	cd 80                	int    $0x80
  40334b:	48 89 c0             	mov    %rax,%rax
  40334e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				"movq %2,%%rdi;"
				"int $0x80;"
				"movq %%rax,%0;"
				:"=r"(ret):"m"(n),"m"(a1));
	}
	return ret;
  403352:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  403356:	c9                   	leaveq 
  403357:	c3                   	retq   

0000000000403358 <chdir>:
#include <sys/syscall.h>
#include <syscall.h>
#include <errno.h>
#include <stdlib.h>

int chdir(const char *path){
  403358:	55                   	push   %rbp
  403359:	48 89 e5             	mov    %rsp,%rbp
  40335c:	48 83 ec 18          	sub    $0x18,%rsp
  403360:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	int retvalue;
	retvalue=syscall_1(SYS_chdir,(uint64_t)path);
  403364:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  403368:	48 89 c6             	mov    %rax,%rsi
  40336b:	bf 50 00 00 00       	mov    $0x50,%edi
  403370:	e8 9f ff ff ff       	callq  403314 <syscall_1>
  403375:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(retvalue >=0){
  403378:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  40337c:	78 05                	js     403383 <chdir+0x2b>
		return retvalue;
  40337e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  403381:	eb 05                	jmp    403388 <chdir+0x30>
	}
	return -1;
  403383:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
  403388:	c9                   	leaveq 
  403389:	c3                   	retq   
