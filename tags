!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
-exclude	Makefile	/^	tar -czvf $(USER).tgz --exclude=.empty --exclude=.*.sw? --exclude=*~ LICENSE README Makefile linker.script sys bin crt libc newfs include $(ROOTFS) $(USER).img$/;"	m
AR	Makefile	/^AR=ar$/;"	m
AS	Makefile	/^AS=as$/;"	m
AVAIL1_BASE	include/sys/paging.h	16;"	d
AVAIL1_LIM	include/sys/paging.h	17;"	d
AVAIL2_BASE	include/sys/paging.h	18;"	d
AVAIL2_LIM	include/sys/paging.h	19;"	d
Allocations	sys/paging.c	/^int Allocations;$/;"	v
BINS	Makefile	/^BINS:=$(addprefix $(ROOTFS)\/,$(wildcard bin\/*))$/;"	m
BIN_SRCS	Makefile	/^BIN_SRCS:=$(shell find bin\/\\* -name \\*.c)$/;"	m
BUILTINS_H_	include/builtIns.h	9;"	d
C	sys/gdt.c	10;"	d	file:
CAPSLOCK	sys/keyboard.c	6;"	d	file:
CC	Makefile	/^CC=gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS= -std=c99 -D__thread= -Wall -Werror -nostdinc -Iinclude -msoft-float -mno-sse -mno-red-zone -fno-builtin -fPIC -march=amdfam10 -g3 -fno-stack-protector $/;"	m
CR0_AM	include/sys/mmu.h	103;"	d
CR0_CD	include/sys/mmu.h	105;"	d
CR0_EM	include/sys/mmu.h	98;"	d
CR0_ET	include/sys/mmu.h	100;"	d
CR0_MP	include/sys/mmu.h	97;"	d
CR0_NE	include/sys/mmu.h	101;"	d
CR0_NW	include/sys/mmu.h	104;"	d
CR0_PE	include/sys/mmu.h	96;"	d
CR0_PG	include/sys/mmu.h	106;"	d
CR0_TS	include/sys/mmu.h	99;"	d
CR0_WP	include/sys/mmu.h	102;"	d
CR4_DE	include/sys/mmu.h	111;"	d
CR4_MCE	include/sys/mmu.h	109;"	d
CR4_PAE	include/sys/mmu.h	117;"	d
CR4_PCE	include/sys/mmu.h	108;"	d
CR4_PSE	include/sys/mmu.h	110;"	d
CR4_PVI	include/sys/mmu.h	113;"	d
CR4_TSD	include/sys/mmu.h	112;"	d
CR4_VME	include/sys/mmu.h	114;"	d
CRT_SRCS	Makefile	/^CRT_SRCS:=$(shell find crt\/ -name \\*.c -o -name \\*.s)$/;"	m
CTRL	sys/keyboard.c	9;"	d	file:
CommArray	include/parser.h	/^	singleCommand* CommArray[PIPE_MAX_NUM];	\/* Array to store individual commands*\/$/;"	m	struct:__anon3
D	sys/gdt.c	17;"	d	file:
DIRECTORY	include/sys/tarfs.h	71;"	d
DPL0	sys/gdt.c	11;"	d	file:
DPL1	sys/gdt.c	12;"	d	file:
DPL2	sys/gdt.c	13;"	d	file:
DPL3	sys/gdt.c	14;"	d	file:
E2BIG	include/errno.h	16;"	d
EACCES	include/errno.h	22;"	d
EAGAIN	include/errno.h	20;"	d
EAPPEND	include/builtIns.h	12;"	d
EAPPEND	include/shell.h	14;"	d
EASIS	include/builtIns.h	11;"	d
EASIS	include/shell.h	13;"	d
EBADF	include/errno.h	18;"	d
EBUSY	include/errno.h	25;"	d
ECHILD	include/errno.h	19;"	d
EDEADLK	include/errno.h	44;"	d
EDOM	include/errno.h	42;"	d
EEXIST	include/errno.h	26;"	d
EFAULT	include/errno.h	23;"	d
EFBIG	include/errno.h	36;"	d
EFER_LME	include/sys/mmu.h	119;"	d
EFER_MSR	include/sys/mmu.h	118;"	d
EINTR	include/errno.h	13;"	d
EINVAL	include/errno.h	31;"	d
EIO	include/errno.h	14;"	d
EISDIR	include/errno.h	30;"	d
ELF_MAGIC	include/sys/elf.h	1;"	d
ELF_PROG_FLAG_EXEC	include/sys/elf.h	50;"	d
ELF_PROG_FLAG_READ	include/sys/elf.h	52;"	d
ELF_PROG_FLAG_WRITE	include/sys/elf.h	51;"	d
ELF_PROG_LOAD	include/sys/elf.h	47;"	d
ELF_SHN_UNDEF	include/sys/elf.h	61;"	d
ELF_SHT_NULL	include/sys/elf.h	55;"	d
ELF_SHT_PROGBITS	include/sys/elf.h	56;"	d
ELF_SHT_STRTAB	include/sys/elf.h	58;"	d
ELF_SHT_SYMTAB	include/sys/elf.h	57;"	d
EMFILE	include/errno.h	33;"	d
EMLINK	include/errno.h	40;"	d
ENAMETOOLONG	include/errno.h	45;"	d
ENFILE	include/errno.h	32;"	d
ENODEV	include/errno.h	28;"	d
ENOENT	include/errno.h	11;"	d
ENOEXEC	include/errno.h	17;"	d
ENOMEM	include/errno.h	21;"	d
ENOSPC	include/errno.h	37;"	d
ENOTBLK	include/errno.h	24;"	d
ENOTDIR	include/errno.h	29;"	d
ENOTTY	include/errno.h	34;"	d
ENXIO	include/errno.h	15;"	d
EPERM	include/errno.h	10;"	d
EPIPE	include/errno.h	41;"	d
EPREPEND	include/builtIns.h	13;"	d
EPREPEND	include/shell.h	15;"	d
ERANGE	include/errno.h	43;"	d
EROFS	include/errno.h	39;"	d
ER_P	include/sys/isr.h	29;"	d
ER_U	include/sys/isr.h	31;"	d
ER_W	include/sys/isr.h	30;"	d
ESPIPE	include/errno.h	38;"	d
ESRCH	include/errno.h	12;"	d
ETXTBSY	include/errno.h	35;"	d
EXDEV	include/errno.h	27;"	d
Elf	include/sys/elf.h	/^struct Elf {$/;"	s
FALSE	sys/keyboard.c	11;"	d	file:
FEC_PR	include/sys/mmu.h	145;"	d
FEC_U	include/sys/mmu.h	147;"	d
FEC_WR	include/sys/mmu.h	146;"	d
FILE_MAX_SIZE	include/parser.h	6;"	d
FILE_TYPE	include/sys/tarfs.h	72;"	d
FINDBINARYFULLPATH_H_	include/findBinaryFullPath.h	9;"	d
FL_AC	include/sys/mmu.h	139;"	d
FL_AF	include/sys/mmu.h	124;"	d
FL_CF	include/sys/mmu.h	122;"	d
FL_DF	include/sys/mmu.h	129;"	d
FL_ID	include/sys/mmu.h	142;"	d
FL_IF	include/sys/mmu.h	128;"	d
FL_IOPL_0	include/sys/mmu.h	132;"	d
FL_IOPL_1	include/sys/mmu.h	133;"	d
FL_IOPL_2	include/sys/mmu.h	134;"	d
FL_IOPL_3	include/sys/mmu.h	135;"	d
FL_IOPL_MASK	include/sys/mmu.h	131;"	d
FL_NT	include/sys/mmu.h	136;"	d
FL_OF	include/sys/mmu.h	130;"	d
FL_PF	include/sys/mmu.h	123;"	d
FL_RF	include/sys/mmu.h	137;"	d
FL_SF	include/sys/mmu.h	126;"	d
FL_TF	include/sys/mmu.h	127;"	d
FL_VIF	include/sys/mmu.h	140;"	d
FL_VIP	include/sys/mmu.h	141;"	d
FL_VM	include/sys/mmu.h	138;"	d
FL_ZF	include/sys/mmu.h	125;"	d
FREE	include/sys/process.h	/^FREE,$/;"	e	enum:ProcStatus
FREE	libc/malloc.c	/^enum {FREE, IN_USE};$/;"	e	enum:__anon13	file:
Feb	include/stringtokenizer.h	/^ *  Created on: Feb 2, 2015$/;"	v
GDT_CS	sys/gdt.c	7;"	d	file:
GDT_DS	sys/gdt.c	8;"	d	file:
GETENVIRONMENTVARLOC_H_	include/getEnvironmentVarLoc.h	9;"	d
GpRegs	include/sys/idt.h	/^struct GpRegs {$/;"	s
HEAP	include/sys/process.h	/^HEAP,$/;"	e	enum:SegType
ICW1_ICW4	include/sys/pic.h	21;"	d
ICW1_INIT	include/sys/pic.h	25;"	d
ICW1_INTERVAL4	include/sys/pic.h	23;"	d
ICW1_LEVEL	include/sys/pic.h	24;"	d
ICW1_SINGLE	include/sys/pic.h	22;"	d
ICW4_8086	include/sys/pic.h	27;"	d
ICW4_AUTO	include/sys/pic.h	28;"	d
ICW4_BUF_MASTER	include/sys/pic.h	30;"	d
ICW4_BUF_SLAVE	include/sys/pic.h	29;"	d
ICW4_SFNM	include/sys/pic.h	31;"	d
IDT_H_	include/sys/idt.h	9;"	d
INCLUDES	Makefile	/^INCLUDES:=$(shell find include\/ -type f -name \\*.h)$/;"	m
INITIAL_STACK_SIZE	sys/main.c	84;"	d	file:
INTERRUPT	sys/idt.c	6;"	d	file:
INTERRUPT	sys/isr.c	19;"	d	file:
INTERRUPTP_ERRORCODE	sys/isr.c	43;"	d	file:
INTERRUPT_NO_ERRORCODE	sys/isr.c	71;"	d	file:
IN_USE	libc/malloc.c	/^enum {FREE, IN_USE};$/;"	e	enum:__anon13	file:
IRQ0	include/sys/pic.h	35;"	d
IRQ1	include/sys/pic.h	36;"	d
IRQ2	include/sys/pic.h	37;"	d
IRQ3	include/sys/pic.h	38;"	d
IRQ4	include/sys/pic.h	39;"	d
ISR_H_	include/sys/isr.h	9;"	d
KADDR	include/sys/paging.h	70;"	d
KERNBASE	include/sys/paging.h	12;"	d
KERNEL_PROCESS	include/sys/process.h	/^KERNEL_PROCESS$/;"	e	enum:ProcType
KERN_SRCS	Makefile	/^KERN_SRCS:=$(shell find sys\/ -name \\*.c -o -name \\*.s)$/;"	m
KEYBOARD_H_	include/sys/keyboard.h	2;"	d
KO_CREAT	include/sys/tarfs.h	/^enum { KO_RDONLY = 0, KO_WRONLY = 1, KO_RDWR = 2, KO_CREAT = 0x40, KO_DIRECTORY = 0x10000 };$/;"	e	enum:__anon7
KO_DIRECTORY	include/sys/tarfs.h	/^enum { KO_RDONLY = 0, KO_WRONLY = 1, KO_RDWR = 2, KO_CREAT = 0x40, KO_DIRECTORY = 0x10000 };$/;"	e	enum:__anon7
KO_RDONLY	include/sys/tarfs.h	/^enum { KO_RDONLY = 0, KO_WRONLY = 1, KO_RDWR = 2, KO_CREAT = 0x40, KO_DIRECTORY = 0x10000 };$/;"	e	enum:__anon7
KO_RDWR	include/sys/tarfs.h	/^enum { KO_RDONLY = 0, KO_WRONLY = 1, KO_RDWR = 2, KO_CREAT = 0x40, KO_DIRECTORY = 0x10000 };$/;"	e	enum:__anon7
KO_WRONLY	include/sys/tarfs.h	/^enum { KO_RDONLY = 0, KO_WRONLY = 1, KO_RDWR = 2, KO_CREAT = 0x40, KO_DIRECTORY = 0x10000 };$/;"	e	enum:__anon7
KSEEK_CUR	include/sys/tarfs.h	/^enum { KSEEK_SET = 0, KSEEK_CUR = 1, KSEEK_END = 2 };$/;"	e	enum:__anon6
KSEEK_END	include/sys/tarfs.h	/^enum { KSEEK_SET = 0, KSEEK_CUR = 1, KSEEK_END = 2 };$/;"	e	enum:__anon6
KSEEK_SET	include/sys/tarfs.h	/^enum { KSEEK_SET = 0, KSEEK_CUR = 1, KSEEK_END = 2 };$/;"	e	enum:__anon6
K_CS	include/sys/gdt.h	18;"	d
K_DS	include/sys/gdt.h	19;"	d
K_NAME_MAX	include/sys/tarfs.h	38;"	d
K_dirent	include/sys/tarfs.h	/^struct K_dirent$/;"	s
K_timespec	include/sys/process.h	/^struct K_timespec$/;"	s
L	sys/gdt.c	16;"	d	file:
LD	Makefile	/^LD=ld $/;"	m
LDLAGS	Makefile	/^LDLAGS=-nostdlib$/;"	m
LIBC_SRCS	Makefile	/^LIBC_SRCS:=$(shell find libc\/ -name \\*.c -o -name \\*.s)$/;"	m
LOAD	include/sys/process.h	/^LOAD,$/;"	e	enum:SegType
LSHIFT	sys/keyboard.c	7;"	d	file:
MAXLINE	include/shell.h	12;"	d
MAX_CMD_LEN	include/parser.h	7;"	d
MAX_GDT	sys/gdt.c	5;"	d	file:
MAX_VAR_NUM	include/parser.h	4;"	d
MCB_P	libc/malloc.c	/^} MCB_t, *MCB_P;$/;"	t	typeref:struct:MCB_header_t	file:
MCB_header_t	libc/malloc.c	/^typedef struct MCB_header_t {$/;"	s	file:
MCB_t	libc/malloc.c	/^} MCB_t, *MCB_P;$/;"	t	typeref:struct:MCB_header_t	file:
METADATA_SIZE	include/memory.h	5;"	d
MMU_H	include/sys/mmu.h	2;"	d
NAME_MAX	include/stdlib.h	48;"	d
NEW_MCB	libc/malloc.c	/^enum {NEW_MCB, NO_MCB, REUSE_MCB};$/;"	e	enum:__anon12	file:
NO_MCB	libc/malloc.c	/^enum {NEW_MCB, NO_MCB, REUSE_MCB};$/;"	e	enum:__anon12	file:
NPDENTRIES	include/sys/mmu.h	57;"	d
NPDPENTRIES	include/sys/mmu.h	56;"	d
NPMLENTRIES	include/sys/mmu.h	55;"	d
NPROCS	include/sys/process.h	2;"	d
NPTENTRIES	include/sys/mmu.h	58;"	d
NULL	include/sys/defs.h	4;"	d
O_CREAT	include/stdlib.h	/^enum { O_RDONLY = 0, O_WRONLY = 1, O_RDWR = 2, O_CREAT = 0x40, O_DIRECTORY = 0x10000 };$/;"	e	enum:__anon10
O_DIRECTORY	include/stdlib.h	/^enum { O_RDONLY = 0, O_WRONLY = 1, O_RDWR = 2, O_CREAT = 0x40, O_DIRECTORY = 0x10000 };$/;"	e	enum:__anon10
O_RDONLY	include/stdlib.h	/^enum { O_RDONLY = 0, O_WRONLY = 1, O_RDWR = 2, O_CREAT = 0x40, O_DIRECTORY = 0x10000 };$/;"	e	enum:__anon10
O_RDWR	include/stdlib.h	/^enum { O_RDONLY = 0, O_WRONLY = 1, O_RDWR = 2, O_CREAT = 0x40, O_DIRECTORY = 0x10000 };$/;"	e	enum:__anon10
O_WRONLY	include/stdlib.h	/^enum { O_RDONLY = 0, O_WRONLY = 1, O_RDWR = 2, O_CREAT = 0x40, O_DIRECTORY = 0x10000 };$/;"	e	enum:__anon10
P	sys/gdt.c	15;"	d	file:
PADDR	include/sys/paging.h	60;"	d
PAGESIZE	libc/malloc.c	5;"	d	file:
PAGING_H_	include/sys/paging.h	9;"	d
PDPE	include/sys/mmu.h	44;"	d
PDPESHIFT	include/sys/mmu.h	68;"	d
PDX	include/sys/mmu.h	35;"	d
PDX	include/sys/mmu.h	45;"	d
PDXSHIFT	include/sys/mmu.h	67;"	d
PGADDR	include/sys/mmu.h	52;"	d
PGNUM	include/sys/mmu.h	32;"	d
PGOFF	include/sys/mmu.h	49;"	d
PGSHIFT	include/sys/mmu.h	61;"	d
PGSIZE	include/sys/mmu.h	60;"	d
PGSIZE	include/sys/paging.h	11;"	d
PHYSBASE	include/sys/paging.h	14;"	d
PHYSFREE	include/sys/paging.h	15;"	d
PIC1	include/sys/pic.h	12;"	d
PIC1_COMMAND	include/sys/pic.h	14;"	d
PIC1_DATA	include/sys/pic.h	15;"	d
PIC2	include/sys/pic.h	13;"	d
PIC2_COMMAND	include/sys/pic.h	16;"	d
PIC2_DATA	include/sys/pic.h	17;"	d
PIC_EOI	include/sys/pic.h	19;"	d
PIC_H_	include/sys/pic.h	9;"	d
PIC_remap	sys/pic.c	/^void PIC_remap(int offset1, int offset2)$/;"	f
PIC_sendEOI	sys/pic.c	/^void PIC_sendEOI(unsigned char irq)$/;"	f
PIPE_MAX_NUM	include/parser.h	5;"	d
PML4	include/sys/mmu.h	40;"	d
PML4SHIFT	include/sys/mmu.h	69;"	d
POPA	include/sys/process.h	99;"	d
POPA2	include/sys/utils.h	20;"	d
PORT_H_	include/sys/port.h	2;"	d
PPN	include/sys/mmu.h	30;"	d
PS1	bin/hello/shell.c	/^char PS1[200]="SBUSH";$/;"	v
PTE_A	include/sys/mmu.h	77;"	d
PTE_ADDR	include/sys/mmu.h	93;"	d
PTE_AVAIL	include/sys/mmu.h	84;"	d
PTE_COW	include/sys/mmu.h	81;"	d
PTE_D	include/sys/mmu.h	78;"	d
PTE_MBZ	include/sys/mmu.h	80;"	d
PTE_P	include/sys/mmu.h	72;"	d
PTE_PCD	include/sys/mmu.h	76;"	d
PTE_PS	include/sys/mmu.h	79;"	d
PTE_PWT	include/sys/mmu.h	75;"	d
PTE_SYSCALL	include/sys/mmu.h	87;"	d
PTE_U	include/sys/mmu.h	74;"	d
PTE_USER	include/sys/mmu.h	90;"	d
PTE_W	include/sys/mmu.h	73;"	d
PTSHIFT	include/sys/mmu.h	64;"	d
PTSIZE	include/sys/mmu.h	63;"	d
PTX	include/sys/mmu.h	43;"	d
PTXSHIFT	include/sys/mmu.h	66;"	d
PUSHA	include/sys/utils.h	1;"	d
PageStruct	include/sys/paging.h	/^typedef struct PageStruct {$/;"	s
PageStruct	include/sys/paging.h	/^}PageStruct;$/;"	t	typeref:struct:PageStruct
Pipe	include/sys/file_table.h	/^}Pipe;$/;"	t	typeref:struct:__anon8
ProcStatus	include/sys/process.h	/^enum ProcStatus{$/;"	g
ProcStruct	include/sys/process.h	/^typedef struct ProcStruct{$/;"	s
ProcStruct	include/sys/process.h	/^}ProcStruct;$/;"	t	typeref:struct:ProcStruct
ProcType	include/sys/process.h	/^enum ProcType$/;"	g
Proghdr	include/sys/elf.h	/^struct Proghdr {$/;"	s
REUSE_MCB	libc/malloc.c	/^enum {NEW_MCB, NO_MCB, REUSE_MCB};$/;"	e	enum:__anon12	file:
ROOTBIN	Makefile	/^ROOTBIN=$(ROOTFS)\/bin$/;"	m
ROOTBOOT	Makefile	/^ROOTBOOT=$(ROOTFS)\/boot$/;"	m
ROOTFS	Makefile	/^ROOTFS=rootfs$/;"	m
ROOTLIB	Makefile	/^ROOTLIB=$(ROOTFS)\/lib$/;"	m
ROUNDDOWN	include/sys/paging.h	77;"	d
ROUNDDOWN	include/sys/utils.h	38;"	d
ROUNDUP	include/sys/paging.h	84;"	d
ROUNDUP	include/sys/utils.h	44;"	d
RPL0	include/sys/gdt.h	23;"	d
RPL1	include/sys/gdt.h	24;"	d
RPL2	include/sys/gdt.h	25;"	d
RPL3	include/sys/gdt.h	26;"	d
RSHIFT	sys/keyboard.c	8;"	d	file:
RUNNABLE	include/sys/process.h	/^RUNNABLE,$/;"	e	enum:ProcStatus
RUNNING	include/sys/process.h	/^RUNNING,$/;"	e	enum:ProcStatus
SEEK_CUR	include/stdlib.h	/^enum { SEEK_SET = 0, SEEK_CUR = 1, SEEK_END = 2 };$/;"	e	enum:__anon11
SEEK_END	include/stdlib.h	/^enum { SEEK_SET = 0, SEEK_CUR = 1, SEEK_END = 2 };$/;"	e	enum:__anon11
SEEK_SET	include/stdlib.h	/^enum { SEEK_SET = 0, SEEK_CUR = 1, SEEK_END = 2 };$/;"	e	enum:__anon11
SHELL	Makefile	/^SHELL=\/bin\/sh$/;"	m
SHELL_H_	include/shell.h	9;"	d
STACK	include/sys/process.h	/^STACK,$/;"	e	enum:SegType
STRINGTOKENIZER_H_	include/stringtokenizer.h	2;"	d
STRING_H_	include/string.h	3;"	d
SUBMITTO	Makefile	/^SUBMITTO:=~mferdman\/cse506-submit\/$/;"	m
SYS_alarm	include/sys/syscall.h	12;"	d
SYS_brk	include/sys/syscall.h	5;"	d
SYS_chdir	include/sys/syscall.h	14;"	d
SYS_close	include/sys/syscall.h	19;"	d
SYS_dup	include/sys/syscall.h	21;"	d
SYS_dup2	include/sys/syscall.h	22;"	d
SYS_execve	include/sys/syscall.h	9;"	d
SYS_exit	include/sys/syscall.h	4;"	d
SYS_fork	include/sys/syscall.h	6;"	d
SYS_getcwd	include/sys/syscall.h	13;"	d
SYS_getdents	include/sys/syscall.h	23;"	d
SYS_getpid	include/sys/syscall.h	7;"	d
SYS_getppid	include/sys/syscall.h	8;"	d
SYS_lseek	include/sys/syscall.h	18;"	d
SYS_nanosleep	include/sys/syscall.h	11;"	d
SYS_open	include/sys/syscall.h	15;"	d
SYS_pipe	include/sys/syscall.h	20;"	d
SYS_ps	include/sys/syscall.h	24;"	d
SYS_read	include/sys/syscall.h	16;"	d
SYS_wait4	include/sys/syscall.h	10;"	d
SYS_write	include/sys/syscall.h	17;"	d
Secthdr	include/sys/elf.h	/^struct Secthdr {$/;"	s
SegType	include/sys/process.h	/^enum SegType{$/;"	g
TIMER_H_	include/sys/timer.h	9;"	d
TRAP_GATE	sys/idt.c	7;"	d	file:
TRUE	sys/keyboard.c	12;"	d	file:
TYPE_DIRECTORY	include/sys/file_table.h	4;"	d
TYPE_FILE	include/sys/file_table.h	3;"	d
TYPE_PIPE	include/sys/file_table.h	5;"	d
Token	include/stringTokenizer.h	/^}Token;$/;"	t	typeref:struct:__anon4
Token	include/stringtokenizer.h	/^} Token;$/;"	t	typeref:struct:__anon1
Trapframe	include/sys/idt.h	/^struct Trapframe {$/;"	s
USERSTACKTOP	include/sys/paging.h	22;"	d
USER_PROCESS	include/sys/process.h	/^USER_PROCESS=0,$/;"	e	enum:ProcType
U_CS	include/sys/gdt.h	20;"	d
U_DS	include/sys/gdt.h	21;"	d
VIDEO_START	include/sys/paging.h	21;"	d
VIDEO_START	include/sys/sbunix.h	4;"	d
VPD	include/sys/mmu.h	36;"	d
VPDPE	include/sys/mmu.h	37;"	d
VPML4E	include/sys/mmu.h	38;"	d
VPN	include/sys/mmu.h	31;"	d
VarList	include/parser.h	/^	char *VarList[MAX_VAR_NUM];$/;"	m	struct:__anon2
VarNum	include/parser.h	/^	int VarNum;$/;"	m	struct:__anon2
W	sys/gdt.c	18;"	d	file:
WAITING	include/sys/process.h	/^WAITING$/;"	e	enum:ProcStatus
_DEFS_H	include/sys/defs.h	2;"	d
_ERRNO_H	include/errno.h	2;"	d
_GDT_H	include/sys/gdt.h	2;"	d
_MEMORY_H	include/memory.h	2;"	d
_PARSER_H	include/parser.h	2;"	d
_STDARG_H	include/stdarg.h	2;"	d
_STDIO_H	include/stdio.h	2;"	d
_STDLIB_H	include/stdlib.h	2;"	d
_SYSCALL_H	include/syscall.h	2;"	d
_TARFS_H	include/sys/tarfs.h	2;"	d
__SBUNIX_H	include/sys/sbunix.h	2;"	d
__SYS_SYSCALL_H	include/sys/syscall.h	2;"	d
_start	crt/crt1.c	/^void _start(void) {$/;"	f
_x86_64_asm_lgdt	sys/gdt.s	/^_x86_64_asm_lgdt:$/;"	l
addr	sys/gdt.c	/^	uint64_t addr;$/;"	m	struct:gdtr_t	file:
addr	sys/idt.c	/^        uint64_t addr;$/;"	m	struct:idtr_t	file:
addr_hdr	include/sys/tarfs.h	/^    uint64_t addr_hdr;$/;"	m	struct:__anon5
address	include/sys/file_table.h	/^	uint64_t address; \/\/Only valid for pipe buffers and directories$/;"	m	struct:__anon8
alarm	libc/alarm.c	/^unsigned int alarm(unsigned int sec)$/;"	f
align4	include/memory.h	4;"	d
alloc_new	libc/malloc.c	/^void *alloc_new(int aligned_size)$/;"	f
allocate_page	sys/paging.c	/^PageStruct* allocate_page(){$/;"	f
allocate_proc_area	sys/process.c	/^int allocate_proc_area(ProcStruct* p, void* va, uint64_t size)$/;"	f
allocate_process	sys/process.c	/^ProcStruct* allocate_process(unsigned char parentid)$/;"	f
allocate_vma	sys/process.c	/^struct vma_struct* allocate_vma(mm_struct* mem)$/;"	f
allocated_mem	libc/malloc.c	/^static int allocated_mem; $/;"	v	file:
args	sys/process.c	/^char args[15][60];$/;"	v
binary	include/sys/process.h	/^uint64_t *binary;$/;"	m	struct:ProcStruct
block	include/memory.h	/^struct block{$/;"	s
blockPTR	include/memory.h	/^typedef struct block *blockPTR;$/;"	t	typeref:struct:block
boot	sys/main.c	/^void boot(void)$/;"	f
boot_alloc	sys/paging.c	/^boot_alloc(uint32_t n){$/;"	f	file:
boot_cr3	include/sys/paging.h	/^physaddr_t* boot_cr3;		\/\/ Physical address of boot time page directory$/;"	v
boot_pde	include/sys/paging.h	/^uint64_t *boot_pml4e,*boot_pdpe,*boot_pde, *boot_pte;		\/\/ Kernel's initial page directory$/;"	v
boot_pdpe	include/sys/paging.h	/^uint64_t *boot_pml4e,*boot_pdpe,*boot_pde, *boot_pte;		\/\/ Kernel's initial page directory$/;"	v
boot_pml4e	include/sys/paging.h	/^uint64_t *boot_pml4e,*boot_pdpe,*boot_pde, *boot_pte;		\/\/ Kernel's initial page directory$/;"	v
boot_pte	include/sys/paging.h	/^uint64_t *boot_pml4e,*boot_pdpe,*boot_pde, *boot_pte;		\/\/ Kernel's initial page directory$/;"	v
callq	bin/hello/tp.s	/^callq main$/;"	l
capslock	sys/keyboard.c	/^unsigned char capslock = FALSE;$/;"	v
cat	libc/cat.c	/^void cat(char* filename){$/;"	f
cd	libc/testCases.c	/^void cd(char *path){$/;"	f
changePS1	bin/hello/PS1.c	/^void changePS1(char*str){$/;"	f
changedir	bin/hello/cd.c	/^void changedir(char* path){$/;"	f
chdir	libc/chdir.c	/^int chdir(const char *path){$/;"	f
checksum	include/sys/tarfs.h	/^	char checksum[8];$/;"	m	struct:posix_header_ustar
close	include/sys/file_table.h	/^	int (*close)(); \/\/pointer to the device specific close call$/;"	m	struct:__anon9
close	libc/close.c	/^int close(int fd)$/;"	f
close_file	sys/tarfs.c	/^int close_file(int file_table_index){$/;"	f
closedir	libc/closedir.c	/^int closedir(void *dir){$/;"	f
colour	sys/printf.c	7;"	d	file:
commandName	include/parser.h	/^	char *commandName;$/;"	m	struct:__anon2
convert_to_absolute_path_dir	sys/tarfs.c	/^void convert_to_absolute_path_dir(const char* path,char* absPath){$/;"	f
convert_to_absolute_path_file	sys/tarfs.c	/^void convert_to_absolute_path_file(const char* path,char* absPath){$/;"	f
copy_args_to_stack	sys/process.c	/^int copy_args_to_stack(uint64_t stacktop,int argc)$/;"	f
copypagetables	sys/process.c	/^int copypagetables(ProcStruct *proc)$/;"	f
copyvmas	sys/process.c	/^int copyvmas(ProcStruct *proc)$/;"	f
count	include/sys/process.h	/^    int count;$/;"	m	struct:mm_struct
cpu_lidt	sys/idt.c	/^static inline void cpu_lidt(void* idt) {$/;"	f	file:
cr3	include/sys/process.h	/^physaddr_t* cr3;$/;"	m	struct:ProcStruct
create_process	sys/process.c	/^ProcStruct* create_process(uint64_t* binary, enum ProcType type)$/;"	f
cs	include/sys/isr.h	/^    uint64_t cs;$/;"	m	struct:faultStruct
ctrl	sys/keyboard.c	/^unsigned char ctrl = FALSE;$/;"	v
curproc	include/sys/process.h	/^ProcStruct* proc_free_list,*proc_running_list,*curproc;$/;"	v
cursor	include/sys/file_table.h	/^	uint64_t cursor; \/\/current cursor position$/;"	m	struct:__anon9
cwd	include/sys/process.h	/^char cwd[50]; \/\/store the current working directory of a process$/;"	m	struct:ProcStruct
d_ino	include/stdlib.h	/^	long d_ino;$/;"	m	struct:dirent
d_ino	include/sys/tarfs.h	/^	long d_ino;$/;"	m	struct:K_dirent
d_name	include/stdlib.h	/^	char d_name [NAME_MAX+1];$/;"	m	struct:dirent
d_name	include/sys/tarfs.h	/^	char d_name [K_NAME_MAX+1];$/;"	m	struct:K_dirent
d_off	include/stdlib.h	/^	off_t d_off;$/;"	m	struct:dirent
d_off	include/sys/tarfs.h	/^	uint64_t d_off;$/;"	m	struct:K_dirent
d_reclen	include/stdlib.h	/^	unsigned short d_reclen;$/;"	m	struct:dirent
d_reclen	include/sys/tarfs.h	/^	unsigned short d_reclen;$/;"	m	struct:K_dirent
data	include/memory.h	/^	char data[1];$/;"	m	struct:block
devmajor	include/sys/tarfs.h	/^	char devmajor[8];$/;"	m	struct:posix_header_ustar
devminor	include/sys/tarfs.h	/^	char devminor[8];$/;"	m	struct:posix_header_ustar
directroy_test_case	libc/testCases.c	/^void directroy_test_case(){$/;"	f
dirent	include/stdlib.h	/^struct dirent$/;"	s
dpl	sys/idt.c	/^    unsigned dpl : 2;$/;"	m	struct:idt_t	file:
dup	libc/dup.c	/^int dup(int oldfd)$/;"	f
dup2	libc/dup2.c	/^int dup2(int oldfd, int newfd)$/;"	f
dup2	sys/pipe.c	/^int dup2(int oldfd, int newfd){$/;"	f
dup2_test_case	libc/testCases.c	/^void dup2_test_case(){$/;"	f
duplicateFD	include/sys/file_table.h	/^	int duplicateFD;$/;"	m	struct:__anon8
e_ehsize	include/sys/elf.h	/^	uint16_t e_ehsize;$/;"	m	struct:Elf
e_elf	include/sys/elf.h	/^	unsigned char e_elf[12];$/;"	m	struct:Elf
e_entry	include/sys/elf.h	/^	uint64_t e_entry;$/;"	m	struct:Elf
e_flags	include/sys/elf.h	/^	uint32_t e_flags;$/;"	m	struct:Elf
e_machine	include/sys/elf.h	/^	uint16_t e_machine;$/;"	m	struct:Elf
e_magic	include/sys/elf.h	/^	uint32_t e_magic;	\/\/ must equal ELF_MAGIC$/;"	m	struct:Elf
e_phentsize	include/sys/elf.h	/^	uint16_t e_phentsize;$/;"	m	struct:Elf
e_phnum	include/sys/elf.h	/^	uint16_t e_phnum;$/;"	m	struct:Elf
e_phoff	include/sys/elf.h	/^	uint64_t e_phoff;$/;"	m	struct:Elf
e_shentsize	include/sys/elf.h	/^	uint16_t e_shentsize;$/;"	m	struct:Elf
e_shnum	include/sys/elf.h	/^	uint16_t e_shnum;$/;"	m	struct:Elf
e_shoff	include/sys/elf.h	/^	uint64_t e_shoff;$/;"	m	struct:Elf
e_shstrndx	include/sys/elf.h	/^	uint16_t e_shstrndx;$/;"	m	struct:Elf
e_type	include/sys/elf.h	/^	uint16_t e_type;$/;"	m	struct:Elf
e_version	include/sys/elf.h	/^	uint32_t e_version;$/;"	m	struct:Elf
elf	include/sys/process.h	/^uint64_t *elf;$/;"	m	struct:ProcStruct
end_brk	include/sys/process.h	/^    uint64_t end_brk,start_brk;$/;"	m	struct:mm_struct
enter_pressed	sys/keyboard.c	/^volatile int enter_pressed = 0; \/\/A flag that indicates whetehr user finished pressing keys$/;"	v
env_pop_tf	sys/process.c	/^void env_pop_tf(struct Trapframe *tf1)$/;"	f
errno	include/errno.h	/^ int errno;$/;"	v
errno	sys/main.c	/^int errno = 0;$/;"	v
errorCode	include/sys/isr.h	/^    uint64_t errorCode;$/;"	m	struct:faultStruct
executeBuiltins	bin/hello/executeBuiltins.c	/^void executeBuiltins(parseInfo* command,char*envp[]){$/;"	f
execute_cmd	bin/hello/execute.c	/^void execute_cmd(parseInfo * info,char*envp[])$/;"	f
execve	libc/execve.c	/^int execve(const char *filename, char *const argv[], char *const envp[])$/;"	f
execve	sys/process.c	/^uint64_t execve(const char *arg1,const char *arg2[],const  char* arg3[])$/;"	f
exit	libc/exit.c	/^void exit(int status){$/;"	f
faultFrame	include/sys/isr.h	/^typedef struct faultStruct faultFrame;$/;"	t	typeref:struct:faultStruct
faultStruct	include/sys/isr.h	/^struct faultStruct {$/;"	s
fd_table	include/sys/process.h	/^int fd_table[10];  \/\/per process file descriptor array$/;"	m	struct:ProcStruct
fileTable_entry	include/sys/file_table.h	/^} fileTable_entry;$/;"	t	typeref:struct:__anon9
file_read_test_case	libc/testCases.c	/^void file_read_test_case(){$/;"	f
file_table	sys/tarfs.c	/^fileTable_entry file_table[10];$/;"	v
filesz	include/sys/process.h	/^uint64_t filesz;$/;"	m	struct:vma_struct
findBinaryFullPath	bin/hello/findBinaryFullPath.c	/^char* findBinaryFullPath(char* srchPath,char* binaryName){$/;"	f
findEnvVar	bin/hello/getEnvironmentVarLoc.c	/^char** findEnvVar(char* envVar, char* envp[]){$/;"	f
find_file_in_dir	bin/hello/findBinaryFullPath.c	/^char* find_file_in_dir (char *path, char *file)$/;"	f
fork	libc/fork.c	/^pid_t fork()$/;"	f
fork_process	sys/process.c	/^int fork_process(struct Trapframe* tf)$/;"	f
fork_test_case	libc/testCases.c	/^void fork_test_case(){$/;"	f
free	include/memory.h	/^	int free;$/;"	m	struct:block
free	libc/malloc.c	/^void free(void *p)$/;"	f
free_info	bin/hello/parser.c	/^void free_info (parseInfo *info) {$/;"	f
free_pages	sys/paging.c	/^int free_pages=1;$/;"	v
gdt	sys/gdt.c	/^uint64_t gdt[MAX_GDT] = {$/;"	v
gdtr	sys/gdt.c	/^static struct gdtr_t gdtr = {$/;"	v	typeref:struct:gdtr_t	file:
gdtr_t	sys/gdt.c	/^struct gdtr_t {$/;"	s	file:
get_per_ind	sys/tarfs.c	/^int get_per_ind(char* dir){$/;"	f
get_per_ind_file	sys/tarfs.c	/^int get_per_ind_file(char* dir){$/;"	f
get_running_process	sys/process.c	/^int get_running_process(){$/;"	f
getcwd	libc/getcwd.c	/^char* getcwd(char *buf, size_t size){$/;"	f
getnewprocess	sys/process.c	/^ProcStruct *getnewprocess()$/;"	f
getpid	libc/process.c	/^pid_t getpid()$/;"	f
getppid	libc/process.c	/^pid_t getppid()$/;"	f
gid	include/sys/tarfs.h	/^	char gid[8];$/;"	m	struct:posix_header_ustar
gname	include/sys/tarfs.h	/^	char gname[32];$/;"	m	struct:posix_header_ustar
heap_end	libc/malloc.c	/^static char *heap_end;$/;"	v	file:
idt_entries	sys/idt.c	/^idt_t idt_entries[256];$/;"	v
idt_ptr	sys/idt.c	/^idtr_t   idt_ptr;$/;"	v
idt_set_gate	sys/idt.c	/^void idt_set_gate(uint16_t num, uint64_t isrAddr, uint16_t selector,uint16_t dpl,uint16_t type, uint16_t ist){$/;"	f
idt_t	sys/idt.c	/^struct idt_t {$/;"	s	file:
idt_t	sys/idt.c	/^typedef struct idt_t idt_t;$/;"	t	typeref:struct:idt_t	file:
idtr_t	sys/idt.c	/^struct idtr_t {$/;"	s	file:
idtr_t	sys/idt.c	/^typedef struct idtr_t idtr_t;$/;"	t	typeref:struct:idtr_t	file:
inb	include/sys/port.h	/^static inline uint16_t inb(uint16_t port)$/;"	f
inc_brk	sys/process.c	/^uint64_t inc_brk(uint64_t n)$/;"	f
init_PIT	sys/timer.c	/^void init_PIT(uint16_t frequency){$/;"	f
init_idt	sys/idt.c	/^void init_idt()$/;"	f
initialize_page_lists	sys/paging.c	/^void initialize_page_lists(){$/;"	f
initialize_process	sys/process.c	/^void initialize_process()$/;"	f
initialize_vm_64	sys/paging.c	/^void initialize_vm_64(void){$/;"	f
inode	newfs/newfs.c	/^struct inode {$/;"	s	file:
inode_num	include/sys/file_table.h	/^	int inode_num; \/\/the entry in the tarfs table$/;"	m	struct:__anon9
int	bin/hello/tp.s	/^int $80$/;"	l
int16_t	include/sys/defs.h	/^typedef          short  int16_t;$/;"	t
int32_t	include/sys/defs.h	/^typedef          int    int32_t;$/;"	t
int64_t	include/sys/defs.h	/^typedef          long   int64_t;$/;"	t
invlpg	include/sys/paging.h	/^invlpg(void *addr)                             {                                               __asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");         $/;"	f
io_wait	include/sys/port.h	/^static inline void io_wait(void)$/;"	f
is_available	libc/malloc.c	/^    int is_available;$/;"	m	struct:MCB_header_t	file:
isr0_handler	sys/isr.c	/^void isr0_handler(){$/;"	f
isr11_handler	sys/isr.c	/^void isr11_handler(){$/;"	f
isr128_handler	sys/isr.c	/^void isr128_handler(struct Trapframe* tf){$/;"	f
isr12_handler	sys/isr.c	/^void isr12_handler(){$/;"	f
isr13_handler	sys/isr.c	/^void isr13_handler(){$/;"	f
isr14_handler	sys/isr.c	/^void isr14_handler(struct faultStruct *faultFrame)$/;"	f
isr17_handler	sys/isr.c	/^void isr17_handler(){$/;"	f
isr32_handler	sys/isr.c	/^void isr32_handler(struct Trapframe *tf){$/;"	f
isr33_handler	sys/isr.c	/^void isr33_handler(){$/;"	f
isr4_handler	sys/isr.c	/^void isr4_handler(){$/;"	f
isr5_handler	sys/isr.c	/^void isr5_handler(){$/;"	f
isr6_handler	sys/isr.c	/^void isr6_handler(){$/;"	f
isr8_handler	sys/isr.c	/^void isr8_handler(){$/;"	f
ist	sys/idt.c	/^    unsigned ist : 3 ;$/;"	m	struct:idt_t	file:
k	bin/tabz/tab.c	/^int k=0;$/;"	v
k	libc/testCases.c	/^int k=0;$/;"	v
kchdir	sys/tarfs.c	/^int kchdir(char* directoryPath){$/;"	f
kclose	sys/tarfs.c	/^int kclose(int fd){$/;"	f
keyboard_buffer	sys/keyboard.c	/^char keyboard_buffer[100]; \/\/To be used to hold the pressed keys till user presses ENTER$/;"	v
keyboard_init	sys/keyboard.c	/^void keyboard_init()$/;"	f
keyboard_read	sys/keyboard.c	/^void keyboard_read()$/;"	f
keymap	sys/keyboard.c	/^char keymap[256];$/;"	v
keymap_upper	sys/keyboard.c	/^char keymap_upper[256];$/;"	v
kgetcwd	sys/tarfs.c	/^void kgetcwd(char* buff){$/;"	f
klseek	sys/tarfs.c	/^uint64_t klseek(int fd, uint64_t offset, int whence){$/;"	f
kmemcpy	sys/utils.c	/^void kmemcpy(void* dst, void* src , uint64_t size)$/;"	f
kmemset	sys/utils.c	/^void kmemset(void* start, int x, size_t size){$/;"	f
kopen	sys/tarfs.c	/^int kopen(const char* name){$/;"	f
kopendir	sys/tarfs.c	/^uint64_t kopendir(const char *name){$/;"	f
kprintf	sys/printf.c	/^void kprintf(char* buff,int len){$/;"	f
kread	sys/tarfs.c	/^int kread(int fd,char* buf, int numBytesToRead){$/;"	f
kreaddir	sys/tarfs.c	/^int kreaddir(void *dir,char* userBuff){$/;"	f
kscanf	sys/keyboard.c	/^uint64_t kscanf(char* buff){$/;"	f
kstack	include/sys/process.h	/^uint64_t kstack[512];$/;"	m	struct:ProcStruct
kstrcat	sys/kstring.c	/^char *kstrcat(char *dst, const char *src)$/;"	f
kstrcmp	sys/kstring.c	/^int kstrcmp(const char *str1, const char *str2)$/;"	f
kstrcpy	sys/kstring.c	/^char* kstrcpy(char* dst, const char* src)$/;"	f
kstrlen	sys/kstring.c	/^int kstrlen(const char *str)$/;"	f
kstrstr	sys/kstring.c	/^const char *kstrstr(const char *haystack, const char *needle)$/;"	f
kwrite	sys/tarfs.c	/^int kwrite(int fd,char* buf, int numBytesToWrite){$/;"	f
lcr3	include/sys/paging.h	/^lcr3(uint64_t* val)$/;"	f
length_of_command	sys/keyboard.c	/^int length_of_command = 0;$/;"	v
linkname	include/sys/tarfs.h	/^	char linkname[100];$/;"	m	struct:posix_header_ustar
load_elf	sys/process.c	/^int load_elf(ProcStruct *e,uint64_t* binary)$/;"	f
loader_stack	sys/main.c	/^uint32_t* loader_stack;$/;"	v
ls	libc/testCases.c	/^void ls(){$/;"	f
lseek	libc/lseek.c	/^off_t lseek(int fildes, off_t offset, int whence)$/;"	f
ltr	include/sys/paging.h	/^ltr(uint16_t sel)$/;"	f
magic	include/memory.h	/^	int magic;$/;"	m	struct:block
magic	include/sys/tarfs.h	/^	char magic[6];$/;"	m	struct:posix_header_ustar
magic	newfs/newfs.c	/^	uint32_t magic;$/;"	m	struct:superblock	file:
main	bin/asd/asd.c	/^int main()$/;"	f
main	bin/hello/shell.c	/^int main (int argc, char *argv[], char* envp[])$/;"	f
main	bin/hello/tp.s	/^main:$/;"	l
main	bin/init/init.c	/^int main()$/;"	f
main	bin/malluaunty/tp.c	/^int main(int argc, char* argv[], char* envp[])$/;"	f
main	bin/tabz/tab.c	/^int main()$/;"	f
main	newfs/newfs.c	/^int main(int argc, char* argv[]) {$/;"	f
main1	bin/hello/hello.c	/^int main1(int argc, char* argv[], char* envp[]) {$/;"	f
main11	bin/hello/shell1.c	/^int main11(int argc, char* argv[], char* envp[])$/;"	f
main2	bin/hello/temp.c	/^int main2 (int argc, char *argv[], char* envp[])$/;"	f
make_head	libc/malloc.c	/^void make_head(char *addr, int size) $/;"	f
malloc	libc/malloc.c	/^void* malloc(size_t elem_size)$/;"	f
map_vm_pm	sys/paging.c	/^uint16_t  map_vm_pm(pml4e_t* pml4e, uint64_t va,uint64_t pa,uint64_t size, uint16_t perm)$/;"	f
max_mem	libc/malloc.c	/^static int max_mem;$/;"	v	file:
maxcount	sys/process.c	/^int maxcount=0;$/;"	v
mcb_count	libc/malloc.c	/^static int mcb_count;$/;"	v	file:
mem_start_p	libc/malloc.c	/^static char *mem_start_p;$/;"	v	file:
mm	include/sys/process.h	/^struct mm_struct *mm;$/;"	m	struct:ProcStruct	typeref:struct:ProcStruct::mm_struct
mm_struct	include/sys/process.h	/^typedef struct mm_struct {$/;"	s
mm_struct	include/sys/process.h	/^}mm_struct;$/;"	t	typeref:struct:mm_struct
mmap	include/sys/process.h	/^    struct vma_struct * mmap;$/;"	m	struct:mm_struct	typeref:struct:mm_struct::vma_struct
mmap_avl	include/sys/process.h	/^    struct vma_struct * mmap_avl;$/;"	m	struct:mm_struct	typeref:struct:mm_struct::vma_struct
mode	include/sys/tarfs.h	/^	char mode[8];$/;"	m	struct:posix_header_ustar
mov	bin/hello/tp.s	/^mov  %eax, 1$/;"	l
mov	bin/hello/tp.s	/^mov  %eax, 2$/;"	l
mov	bin/hello/tp.s	/^mov  %eax, 3$/;"	l
mtime	include/sys/tarfs.h	/^	char mtime[12];$/;"	m	struct:posix_header_ustar
name	include/sys/tarfs.h	/^	char name[100];$/;"	m	struct:posix_header_ustar
name	include/sys/tarfs.h	/^    char name[100];$/;"	m	struct:__anon5
next	include/memory.h	/^	struct block* next;$/;"	m	struct:block	typeref:struct:block::block
next	include/sys/paging.h	/^        struct PageStruct *next;$/;"	m	struct:PageStruct	typeref:struct:PageStruct::PageStruct
next	include/sys/process.h	/^struct ProcStruct* next;$/;"	m	struct:ProcStruct	typeref:struct:ProcStruct::ProcStruct
nextfree	sys/paging.c	/^static char* nextfree;$/;"	v	file:
npages	include/sys/paging.h	/^uint64_t npages;$/;"	v
numOfEntries	sys/tarfs.c	/^int numOfEntries = 1; \/\/index into the tarfs table..after tarfs_init() it has the total number of entries in FS$/;"	v
numOfTokens	include/stringTokenizer.h	/^	int numOfTokens;$/;"	m	struct:__anon4
numOfTokens	include/stringtokenizer.h	/^	int numOfTokens;$/;"	m	struct:__anon1
num_child	include/sys/process.h	/^int num_child;$/;"	m	struct:ProcStruct
octalToDecimal	sys/utils.c	/^uint64_t octalToDecimal(uint64_t octal)$/;"	f
off_t	include/stdlib.h	/^typedef uint64_t off_t;$/;"	t
offset_0_15	sys/idt.c	/^    uint16_t offset_0_15;$/;"	m	struct:idt_t	file:
offset_16_31	sys/idt.c	/^    uint16_t offset_16_31;$/;"	m	struct:idt_t	file:
offset_63_32	sys/idt.c	/^    uint32_t offset_63_32;$/;"	m	struct:idt_t	file:
onlyWhiteSpace	bin/hello/stringTokenizer.c	/^int onlyWhiteSpace(char *str){$/;"	f
open	libc/open.c	/^int open(const char *pathname, int flags)$/;"	f
opendir	libc/opendir.c	/^void *opendir(const char *name)$/;"	f
outb	include/sys/port.h	/^static inline void outb(uint16_t port, unsigned char val)$/;"	f
p	sys/idt.c	/^    unsigned p : 1;$/;"	m	struct:idt_t	file:
p_align	include/sys/elf.h	/^	uint64_t p_align;$/;"	m	struct:Proghdr
p_filesz	include/sys/elf.h	/^	uint64_t p_filesz;$/;"	m	struct:Proghdr
p_flags	include/sys/elf.h	/^    uint32_t p_flags;$/;"	m	struct:Proghdr
p_memsz	include/sys/elf.h	/^	uint64_t p_memsz;$/;"	m	struct:Proghdr
p_offset	include/sys/elf.h	/^	uint64_t p_offset;$/;"	m	struct:Proghdr
p_pa	include/sys/elf.h	/^	uint64_t p_pa;$/;"	m	struct:Proghdr
p_type	include/sys/elf.h	/^	uint32_t p_type;$/;"	m	struct:Proghdr
p_va	include/sys/elf.h	/^	uint64_t p_va;$/;"	m	struct:Proghdr
pad	include/sys/tarfs.h	/^	char pad[12];$/;"	m	struct:posix_header_ustar
pageToPhysicalAddress	sys/paging.c	/^uint64_t* pageToPhysicalAddress(PageStruct* page){$/;"	f
page_free_list	sys/paging.c	/^static struct PageStruct *page_free_list;	\/\/ Free list of physical pages. page_free_list is the head of the free list$/;"	v	typeref:struct:PageStruct	file:
pages	sys/paging.c	/^struct PageStruct *pages;$/;"	v	typeref:struct:PageStruct
par_ind	include/sys/tarfs.h	/^    int par_ind;$/;"	m	struct:__anon5
parallel_fork	bin/hello/shell1.c	/^void parallel_fork(){$/;"	f
parent_id	include/sys/process.h	/^unsigned char parent_id;$/;"	m	struct:ProcStruct
parseInfo	include/parser.h	/^} parseInfo;$/;"	t	typeref:struct:__anon3
parseModified	bin/hello/parser.c	/^parseInfo* parseModified(char *cmd,char* envp[]){$/;"	f
pde_t	include/sys/defs.h	/^typedef uint64_t pde_t;$/;"	t
pdpe_t	include/sys/defs.h	/^typedef uint64_t pdpe_t;$/;"	t
physaddr_t	include/sys/defs.h	/^typedef uint64_t physaddr_t;$/;"	t
physicalAddressToPage	sys/paging.c	/^PageStruct * physicalAddressToPage(uint64_t *addr){$/;"	f
pid_t	include/stdlib.h	/^typedef uint32_t pid_t;$/;"	t
pipe	include/sys/file_table.h	/^	Pipe pipe; \/\/$/;"	m	struct:__anon9
pipe	libc/pipe.c	/^int pipe(int fd[2])$/;"	f
pipe	sys/pipe.c	/^int pipe(int *pipefd){$/;"	f
pipeNum	include/parser.h	/^	int   pipeNum;$/;"	m	struct:__anon3
pipe_close	sys/pipe.c	/^int pipe_close(int fd){$/;"	f
pipe_read	sys/pipe.c	/^int pipe_read(int file_table_index,char* buf, int numBytesToRead){$/;"	f
pipe_write	sys/pipe.c	/^int pipe_write(int file_table_index,char *buf,int numBytesToWrite){$/;"	f
pml4e	include/sys/process.h	/^uint64_t* pml4e;$/;"	m	struct:ProcStruct
pml4e_t	include/sys/defs.h	/^typedef uint64_t pml4e_t;$/;"	t
posix_header_ustar	include/sys/tarfs.h	/^struct posix_header_ustar {$/;"	s
power	sys/utils.c	/^uint64_t power(uint64_t x, int e) {$/;"	f
prefix	include/sys/tarfs.h	/^	char prefix[155];$/;"	m	struct:posix_header_ustar
present	include/sys/file_table.h	/^	int present; \/\/indicates if this entry is valid or not 0->free 1->present$/;"	m	struct:__anon9
prev	include/memory.h	/^	struct block* prev;$/;"	m	struct:block	typeref:struct:block::block
print_info	bin/hello/parser.c	/^void print_info (parseInfo *info) {$/;"	f
print_keyboard_buff	sys/keyboard.c	/^void print_keyboard_buff(){$/;"	f
print_num	libc/printf.c	/^void print_num(int num, int base)$/;"	f
print_num	sys/printf.c	/^void print_num(int num, int base)$/;"	f
print_ptr	libc/printf.c	/^void print_ptr(long unsigned int num, long unsigned int base)$/;"	f
print_ptr	sys/printf.c	/^void print_ptr(long unsigned int num, long unsigned int base)$/;"	f
print_time	sys/timer.c	/^void print_time(long int cur_tick,volatile char *pos)$/;"	f
printf	libc/printf.c	/^int printf(const char *format, ...) {$/;"	f
printf	sys/printf.c	/^void printf(const char *format, ...) {$/;"	f
proc_binary2	sys/main.c	/^uint64_t* proc_binary2=0;$/;"	v
proc_free	sys/process.c	/^int proc_free(ProcStruct *proc)$/;"	f
proc_free_list	include/sys/process.h	/^ProcStruct* proc_free_list,*proc_running_list,*curproc;$/;"	v
proc_id	include/sys/process.h	/^unsigned char proc_id;$/;"	m	struct:ProcStruct
proc_run	sys/process.c	/^proc_run(struct ProcStruct *proc)$/;"	f
proc_running_list	include/sys/process.h	/^ProcStruct* proc_free_list,*proc_running_list,*curproc;$/;"	v
proc_sleep	sys/process.c	/^int proc_sleep(void* t){$/;"	f
proccount	sys/process.c	/^uint16_t proccount=0;$/;"	v
procs	include/sys/process.h	/^ProcStruct* procs; $/;"	v
ps	libc/ps.c	/^int ps(){$/;"	f
pt	include/sys/process.h	/^    uint64_t * pt; \/\/ page table pointer  $/;"	m	struct:mm_struct
pte_t	include/sys/defs.h	/^typedef uint64_t pte_t;$/;"	t
read	include/sys/file_table.h	/^	int (*read)(); \/\/pointer to the device specific read call$/;"	m	struct:__anon9
read	libc/read.c	/^ssize_t read(int fd, void *buf, size_t count){$/;"	f
read_cr2_register	sys/isr.c	/^uint64_t read_cr2_register(){$/;"	f
read_cursor	include/sys/file_table.h	/^	uint64_t read_cursor;$/;"	m	struct:__anon8
read_file	sys/tarfs.c	/^int read_file(int file_table_index,char *buf,int numBytesToRead){$/;"	f
read_line	bin/hello/parser.c	/^int read_line(int fd, char* buf)$/;"	f
read_line	libc/testCases.c	/^void read_line(int fd, char* buf)$/;"	f
readdir	libc/readdir.c	/^struct dirent* readdir(void *dir){$/;"	f
readers	include/sys/file_table.h	/^	int readers;$/;"	m	struct:__anon8
ref_count	include/sys/file_table.h	/^	int ref_count; \/\/number of processes which have this file open$/;"	m	struct:__anon9
ref_count	include/sys/paging.h	/^	uint16_t ref_count;$/;"	m	struct:PageStruct
refcount	newfs/newfs.c	/^	uint64_t refcount;$/;"	m	struct:inode	file:
reg_r10	include/sys/idt.h	/^    uint64_t reg_r10;$/;"	m	struct:GpRegs
reg_r11	include/sys/idt.h	/^    uint64_t reg_r11;$/;"	m	struct:GpRegs
reg_r12	include/sys/idt.h	/^    uint64_t reg_r12;$/;"	m	struct:GpRegs
reg_r13	include/sys/idt.h	/^    uint64_t reg_r13;$/;"	m	struct:GpRegs
reg_r14	include/sys/idt.h	/^    uint64_t reg_r14;$/;"	m	struct:GpRegs
reg_r15	include/sys/idt.h	/^    uint64_t reg_r15;$/;"	m	struct:GpRegs
reg_r8	include/sys/idt.h	/^    uint64_t reg_r8;$/;"	m	struct:GpRegs
reg_r9	include/sys/idt.h	/^    uint64_t reg_r9;$/;"	m	struct:GpRegs
reg_rax	include/sys/idt.h	/^	uint64_t reg_rax;$/;"	m	struct:GpRegs
reg_rbp	include/sys/idt.h	/^	uint64_t reg_rbp;$/;"	m	struct:GpRegs
reg_rbx	include/sys/idt.h	/^	uint64_t reg_rbx;$/;"	m	struct:GpRegs
reg_rcx	include/sys/idt.h	/^	uint64_t reg_rcx;$/;"	m	struct:GpRegs
reg_rdi	include/sys/idt.h	/^	uint64_t reg_rdi;$/;"	m	struct:GpRegs
reg_rdx	include/sys/idt.h	/^	uint64_t reg_rdx;$/;"	m	struct:GpRegs
reg_rsi	include/sys/idt.h	/^	uint64_t reg_rsi;$/;"	m	struct:GpRegs
reload_gdt	sys/gdt.c	/^void reload_gdt() {$/;"	f
removeSpaces	bin/hello/removeSpaces.c	/^char* removeSpaces(char*str){$/;"	f
remove_page	sys/paging.c	/^int remove_page(uint64_t* pa)$/;"	f
reserved	include/sys/gdt.h	/^	uint32_t reserved;$/;"	m	struct:tss_t
reserved0	sys/idt.c	/^    unsigned reserved0 : 5;$/;"	m	struct:idt_t	file:
reserved1	sys/idt.c	/^    uint32_t reserved1;$/;"	m	struct:idt_t	file:
rflags	include/sys/isr.h	/^    uint64_t rflags;$/;"	m	struct:faultStruct
rip	include/sys/isr.h	/^    uint64_t rip;$/;"	m	struct:faultStruct
rsp	include/sys/isr.h	/^    uint64_t rsp;$/;"	m	struct:faultStruct
rsp0	include/sys/gdt.h	/^	uint64_t rsp0;$/;"	m	struct:tss_t
scan_hex	libc/scanf.c	/^int scan_hex(int* num)$/;"	f
scan_num	libc/scanf.c	/^int scan_num(int* num)$/;"	f
scan_ret	libc/scanf.c	/^int scan_ret=0;$/;"	v
scanf	libc/scanf.c	/^int scanf(const char *format, ...) {$/;"	f
scheduler	sys/process.c	/^int scheduler()$/;"	f
screen	libc/printf.c	/^char screen[1024];$/;"	v
screen	sys/printf.c	/^char screen[1024];$/;"	v
screen_ctr	libc/printf.c	/^int screen_ctr;$/;"	v
screen_ctr	sys/printf.c	/^int screen_ctr;$/;"	v
sd_dpl	sys/gdt.c	/^	uint64_t sd_dpl:2;     \/* segment descriptor priority level *\/$/;"	m	struct:sys_segment_descriptor	file:
sd_gran	sys/gdt.c	/^	uint64_t sd_gran:1;    \/* limit granularity (byte\/page) *\/$/;"	m	struct:sys_segment_descriptor	file:
sd_hibase	sys/gdt.c	/^	uint64_t sd_hibase:40; \/* segment base address (msb) *\/$/;"	m	struct:sys_segment_descriptor	file:
sd_hilimit	sys/gdt.c	/^	uint64_t sd_hilimit:4; \/* segment extent (msb) *\/$/;"	m	struct:sys_segment_descriptor	file:
sd_lobase	sys/gdt.c	/^	uint64_t sd_lobase:24; \/* segment base address (lsb) *\/$/;"	m	struct:sys_segment_descriptor	file:
sd_lolimit	sys/gdt.c	/^	uint64_t sd_lolimit:16;\/* segment extent (lsb) *\/$/;"	m	struct:sys_segment_descriptor	file:
sd_p	sys/gdt.c	/^	uint64_t sd_p:1;       \/* segment descriptor present *\/$/;"	m	struct:sys_segment_descriptor	file:
sd_type	sys/gdt.c	/^	uint64_t sd_type:5;    \/* segment type *\/$/;"	m	struct:sys_segment_descriptor	file:
sd_xx1	sys/gdt.c	/^	uint64_t sd_xx1:3;     \/* avl, long and def32 (not used) *\/$/;"	m	struct:sys_segment_descriptor	file:
sd_xx2	sys/gdt.c	/^	uint64_t sd_xx2:8;     \/* reserved *\/$/;"	m	struct:sys_segment_descriptor	file:
sd_xx3	sys/gdt.c	/^	uint64_t sd_xx3:19;    \/* reserved *\/$/;"	m	struct:sys_segment_descriptor	file:
sd_zero	sys/gdt.c	/^	uint64_t sd_zero:5;    \/* must be zero *\/$/;"	m	struct:sys_segment_descriptor	file:
selector	sys/idt.c	/^    uint16_t selector;$/;"	m	struct:idt_t	file:
set	bin/hello/changePath.c	/^void set(char * args, char** envp){$/;"	f
setPath	bin/hello/changePath.c	/^char * setPath(char* env,char* path,int mode){$/;"	f
setup_tss	sys/gdt.c	/^void setup_tss() {$/;"	f
setupt_proc_vm	sys/process.c	/^setupt_proc_vm(ProcStruct* NewProc)$/;"	f
sh_addr	include/sys/elf.h	/^	uint64_t sh_addr;$/;"	m	struct:Secthdr
sh_addralign	include/sys/elf.h	/^	uint64_t sh_addralign;$/;"	m	struct:Secthdr
sh_entsize	include/sys/elf.h	/^	uint64_t sh_entsize;$/;"	m	struct:Secthdr
sh_flags	include/sys/elf.h	/^	uint64_t sh_flags;$/;"	m	struct:Secthdr
sh_info	include/sys/elf.h	/^	uint32_t sh_info;$/;"	m	struct:Secthdr
sh_link	include/sys/elf.h	/^	uint32_t sh_link;$/;"	m	struct:Secthdr
sh_name	include/sys/elf.h	/^	uint32_t sh_name;$/;"	m	struct:Secthdr
sh_offset	include/sys/elf.h	/^	uint64_t sh_offset;$/;"	m	struct:Secthdr
sh_size	include/sys/elf.h	/^	uint64_t sh_size;$/;"	m	struct:Secthdr
sh_type	include/sys/elf.h	/^	uint32_t sh_type;$/;"	m	struct:Secthdr
shift	sys/keyboard.c	/^unsigned char shift = FALSE;$/;"	v
show_fd_table	sys/tarfs.c	/^void show_fd_table(){$/;"	f
show_file_table	sys/tarfs.c	/^void show_file_table(int fd){$/;"	f
singleCommand	include/parser.h	/^}singleCommand;$/;"	t	typeref:struct:__anon2
size	include/memory.h	/^	int size;$/;"	m	struct:block
size	include/sys/file_table.h	/^	int size;$/;"	m	struct:__anon9
size	include/sys/tarfs.h	/^	char size[12];$/;"	m	struct:posix_header_ustar
size	include/sys/tarfs.h	/^    int size;$/;"	m	struct:__anon5
size	libc/malloc.c	/^    int size;$/;"	m	struct:MCB_header_t	file:
size	sys/gdt.c	/^	uint16_t size;$/;"	m	struct:gdtr_t	file:
size	sys/idt.c	/^		uint16_t size;$/;"	m	struct:idtr_t	file:
size_t	include/stdlib.h	/^typedef uint64_t size_t;$/;"	t
size_t	include/sys/defs.h	/^typedef uint64_t size_t;$/;"	t
sleep	libc/sleep.c	/^unsigned int sleep(unsigned int sec)$/;"	f
sleep_test_case	libc/testCases.c	/^void sleep_test_case(){$/;"	f
special	sys/keyboard.c	/^char special=' ';$/;"	v
ss	include/sys/isr.h	/^    uint64_t ss;$/;"	m	struct:faultStruct
ssize_t	include/stdlib.h	/^typedef int64_t ssize_t;$/;"	t
stack	sys/main.c	/^char stack[INITIAL_STACK_SIZE];$/;"	v
start	sys/main.c	/^void start(uint32_t* modulep, void* physbase, void* physfree)$/;"	f
start_brk	include/sys/process.h	/^    uint64_t end_brk,start_brk;$/;"	m	struct:mm_struct
status	include/sys/process.h	/^enum ProcStatus status;$/;"	m	struct:ProcStruct	typeref:enum:ProcStruct::ProcStatus
stoi	sys/utils.c	/^long stoi(const char *s) $/;"	f
strcat	libc/string.c	/^char *strcat(char *dst, const char *src)$/;"	f
strcmp	libc/string.c	/^int strcmp(const char *str1, const char *str2)$/;"	f
strcpy	libc/string.c	/^char* strcpy(char* dst, const char* src)$/;"	f
strerror	libc/string.c	/^uint64_t strerror(int err)$/;"	f
strlen	libc/string.c	/^int strlen(const char *str)$/;"	f
strstr	libc/string.c	/^const char *strstr(const char *haystack, const char *needle)$/;"	f
substring	bin/hello/stringTokenizer.c	/^char * substring(char* str, int front, int back){$/;"	f
superblock	newfs/newfs.c	/^struct superblock {$/;"	s	file:
sys_brk	sys/syscall.c	/^uint64_t sys_brk(uint64_t n)$/;"	f
sys_chdir	sys/syscall.c	/^int sys_chdir(char* path){$/;"	f
sys_close_directory	sys/syscall.c	/^int sys_close_directory(void* dir){$/;"	f
sys_close_file	sys/syscall.c	/^uint64_t sys_close_file(int fd){$/;"	f
sys_dup2	sys/syscall.c	/^int sys_dup2(int oldfd,int newfd){$/;"	f
sys_execve	sys/syscall.c	/^int sys_execve(const char *arg1,const char *arg2[],const  char* arg3[])$/;"	f
sys_exit	sys/syscall.c	/^void sys_exit(uint64_t error_code){$/;"	f
sys_fork	sys/syscall.c	/^int sys_fork(struct Trapframe* tf)$/;"	f
sys_getcwd	sys/syscall.c	/^uint64_t sys_getcwd(char* buff, uint64_t size){$/;"	f
sys_getpid	sys/syscall.c	/^int sys_getpid(){$/;"	f
sys_lseek_file	sys/syscall.c	/^uint64_t sys_lseek_file(int fd, uint64_t offset, int whence){$/;"	f
sys_open_dir	sys/syscall.c	/^uint64_t sys_open_dir(const char *name){$/;"	f
sys_open_file	sys/syscall.c	/^uint64_t sys_open_file(const char* name){$/;"	f
sys_pipe	sys/syscall.c	/^int sys_pipe(int* pipeFD){$/;"	f
sys_ps	sys/syscall.c	/^int sys_ps()$/;"	f
sys_read_dir	sys/syscall.c	/^uint64_t sys_read_dir(void* dir,char* userBuff){$/;"	f
sys_read_file	sys/syscall.c	/^uint64_t sys_read_file(int fd, char* buf , int numBytes){$/;"	f
sys_read_terminal	sys/syscall.c	/^uint64_t sys_read_terminal(char* buf){$/;"	f
sys_segment_descriptor	sys/gdt.c	/^struct sys_segment_descriptor {$/;"	s	file:
sys_sleep	sys/syscall.c	/^int sys_sleep(void* t){$/;"	f
sys_waitpid	sys/syscall.c	/^int sys_waitpid(uint64_t chpid, uint64_t chstatus, uint64_t choptions)$/;"	f
sys_write	sys/syscall.c	/^void sys_write(uint64_t fd,uint64_t buff,uint64_t len){$/;"	f
syscall_0	include/syscall.h	/^static __inline uint64_t syscall_0(uint64_t n) {$/;"	f
syscall_1	include/syscall.h	/^static __inline int64_t syscall_1(uint64_t n, uint64_t a1) {$/;"	f
syscall_2	include/syscall.h	/^static __inline uint64_t syscall_2(uint64_t n, uint64_t a1, uint64_t a2) {$/;"	f
syscall_3	include/syscall.h	/^static __inline uint64_t syscall_3(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3) {$/;"	f
tabwidth	sys/printf.c	6;"	d	file:
tarfs_entry	include/sys/tarfs.h	/^} tarfs_entry;$/;"	t	typeref:struct:__anon5
tarfs_fs	sys/tarfs.c	/^tarfs_entry tarfs_fs[100];$/;"	v
tarfs_init	sys/tarfs.c	/^void tarfs_init(){$/;"	f
terminal_read	sys/tarfs.c	/^int terminal_read(int file_table_index,char *buf,int numBytesToRead){$/;"	f
terminal_write	sys/tarfs.c	/^int terminal_write(int file_table_index,char *buff,int numBytesToWrite){$/;"	f
test	libc/readdir.c	/^uint64_t test(uint64_t n, uint64_t a1, uint64_t a2, uint64_t a3){$/;"	f
tf	include/sys/process.h	/^struct Trapframe tf;$/;"	m	struct:ProcStruct	typeref:struct:ProcStruct::Trapframe
tf_cs	include/sys/idt.h	/^	uint16_t tf_cs;$/;"	m	struct:Trapframe
tf_ds	include/sys/idt.h	/^	uint16_t tf_ds;$/;"	m	struct:Trapframe
tf_eflags	include/sys/idt.h	/^	uint64_t tf_eflags;$/;"	m	struct:Trapframe
tf_err	include/sys/idt.h	/^	uint64_t tf_err;$/;"	m	struct:Trapframe
tf_es	include/sys/idt.h	/^	uint16_t tf_es;$/;"	m	struct:Trapframe
tf_padding1	include/sys/idt.h	/^	uint16_t tf_padding1;$/;"	m	struct:Trapframe
tf_padding2	include/sys/idt.h	/^    uint32_t tf_padding2;$/;"	m	struct:Trapframe
tf_padding3	include/sys/idt.h	/^	uint16_t tf_padding3;$/;"	m	struct:Trapframe
tf_padding4	include/sys/idt.h	/^    uint32_t tf_padding4;$/;"	m	struct:Trapframe
tf_padding5	include/sys/idt.h	/^	uint16_t tf_padding5;$/;"	m	struct:Trapframe
tf_padding6	include/sys/idt.h	/^    uint32_t tf_padding6;$/;"	m	struct:Trapframe
tf_padding7	include/sys/idt.h	/^	uint16_t tf_padding7;$/;"	m	struct:Trapframe
tf_padding8	include/sys/idt.h	/^    uint32_t tf_padding8;$/;"	m	struct:Trapframe
tf_regs	include/sys/idt.h	/^	struct GpRegs tf_regs;$/;"	m	struct:Trapframe	typeref:struct:Trapframe::GpRegs
tf_rip	include/sys/idt.h	/^	uintptr_t tf_rip;$/;"	m	struct:Trapframe
tf_rsp	include/sys/idt.h	/^	uintptr_t tf_rsp;$/;"	m	struct:Trapframe
tf_ss	include/sys/idt.h	/^	uint16_t tf_ss;$/;"	m	struct:Trapframe
tf_trapno	include/sys/idt.h	/^	uint64_t tf_trapno;$/;"	m	struct:Trapframe
timeTillNow	sys/isr.c	/^unsigned long int timeTillNow=0;$/;"	v
timespec	libc/sleep.c	/^struct timespec$/;"	s	file:
tlb_invalidate	sys/paging.c	/^tlb_invalidate(pml4e_t *pml4e, void *va)$/;"	f
tokenArr	include/stringTokenizer.h	/^	char *tokenArr[50];$/;"	m	struct:__anon4
tokenArr	include/stringtokenizer.h	/^	char *tokenArr[50];$/;"	m	struct:__anon1
tokenize	bin/hello/stringTokenizer.c	/^Token* tokenize(char *str,char* delim){$/;"	f
tot	bin/hello/shell1.c	17;"	d	file:
tss	sys/main.c	/^struct tss_t tss;$/;"	v	typeref:struct:tss_t
tss_t	include/sys/gdt.h	/^struct tss_t {$/;"	s
tv_nsec	include/sys/process.h	/^	int64_t tv_nsec;$/;"	m	struct:K_timespec
tv_nsec	libc/sleep.c	/^	int64_t tv_nsec;$/;"	m	struct:timespec	file:
tv_sec	include/sys/process.h	/^	unsigned int tv_sec;$/;"	m	struct:K_timespec
tv_sec	libc/sleep.c	/^	unsigned int tv_sec;$/;"	m	struct:timespec	file:
type	include/sys/file_table.h	/^	uint64_t type;$/;"	m	struct:__anon9
type	include/sys/process.h	/^enum ProcType type;$/;"	m	struct:ProcStruct	typeref:enum:ProcStruct::ProcType
type	sys/idt.c	/^    unsigned type : 4;$/;"	m	struct:idt_t	file:
typeflag	include/sys/tarfs.h	/^	char typeflag[1];$/;"	m	struct:posix_header_ustar
typeflag	include/sys/tarfs.h	/^    int typeflag;$/;"	m	struct:__anon5
uid	include/sys/tarfs.h	/^	char uid[8];$/;"	m	struct:posix_header_ustar
uint16_t	include/sys/defs.h	/^typedef unsigned short uint16_t;$/;"	t
uint32_t	include/sys/defs.h	/^typedef unsigned int   uint32_t;$/;"	t
uint64_t	include/sys/defs.h	/^typedef unsigned long  uint64_t;$/;"	t
uintptr_t	include/sys/defs.h	/^typedef uint64_t uintptr_t;$/;"	t
uname	include/sys/tarfs.h	/^	char uname[32];$/;"	m	struct:posix_header_ustar
unused	include/sys/gdt.h	/^	uint32_t unused[11];$/;"	m	struct:tss_t
update_screen	sys/printf.c	/^void update_screen(){$/;"	f
va_arg	include/stdarg.h	5;"	d
va_copy	include/stdarg.h	7;"	d
va_end	include/stdarg.h	6;"	d
va_list	include/stdarg.h	/^typedef __builtin_va_list va_list;$/;"	t
va_start	include/stdarg.h	4;"	d
version	include/sys/tarfs.h	/^	char version[2];$/;"	m	struct:posix_header_ustar
vm_end	include/sys/process.h	/^uint64_t    vm_end; $/;"	m	struct:vma_struct
vm_file	include/sys/process.h	/^uint64_t    *vm_file;          \/* mapped file, if any *\/$/;"	m	struct:vma_struct
vm_filesz	include/sys/process.h	/^uint64_t vm_filesz;$/;"	m	struct:vma_struct
vm_flags	include/sys/process.h	/^uint64_t    vm_flags;      \/* flags *\/$/;"	m	struct:vma_struct
vm_mm	include/sys/process.h	/^struct mm_struct    *vm_mm; $/;"	m	struct:vma_struct	typeref:struct:vma_struct::mm_struct
vm_next	include/sys/process.h	/^struct vma_struct   *vm_next;$/;"	m	struct:vma_struct	typeref:struct:vma_struct::vma_struct
vm_offset	include/sys/process.h	/^uint64_t vm_offset;$/;"	m	struct:vma_struct
vm_size	include/sys/process.h	/^uint64_t vm_size;$/;"	m	struct:vma_struct
vm_start	include/sys/process.h	/^uint64_t    vm_start; $/;"	m	struct:vma_struct
vm_type	include/sys/process.h	/^enum SegType vm_type;$/;"	m	struct:vma_struct	typeref:enum:vma_struct::SegType
vma_struct	include/sys/process.h	/^typedef struct vma_struct{$/;"	s
vma_struct	include/sys/process.h	/^}vma_struct;$/;"	t	typeref:struct:vma_struct
waitingfor	include/sys/process.h	/^int waitingfor;$/;"	m	struct:ProcStruct
waitpid	libc/process.c	/^pid_t waitpid(pid_t pid, int *status, int options)$/;"	f
waitpid_test	libc/testCases.c	/^void waitpid_test(){$/;"	f
wakeuptime	include/sys/process.h	/^uint64_t wakeuptime;$/;"	m	struct:ProcStruct
write	include/sys/file_table.h	/^	int (*write)(); \/\/pointer to the device specific write call$/;"	m	struct:__anon9
write	libc/write.c	/^ssize_t write(int fd, const void *buf, size_t count){$/;"	f
write_cursor	include/sys/file_table.h	/^	uint64_t write_cursor;$/;"	m	struct:__anon8
write_file	sys/tarfs.c	/^int write_file(int file_table_index,char *buf,int numBytesToWrite){$/;"	f
write_text	sys/printf.c	/^int write_text(int len) {$/;"	f
writers	include/sys/file_table.h	/^	int writers;$/;"	m	struct:__anon8
x	sys/printf.c	/^static int x=5,y;$/;"	v	file:
y	sys/printf.c	/^static int x=5,y;$/;"	v	file:
zero	sys/idt.c	/^    unsigned zero : 1;$/;"	m	struct:idt_t	file:
